# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

External SLIF Scanning - External scanning for the Scanless interface

=head1 About this document

In this document, use of the Scanless interface's
(SLIF's) internal scanner is called
B<internal scanning>.
The current SLIF only allows internal scanning.
This document describes an interface that allows the use
of an B<external scanner>.
Use of the external scanner is called
B<external scanning>.

The term "scanless" interface is from the parsing
literature.
It is sometimes criticized as misleading because,
of course, an internal scanner is a scanner.
But in the parsing theory literature,
the context of the term is the classic strict definition
of parsing, which required a separate, external scanner as
a previous phase.
In that context,
"scannerless parser" meant a parser which did not require
a separate, external scanner.

=head1 Design goals

The interface is designed to be
implemented more quickly than more fully featured alternatives:
It is low-level
but open-ended.

This interface allows the user to bring in, or to create,
other scanning tools.
The interface allows
internal and external scanners to take turns reading
the input string.
It also allows
an external scanner to
bypass the SLIF's internal scanner completely.

The other tools can be arbitrarily powerful.
Technically, in this interface, they will always
be "children" of a "parent"
Marpa parser,
but the boundary between scanning and parsing is malleable
enough that,
if an application thinks it necessary,
Marpa and the other tools can in effect share the task of parsing.

=head1 Methods for internal scanning

=head2 Changes to C<Marpa::R2::Scanless::R::read()>.

The C<Marpa::R2::Scanless::R::read()> method remains,
but has two additional arguments,
so that it can be called as
C<< $slr->read($input_string, $start, $length) >>.
The two new arguments, C<$start> and C<$length>, are optional.

The first argument, C<$input_string>, is as before.
As a reminder, this first argument sets the input string for the SLIF.
The input string can only be set once for an SLIF recognizer
and cannot be changed once set.

In C<< $slr->read($input_string, $start, $length) >>,
C<$start> is the position in the input string to begin at,
and C<$length> is the number of codepoints to read.
Negative lengths follow the usual convention so that -1 is the length of the input string.
C<$start> defaults to the "current" position,
and C<$length> defaults to -1, so that the default
In C<< $slr->read($input_string) >> continues to behave as currently implemented.

At present C<read()> is documented as returning a non-negative integer.
In this interface, its return value will be the new current position,
as defined in the next section.

=head2 Current position

The B<current position in the input stream>, more usually simply
called the B<current position>, is a position in the input string.
Positions are zero-based, so that position 0 points to the first
character, if it exists.
A current position equal to the length of the input string
indicates "end of string",
and does
not point to any character.

In this interface, when the current position
moves, it does not necessarily advance -- it
can skip forward,
or can be positioned to an earlier location.
The application can skip sections of the input string.
The application is also free to
revisit spans of the input string as often as it wants.

Here are the guarantees:

=over 4

=item *

Initially, the current position is 0.

=item *

The current position will never be negative.

=item *

The current position will never be past the "end of string".

=back

=head2 How internal scanning works

After the C<read()> method, the current position will indicate how far
in the input stream C<read()> actually read.

=over 4

=item *

As already stated, the current position will never advance past
the end of string.

=item *

If a non-negative C<$length> argument was specified to C<read()>,
C<read()> will pause when the current position is C<$start+$length>.

=item *

If a negative C<$length> argument was specified to C<read()>,
C<read()> will pause when the current position is
C<$length + 1 + length $input_string>.

=item *

The application can specify that the read will
pause when it encounters certain lexemes,
as specified below.

=item *

An abend
in the C<read()> will cause the current position to
be an unspecified value.

=back

=head2 New C<< $slr->resume($start, $length) >> method

The C<< $slr->resume($start, $length) >> method resumes
the SLIF's internal scanning.
The scan continues as specified by C<$start> and C<$length>.
The next pause in internal scanning will take place
according to the rules for internal scanning,
L<as described
above|/"How internal scanning works">.

=head1 Methods for external scanning

=head2 New C<< $slr->g1_alternative($symbol, $value) >> method

The C<< $slr->g1_alternative($symbol, $value) >> method
bypasses G0, reading an alternative directly into G1 with symbol name C<$symbol>,
lexeme value C<$value>.

=head2 New C<< $slr->g1_lexeme_complete($start, $length) >> method

A new C<< $slr->g1_lexeme_complete($start, $length) >> method will
correspond to an C<earleme_complete()> for G1.
Current position in the input stream
will be moved to C<$start+$length>.

=head2 New C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >> method

A new C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >> method
will be the equivalent of

    $slr->g1_alternative($symbol, $value)
    $slr->g1_lexeme_complete($start, $length)

Current position in the input stream will be moved to C<$start+$length>.

=head2 The input string

For error message purposes,
even external lexemes are required to correspond to a span of the input string.
If an application uses external lexemes which have
no natural relationship
to a span of the input string, it must arrange an artificial relationship.

One way to do this is to have a artificial preamble to the real text.
For example, the first 7 characters of the input string could be
the artificial preamble containing the characters "C<NO TEXT>",
which is then followed by what the application considers
the "real" text.
In this case, the first C<read()> could take the form
C<< $slr->read($input_string, 7) >>.
Lexemes corresponding to the artificial preamble would be read
with method calls similar to
C<< $slr->g1_read_lexeme($symbol_name, $value, 0, 7) >>.

=head1 Positions in the input string

=head2 New C<< $slr->pause_span() >> method

    my ($start, $length) = $slr->pause_span()

Most applications will want to be guided by the current position,
but current position depends on whether or not the lexeme was read
or not, which may be inconvenient for some applications.
The values returned by C<pause_span()> are
unaffected by whether or not the lexeme which caused
the pause was actually read,
and are unaffected by the current position of
the input stream.

=head2 New C<< $slr->pos() >> method

Queries the current position.

=head2 New C<< $slr->pos_set($new_pos) >> method

Changes the current position to C<$new_pos>.

=head1 Pausing the internal scan

=head2 C<:lexeme> psueudo-rules

      :lexeme ::= variable pause => before

The SLIF DSL will be extended to include C<:lexeme> pseudo-rules.
Initially, their purpose would be to support the C<pause> adverb,
as described in the next section.

As a side effect, C<:lexeme> pseudo-rules
will allow applications to declare
symbols to be lexemes.
The previous definition of lexeme will continue to apply,
so that the only effect of these "lexeme declarations"
will be to cause a fatal error if the declared lexeme
is not a lexeme
according to the previous rules.
Applications may find this behavior useful for debugging,
and for documentating their grammars.

=head2 The C<pause> adverb

The new
C<:lexeme> pseudo-rules of the SLIF DSL
will allow a new C<pause> adverb.
If C<pause> is set, a C<Marpa::R2::Scanless::R::read()> will pause when that lexeme is encountered.
For a pause to occur at a lexeme, it must potentially be acceptable to G1,
but whether or not it is actually read depends on the value of the C<pause>
adverb.

Possible values of C<pause> are C<before> and C<after>.
If the value of C<pause> is C<after>, the lexeme is read by G1.
If the value of C<pause> is C<before>, the lexeme is not read by G1.

Multiple lexemes may be found at a single G1 parse location,
and these may have any mixture of C<pause> adverbs.
The following rules govern the location of the current position
in the input stream when internal scanning is paused
because of one or more lexemes with a C<pause> setting:

=over 4

=item *

If the C<pause> value
of any of the lexemes causing the pause is C<after>,
the current position in the input stream will be the position 
where the lexeme ended.

=item *

If the C<pause> value
of all of the lexemes causing the pause is C<before>,
the current position in the input stream will be the position 
where the lexeme started.

=back

=head1 Capabilities

The intent of the design is that possibilities
for external scanning be extremely open-ended.
The following ideas are intended to be suggestive
rather than exhaustive.

=head2 Replacing the Stuifzand (BNF) interface

In a pedantic sense, the SLIF must always start off
with the internal scanner,
but it can pause the internal scan after zero codepoints,
One way to do this is with the following code:

    $slr->read($input_string, 0, 0)

When an application pauses internal scanning,
it never needs to resume it.
This means that a separate Stuifzand (BNF) interface
no longer serves any purpose.
The BNF interface will be de-emphasized,
and the documentation
rearranged to reflect this.

=head2 Lookahead and backtracking

Most of the desire to use lookahead and backtracking
with Marpa
comes from an underappreciation of its capabilities.
Nonetheless, there are some situations where
lookahead and/or backtracking could be genuinely useful
in combination with Marpa.
Both can be performed in an external scanner.

=head2 Sub-parsers

An external scanner could, in fact, be a sub-parser.
The sub-parser could be another, more specialized,
Marpa grammar.
Or it could be another grammar
that is thought to
work better for portions of the
parse, hooked up as a sub-parser.
For example, the application could switch back and forth
between Marpa and regular expressions,
or between Marpa and recursive descent.

=head2 G0 actions

Currently the G0 grammar cannot perform actions -- it can only
recognize literal lexemes.
As a special case of sub-parser use,
another Marpa parser can be hooked up
that performs actions and returns the result to
the parent grammar via C<g1_read>.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# vim: expandtab shiftwidth=4:
