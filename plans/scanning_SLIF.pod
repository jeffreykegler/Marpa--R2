# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

SLIF Scanning - Proposed SLIF interface for custom scanners

=head1 About this document

This is an outline of a proposed extension to the Scanless interface (SLIF)
that will allow it to support an application's customized scanning.
Scanning can be handed over entirely to the application,
or the SLIF and the application can takes turns doing the scanning.

=head1 Design considerations

The interface is designed so that it could be
implemented fairly quickly.
The interface is low-level
and open-ended.
It allows the user to bring in, or to create,
powerful scanning tools to supplement the SLIF's scanning,
and even to augment Marpa's parsing, if that is thought
necessary.

=head1 The proposed interface

=head2 New arguments to C<Marpa::R2::Scanless::R::read()>.

The C<Marpa::R2::Scanless::R::read()> method remains,
but has two additional arguments,
so that it can be called as
C<< $slr->read($input_string, $start, $length) >>.
The two new arguments, C<$start> and C<$length>, are optional.

The first argument, C<$input_string>, is as before.
As a reminder, this first argument sets the input string for the SLIF.
The input string can only be set once for an SLIF recognizer
and cannot be changed once set.

In C<< $slr->read($input_string, $start, $length) >>,
C<$start> is the position in the input string to begin at,
and C<$length> is the number of codepoints to read.
Negative lengths follow the usual convention so that -1 is the length of the input string.
C<$start> defaults to the "current" position,
and C<$length> defaults to -1, so that the default
In C<< $slr->read($input_string) >> continues to behave as currently implemented.


=head2 New return value for C<Marpa::R2::Scanless::R::read()>

At present C<read()> is documented as returning a non-negative integer.
In this interface, its return value will be the new current position,
as defined in the next section.

=head2 Current position

The B<current position in the input stream>, more usually simply
called the B<current position>, is a position in the input string.
(As a reminder, the input string is specified to the C<read()> call,
and cannot be changed once set.)

Positions are zero-based, so that position 0 points to the first
character, if it exists.
A current position equal to the length of the input string
indicates "end of string",
and does
not point to any character.

In this interface, when the current position
moves, it does not necessarily advance -- it
can skip forward,
or be 
can be positioned to an earlier location.
It can revisit the same locations as many time as the
application specifies.

Here are the guarantees:

=over 4

=item *

Initially, the current position is 0.

=item *

The current position will never be negative.

=item *

The current position will never be past the "end of string".

=back

After the C<read()> method, the current position will indicate how far
in the input stream C<read()> actually read.

=over 4

=item *

As already stated, the current position will never advance past
the end of string.

=item *

If a non-negative C<$length> argument was specified to C<read()>,
C<read()> will not read past a current position of C<$start+$length>.

=item *

If a negative C<$length> argument was specified to C<read()>,
C<read()> will not read past a current position of
C<$length + 1 + length $input_string>.

=item *

The application can specify that the read will
"break" when it encounters certain lexemes,
as specified below.

=item *

An abend
in the C<read()> will cause the current position to
be an unspecified value.

=back

=head2 A new C<< $slr->resume($start, $length) >> method

=head2 A new C<< $slr->g1_alternative($symbol, $value) >> method

The C<< $slr->g1_alternative($symbol, $value) >> method
bypasses G0, reading an alternative directly into G1 with symbol name C<$symbol>,
lexeme value C<$value>.

=head2 A new C<< $slr->g1_lexeme_complete($start, $length) >> method

A new C<< $slr->g1_lexeme_complete($start, $length) >> method will
correspond to an C<earleme_complete()> for G1.
Current position in the input stream
will be moved to C<$start+$length>.

=head2 A new C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >> method

Add a C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >> method,
which is the equivalent of C<< $slr->g1_alternative($symbol, $value) >>,
followed by C<< $slr->g1_lexeme_complete($start, $length) >>.
Current position in the input stream
will be moved to C<$start+$length>.

=head2 Jumping around in the input string

If only for error message purposes,
all lexemes correspond to a span of the input string, but this correspondence need only be conceptual.
For example, you could put some sort of error message in the first 42 characters, start the main reading after them with
C<< $slr->read($input_string, 42) >>,
and read all your custom lexemes with C<< $slr->g1_read_lexeme($symbol_name, $value, 0, 42) >>.

=head2 The C<break> adverb

In the
SLIF DSL, adverbs will have a new C<break> adverb.
If C<break> is set, a C<Marpa::R2::Scanless::R::read()> will stop when that lexeme is encountered.
Possible values of C<break> are C<accept>, C<reject> and C<skip>.
If the value of C<break> is C<accept>, the lexeme is read, otherwise it is not read.

If at a given G1 parse location,
one of the values of C<break> is either C<accept> or C<skip>,
the current position in the input stream will be at the position 
where the lexeme ended.
If at a given G1 parse location,
all of the values of C<break> are C<reject>,
the current position in the input stream will be at the position
where the lexeme started.

=head2 The current position

An important part of this interface is its idea of
"current" position, which has been referred to several times above.
Current position can be queried with C<< $slr->pos() >>
and set with C<< $slr->pos_set($new_pos) >>.

=head1 Capabilities

=head2 Replacing the Stuifzand (BNF) interface

Once the SLIF allows the user to provide their own scanner,
the separate Stuifzand (BNF) interface will
no longer serve any purpose,
and will be de-emphasized.

=head2 Backtracking and lookahead

Most of the desire to backtrack and perform lookahead for Marpa
comes from an underappreciation of its capabilities.
Nonetheless, there are some situations where backtracking
and/or lookahead is genuinely useful with Marpa.
And the ability to backtrack and look ahead will keep
programmers used to weaker parsers in their "comfort zone".

=head2 Subgrammars

The scanner could, in fact, be a subgrammar.
The subgrammar could, be another, specialized,
Marpa grammar.
Or it could be another grammar
that is thought to
work better for portions of the
parse, hooked up as a "subgrammar".
For example, the application could switch back and forth
between Marpa and regular expressions,
or between Marpa and recursive descent.

=head2 G0 actions

Currently the G0 grammar cannot perform actions -- it can only
recognize literal lexemes.
As a special case of subgrammar use,
another Marpa parser can be hooked up
that performs actions and returns the result to
the parent grammar via C<g1_read>.

=head2 Other possibilities

The interface is in fact open-ended.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# vim: expandtab shiftwidth=4:
