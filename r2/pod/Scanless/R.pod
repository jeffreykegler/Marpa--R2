# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::Scanless::R - Scanless interface recognizers

=head1 Synopsis

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );
    my $self = bless { grammar => $grammar }, 'My_Actions';
    $self->{recce} = $recce;
    local $My_Actions::SELF = $self;

    if ( not defined eval { $recce->read($p_input_string); 1 }
        )
    {
        ## Add last expression found, and rethrow
        my $eval_error = $EVAL_ERROR;
        chomp $eval_error;
        die $self->show_last_expression(), "\n", $eval_error, "\n";
    } ## end if ( not defined eval { $event_count = $recce->read...})

    my $value_ref = $recce->value();
    if ( not defined $value_ref ) {
        die $self->show_last_expression(), "\n",
            "No parse was found, after reading the entire input\n";
    }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: Scanless recognizer semantics
partial: 1
normalize-whitespace: 1

    package My_Actions;

    our $SELF;
    sub new { return $SELF }

    sub do_parens    { shift; return $_[1] }
    sub do_add       { shift; return $_[0] + $_[2] }
    sub do_subtract  { shift; return $_[0] - $_[2] }
    sub do_multiply  { shift; return $_[0] * $_[2] }
    sub do_divide    { shift; return $_[0] / $_[2] }
    sub do_pow       { shift; return $_[0]**$_[2] }
    sub do_first_arg { shift; return shift; }
    sub do_script    { shift; return join q{ }, @_ }

=for Marpa::R2::Display::End

=head1 About this document

This page is the reference document for the recognizer objects
of Marpa's Scanless interface.

=head1 Locations

=head2 Input stream locations

In this document, the word "location" refers
to location in the input stream
unless otherwise specified.
Another idea of location, G1 location,
also exists, but its use is restricted to
tracing methods.

=head2 Negative locations

Several methods allow locations and lengths to be specified
as negative numbers.
A negative location is a location counted
from the end, so that -1 means the
last location of the string,
-2 the second to last location, etc.
A negative length assumes that a start location
has been specified and indicates a distance to a location
counted from the end.
A length of -1 indicates the distance to the end of the string,
-2 indicates the distance to the character just before the
end of the string,
etc.

For example, suppose that we are dealing with input stream locations.
The span (C<0, -1>) is the entire input stream.
The span (C<-1, -1>) is the
last character of input stream.
the span (C<-2, -1>) is the
last two characters of the input stream.
The span (C<-2, 1>) is the 
second to last character of the input stream.

=head1 Internal and external scanning

The SLIF (Scanless interface) is so-called because
it does not require the application to supply a scanner (lexer).
The SLIF contains its own lexer,
one whose use is integrated into
its syntax.
In this document, use of the SLIF's
internal scanner is called
B<internal scanning>.

The SLIF allows applications that find it useful to
do their own scanning.
When an application
bypasses the SLIF's internal scanner
and does its own scanning,
this document calls it
B<external scanning>.
An application can use
external scanning to supplement internal 
scanning,
or it can bypass the SLIF's internal scanner entirely.

=head1 Current location

The B<current location in the input stream>, more usually simply
called the B<current location>, is a location in the input stream.
Locations are zero-based, so that location 0 points to the first
character, if it exists.
A current location equal to the length of the input string
indicates "end of string",
and does
not point to any character.

In this interface, when the current location
moves, it does not necessarily advance -- it
can skip forward,
or can be positioned to an earlier location.
The application can skip sections of the input string.
The application is also free to
revisit spans of the input string as often as it wants.

Here are the guarantees:

=over 4

=item *

Initially, the current location is 0.

=item *

The current location will never be negative.

=item *

The current location will never be past the "end of string".

=back

=head1 How internal scanning works

The SLIF always starts scanning with scanning using the C<read()>
method.
Pedantically, this means scanning always begins with an internal
scanning phase,
but that first phase may be of zero length,
and after than internal scanning does not have to be resumed.

Internal scanning is resumed with the C<resume()> method.
Both the C<read()> and C<resume()> methods require the application
to specify a span in the input stream.
The C<read()> method sets the input stream,
and that input stream is the one used by all C<resume()> method calls
for that recognizer.

In what follows, the term "internal scanning method"
refers to either the C<read()> or the C<resume()> method.
After an internal scanning method,
the current location will indicate how far
in the input stream the internal scanning method actually read.
If the internal scanning method was paused, the current
location will be the one before which it paused.
If the internal scanning method reached the end of string,
the current location will be the end of string.
The return value of the C<read()> and the C<resume()> method is
the current location.

=over 4

=item *

As already stated, the current location will never advance past
the end of string.

=item *

If its C<$length> argument was non-negative,
an internal scanning method
will pause when the current location is C<$start+$length>.

=item *

If its C<$length> argument was negative,
an internal scanning method
will pause when the current location is
C<$length + 1 + length $input_string>.

=item *

An internal scanning method
will pause when it encounters certain lexemes,
as specified in the DSL with the C<pause> adverb.

=item *

An abend
in an internal scanning method causes the current location to
be an unspecified value.

=back

=head1 The input string

For error message purposes,
even external lexemes are required to correspond to a span of the input string.
It may be the case that an application find it useful to
add lexemes that
have no natural relationship
to a span of the input string.
Using an external scanner, an application can read these lexemes,
but it must set up a relationship to the input stream,
even if that relationship is completely artificial.

One way to do this is to put a artificial preamble in front of
the input stream.
For example, the first 7 characters of the input stream could be
an preamble containing the characters "C<NO TEXT>".
This preamble could be immediately followed by the "real" text.
In this case, the initial call to the C<read()> method
could take the form
C<< $slr->read($input_string, 7) >>.
Lexemes corresponding to the artificial preamble would be read
using a method call similar to
C<< $slr->lexeme_read($symbol_name, 0, 7, $value) >>.

=head1 Constructor

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );

=for Marpa::R2::Display::End

The C<new()> method is the constructor for SLIF recognizers.
An example of its use is L<above|/"Synopsis">.
The C<new()> constructor accepts a hash of named arguments.
The following named arguments are allowed:

=head2 grammar

The C<new> method is required to have
a C<grammar> named argument.  Its
value must be
an SLIF grammar object.

=head2 too_many_earley_items

The C<too_many_earley_items> argument is optional,
and very few applications will need it.
If specified, it sets the B<Earley item warning threshold> to
a value other than its default.
If an Earley set becomes larger than the
Earley item warning threshold,
a recognizer event is generated,
and
a warning is printed to the trace file handle.

Marpa parses from any BNF,
and can handle grammars and inputs which produce large
Earley sets.
But parsing that involves large Earley sets can be slow.
Large Earley sets
are something most applications can,
and will wish to, avoid.

By default, Marpa calculates
an Earley item warning threshold
for the G1 recognizer
based on the size of the
G1 grammar,
and for each G0 recognizer based on the size
of the G0 grammar.
If the
Earley item warning threshold is changed from its default,
the change applies to both G0 and G1 -- currently
there is no way to set them separately.

The default threshold will never be less than 100.
If the Earley item warning threshold is set to 0,
no recognizer event is generated,
and
warnings about large Earley sets are turned off.

=head2 trace_terminals

If non-zero, traces the lexemes --
those tokens passed from the G0 parser to
the G1 parser.
This named argument is the best way to follow
what the G0 parser is doing,
but it is also very helpful for tracing the G1 parser.

=head2 trace_values

This named argument is passed on
to the G1 recognizer.
See L<Marpa::R2::Recognizer/"trace_values">

=head2 trace_file_handle

The value is a file handle.
Trace output and warning messages
go to the trace file handle.
By default the trace file handle is C<STDERR>.

=head1 Basic mutators

=head2 read()

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    $recce->read($p_input_string);

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: SLIF external read example
partial: 1
normalize-whitespace: 1

    $recce->read( \$string, 0, 0 );

=for Marpa::R2::Display::End

Given a pointer to an input string,
parses it according to the grammar.
Only a single call to C<read()>
is allowed for a scanless
recognizer.

C<read()> recognizes
optional second and third arguments.
The second argument is a location in the input string
at which internal scanning will start.
The third argument is the length of the section
of the input string to be scanned before pausing.
The default start location is zero.
The default length is -1.
Negative locations and lengths have the standard
interpretation, as L<described above|/"Negative locations">.

One important case is where start location and length
are both specified as zero.
This pauses internal scanning immediately and can be
used to hand control over completely to an external
scanner.

On failure, throws an exception.
The call is considered successful
if it ended because a parse was found,
or because internal scanning was paused.
On success, C<read()> returns the location in the input
string before which internal scanning ended.
This value may be zero.

=head2 value()

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $value_ref = $recce->value();

=for Marpa::R2::Display::End

Has the same effect as a C<value()> call
on the G1 recognizer.
See L<Marpa::R2::Recognizer/"value()">.

=head1 Mutators for external scanning

=head2 lexeme_alternative()

=for Marpa::R2::Display
name: SLIF lexeme_alternative() example
partial: 1
normalize-whitespace: 1

            if ( not defined $recce->lexeme_alternative($token_name) ) {
                die
                    qq{Parser rejected token "$long_name" at position $start_of_lexeme, before "},
                    substr( $string, $start_of_lexeme, 40 ), q{"};
            }

=for Marpa::R2::Display::End

The C<lexeme_alternative()> method
allows an external scanner to read
ambiguous tokens.
Most applications 
will prefer the simpler C<lexeme_read()>.

C<lexeme_alternative()> takes one or two argument.
The first, required, argument is the name of a symbol to be read
at the current location.
The second, optional, argument is the value of the symbol.

Any number of tokens may be read using C<lexeme_alternative()>
without advancing the current location.
This allows an application to use ambiguous tokens.
To complete the reading at a location,
and advance the current location to the next location,
use the C<lexeme_complete()> method.

If the value argument is omitted,
the token's value will a string
which contains the corresponding substring
of the input stream.
(The token's location in the input stream will be set
by the lexeme_complete() method.)
Omitting the value argument does not have the same
effect as passing an explicit Perl C<undef>.
If the second argument is an explicit Perl C<undef>,
the value of the lexeme will be a Perl C<undef>.

On success, returns a non-negative number.
Returns undef if the token was rejected.
Failures are thrown as exceptions.

=head2 lexeme_complete()

=for Marpa::R2::Display
name: SLIF lexeme_alternative() example
partial: 1
normalize-whitespace: 1

            next TOKEN
                if $recce->lexeme_complete( $start_of_lexeme,
                        ( length $lexeme ) );

=for Marpa::R2::Display::End

The C<lexeme_alternative()> allows an external scanner to read
ambiguous tokens.
Most applications will prefer the simpler C<lexeme_read()>.

The C<lexeme_complete()>
requires two arguments,
a input stream start location and a length.
Negative values are allowed and are interpreted
as L<described above|/"Negative locations">.
This span will be treated as the section of the input stream
that corresponds to the tokens read at the current location.
This correspondence may be artificial, but a span must
always be specified.

The C<lexeme_complete()>
method completes the reading of
alternative tokens at the current location,
and advances the current location by one.
The location of the tokens in the input stream will be as
indicated by 

=head2 lexeme_read()

=for Marpa::R2::Display
name: SLIF read/resume example
partial: 1
normalize-whitespace: 1

       $re->lexeme_read('lstring', $start, $length, $value) // die;

=for Marpa::R2::Display::End

=for Marpa::R2::Display
ignore: 1

    $slr->lexeme_read($symbol, $start, $length, $value)

=for Marpa::R2::Display::End

is the equivalent of

=for Marpa::R2::Display
ignore: 1

    $slr->lexeme_alternative($symbol, $value)
    $slr->lexeme_complete($start, $length)

=for Marpa::R2::Display::End

Current location in the input stream will be moved to C<$start+$length>.

=head2 resume()

=for Marpa::R2::Display
name: SLIF read/resume example
partial: 1
normalize-whitespace: 1

    my $re = Marpa::R2::Scanless::R->new( { grammar => $self->{grammar} } );
    my $length = length $string;
    for ( my $pos = $re->read(\$string); $pos < $length; $pos = $re->resume()) {
       my ($start, $length) = $re->pause_span();
       my $value = substr $string, $start+1, $length-2;
       $value = decode_string($value) if -1 != index $value, '\\';
       $re->lexeme_read('lstring', $start, $length, $value) // die;
    }
    my $value_ref = $re->value();
    return ${$value_ref};

=for Marpa::R2::Display::End

The C<resume()> method takes two arguments,
a start position and a length.
The default start position is the current position.
The default length is -1.
Negative arguments are interpreted
as L<described above|/"Negative locations">.

The C<resume()> method resumes
the SLIF's internal scanning,
L<as described
above|/"How internal scanning works">.

On success, C<resume()> moves
the current position to where it paused,
or to the EOS.
The return value is the new current position.
On unthrown failure,
C<resume()> return a Perl C<undef>.

=head1 Accessors

=head2 line_column()

# Marpa::R2::Display
# name: SLIF trace example

       my ($start, $length) = $re->pause_span();
       my ($line, $column) = $re->line_column($start);

# Marpa::R2::Display::End

The C<line_column()> method accepts one, optional, argument,
a location in the input stream.
The location defaults to the current location.
It returns the corresponding line and column position,
as a 2-element array.
The first element of the array is the line position,
and the second element is the column position.

Numbering of lines and columns is 1-based,
following UNIX editor tradition.
A line is considered to end with any newline sequence
as defined in the
Unicode Specification 4.0.0, Section 5.8.
Specifically, a line ends with one of the following:

=over 4

=item *

a LF (line feed U+000A);

=item * 

a CR (carriage return, U+000D), when it is not followed by a LF;

=item *

a CRLF sequence (U+000D,U+000A);

=item *

a NEL (next line, U+0085);

=item *

a VT (vertical tab, U+000B);

=item *

a FF (form feed, U+000C);

=item *

a LS (line separator, U+2028) or

=item *

a PS (paragraph separator, U+2029).

=back

=head2 literal()

# Marpa::R2::Display
# name: SLIF trace example

   my $literal_string = $re->literal($start, $length);

# Marpa::R2::Display::End

The C<literal()> method accepts two arguments,
the start location and length of a span in the
input stream.
It returns the substring of the input stream
corresponding to that span.

=head2 pause_lexeme()

# Marpa::R2::Display
# name: SLIF trace example

   my $lexeme = $re->pause_lexeme();

# Marpa::R2::Display::End

The C<pause_lexeme()> method accepts no arguments,
and returns the name of the lexeme which caused the most
recent pause.
The pause lexeme is initially undefined
and it is reset to undefined at the beginning of
each call to the C<read()> or C<resume()> methods.

Not every pause is caused by a lexeme.
A pause often occurs because
of the length argument of an internal scanning method.
When the most recent pause was not caused by a lexeme,
the pause lexeme is undefined.
C<pause_lexeme()> returns a Perl C<undef> when
the pause lexeme is undefined.

=head2 pause_span()

=for Marpa::R2::Display
name: SLIF read/resume example
partial: 1
normalize-whitespace: 1

   my ($start, $length) = $re->pause_span();

=for Marpa::R2::Display::End

The C<pause_span()> method accepts no arguments,
and returns the "pause span" as a 2-element array.
The "pause span" is
the start location and length of the lexeme which caused
the most recent pause.
The pause span is initially undefined
and it is reset to undefined at the beginning of
each call to the C<read()> or C<resume()> methods.

A pause is not always caused by a lexeme -- the internal
scanning may be paused
because of the length argument of an internal scanning method.
When the most recent pause was not caused by a lexeme,
no span can be associated with it,
and the pause span is undefined.
C<pause_span()> returns a Perl C<undef> if
the pause span is undefined.

=head1 Trace methods

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    sub show_last_expression {
        my ($self) = @_;
        my $recce = $self->{recce};
        my ( $g1_start, $g1_length ) = $recce->last_completed('Expression');
        return 'No expression was successfully parsed' if not defined $g1_start;
        my $last_expression = $recce->substring( $g1_start, $g1_length );
        return "Last expression successfully parsed was: $last_expression";
    } ## end sub show_last_expression

=for Marpa::R2::Display::End

=head2 G1 locations

This section on trace methods often 
describes location in terms of 
G1 Earley sets.
G! Earley set locations are B<not>
the same as
input stream locations.
G1 Earley set location
is more often called simply G1 location.

G1 length is length in Earley sets.
For a G1 span, its
G1 end location will
always be the G1 start location plus the G1 length.

=head2 last_completed()

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    my ( $g1_start, $g1_length ) = $recce->last_completed('Expression');

=for Marpa::R2::Display::End

Given the name of a symbol,
returns the start G1 location and
G1 length of the most recent match.
If there was more than one most recent match, it returns
the longest.
If there was no match, returns the empty array in array context
and a Perl false in scalar context.

=head2 last_completed_range()

Use of this method is discouraged in favor of 
L</"last_completed()">.
Given the name of a symbol,
returns the G1 start and G1 end locations of most recent match.
If there was more than one most recent match, it returns
the longest.
If there was no match, returns the empty array in array context
and a Perl false in scalar context.

=head2 range_to_string()

Use of this method is discouraged in favor of 
L</"substring()">.
Given a G1 start and a G1 end location, returns the substring of the input
string that is between the two.

=head2 show_progress()

=for Marpa::R2::Display
name: Scanless show_progress() synopsis
partial: 1
normalize-whitespace: 1

    my $show_progress_output = $recce->show_progress();

=for Marpa::R2::Display::End

Has the same effect as a C<show_progress()> call
on the G1 recognizer.
See L<Marpa::R2::Recognizer/"show_progress()">.
If locations are specified as arguments to
C<show_progress()>, they need to be 
G1 locations.

=head2 substring()

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    my $last_expression = $recce->substring( $g1_start, $g1_length );

=for Marpa::R2::Display::End

Given a G1 start location and its G1 length, returns a substring of the input
string.
A length of zero will produce a zero-length string.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:

