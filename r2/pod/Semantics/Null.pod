# Copyright 2012 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Semantics::Null - How Marpa evaluates null rules and symbols

=head1 DESCRIPTION

=head2 Nulled symbols

In Marpa parses, some symbols can be nulled --
in other words they can derive the zero-length, or null, string.
Which symbols can be, or are, nulled, depends on the grammar
and the input.
When a symbol or rule is not nulled,
the symbol is said to be B<visible>.

Even the start symbol can be nulled,
in which case the entire parse derives the null string.
A parse in which the start symbol is nulled is
called a B<null parse>.

When evaluating a parse, the symbols are
assigned values as described
L<in the semantics document|Marpa::R2::Semantics>.
This document provides additional detail on the assignment
of values to nulled symbols.

The B<null value of a symbol> comes from
that symbol's C<null_value> property,
if one is defined.
Otherwise, the null value of the symbol
comes from the grammar's
default null value, as defined by the grammar's
L<C<default_null_value>|Marpa::R2::Grammar/default_null_value>
named argument.
If neither the symbol C<null_value> property
or the grammar's
L<C<default_null_value>|Marpa::R2::Grammar/default_null_value>
named argument
is defined,
a symbol's null value is "whatever".
"Whatever" here means
that the value may vary from instance to
instance and cannot be relied on
in any way.

Marpa optimizes for "whatever" null values.
Null values often are not used for anything,
and in those case applications that
allow "whatever" null values
can have better performance.

=head2 Null subtrees

A null subtree is a subtree all of whose symbols and rules are nulled.
Marpa prunes
all null subtrees back to their topmost nulled symbol.

The "lost" semantics of the non-topmost symbols and rules
of null subtrees is usually not missed.
Nulled subtrees cannot contain input,
and therefore do no contain token symbols.
So no token values are lost when
nulled subtrees are pruned.
As bushy as a null subtree might be,
all of its symbols and rules are nulled.

Since nulled symbols and rules correspond to zero-length strings,
so we are literally dealing here with
the "semantics of nothing".
In theory the semantics of nothing can be arbitrarily complex.
In practice it should be possible to keep them simple.
But if an application actually needs it,
Marpa could implement an arbitrarily complex,
and even a dynamic,
"semantics of nothing",
as described below.

=head2 Nullable Rules

Some BNF rules and sequences may sometimes be nulled,
and sometimes not.
This offer some potential for suprising the programmer,
because their value comes from two different sources,
depending on whether they are nulled or not.

When a rule is nulled, its value is the null value
of its B<LHS symbol>.
When a rule is not nulled,
it value comes from the action for the rule.
It's up to the
application to ensure that
the nulled value of the LHS symbol,
and the semantics of the visible rule,
"work together" in a way that makes sense
in the context of
the grammar.

=head2 Nullable Sequences

What was just said about nullable rules applies to nullable seqeunces.
Sequence rules are nullable rules
if they have a C<min> rule property of 0.
When a sequence contains zero items, it must derive the zero-length string,
and the sequence is a nulled rule.

Nullable sequence rules behave in the same way 
as nullable BNF rules.
When the a nullable sequence rule is nulled,
its semantics comes from the null value for its left hand side symbol.
When the a nullable sequence rule is not nulled,
its semantics come from the rule.
If a nulled sequence is in a nulled subtree,
but that nulled sequence
is not the topmost rule of that subtree,
then its semantics will be completely ignored.

=head1 EXAMPLE

As already stated,
Marpa prunes every null subtree back to its topmost
null symbol.
Here is an example:

=for Marpa::R2::Display
name: Null Value Example
perltidy: '-dcsc -sil=0'

    sub L {
        shift;
        return 'L(' . ( join q{;}, map { $_ // '[ERROR!]' } @_ ) . ')';
    }

    sub R {
        shift;
        return 'R(' . ( join q{;}, map { $_ // '[ERROR!]' } @_ ) . ')';
    }

    sub S {
        shift;
        return 'S(' . ( join q{;}, map { $_ // '[ERROR!]' } @_ ) . ')';
    }

    my $grammar = Marpa::R2::Grammar->new(
        {   start   => 'S',
            actions => 'main',
            rules   => [
                [ 'S', [qw/L R/] ],
                [ 'L', [qw/A B X/] ],
                [ 'L', [] ],
                [ 'R', [qw/A B Y/] ],
                [ 'R', [] ],
                [ 'A', [] ],
                [ 'B', [] ],
                [ 'X', [] ],
                [ 'X', [qw/x/] ],
                [ 'Y', [] ],
                [ 'Y', [qw/y/] ],
            ],
            symbols        => {
                L => { null_value => 'null L' },
                R => { null_value => 'null R' },
                A => { null_value => 'null A' },
                B => { null_value => 'null B' },
                X => { null_value => 'null X' },
                Y => { null_value => 'null Y' },
            },
        }
    );

    $grammar->precompute();

    my $recce = Marpa::R2::Recognizer->new( { grammar => $grammar } );

    $recce->read( 'x', 'x' );

=for Marpa::R2::Display::End

If we write the unpruned parse tree
in pre-order, depth-first, indenting children
below their parents, we get something like this:

=for Marpa::R2::Display
ignore: 1

        0: Visible Rule: S := L R
             1: Visible Rule L := A B X
                 1.1: Nulled Symbol A
                 1.2: Nulled Symbol B
                 1.3: Token, Value is 'x'
             2: Nulled Rule, Rule R := A B Y
                 2.1: Nulled Symbol A
                 2.2: Nulled Symbol B
                 2.3: Nulled Symbol Y

=for Marpa::R2::Display::End

In this example, five symbols and a rule are nulled.
The rule and three of the symbols are in a single subtree: 2, 2.1, 2.2 and 2.3.
Marpa prunes every null subtree back to its topmost symbol,
which in this case is the LHS of the rule numbered 2.

The pruned tree looks like this

=for Marpa::R2::Display
ignore: 1

        0: Visible Rule: S := L R
             1: Visible Rule L := A B X
                 1.1: Nulled Node, Symbol A
                 1.2: Nulled Node, Symbol B
                 1.3: Token, Value is 'x'
             2: LHS of Nulled Rule, Symbol R

=for Marpa::R2::Display::End


Here is the output:

=for Marpa::R2::Display
name: Null Value Example Output
normalize-whitespace: 1

    S(L(null A;null B;x);null R)

=for Marpa::R2::Display::End

In the output we see

=over

=item * The null value for symbol 1.1: "C<null A>".

=item * The null value for symbol 1.2: "C<null B>".

=item * The token value for symbol 1.3: "C<x>".

=item * An application of the semantic Perl closure for rule 1.

=item * The null value for rule 2: "C<null R>".

=item * An application of the semantic Perl closure for rule 0.

=back

We do not see any output
for symbols 2.1, 2.2, or 2.3 because they were not topmost
in the pruned subtree.
We B<do> see the null value for the LHS of rule 2,
because it is the topmost symbol.
We B<do not> see an application of the semantic Perl closure for rule 2,
because nulled rules take their value from the null value of their LHS,
and not from the rule semantics.

=head1 ADVANCED

In rare cases,
your application
may call for null values with a complex semantics.

=head2 Implementing a complex but constant null semantics

If an application's semantics of nothing, while complex, remains constant,
you can handle it
by setting every nullable symbol's C<null_value> property
to the value
which your semantics produces when that nullable symbol is the root
symbol of a null subtree.

=head2 Implementing a complex and dynamic null semantics

If the values of an application's
null values are not constants,
Marpa can still calculate them.
Here is the most general method:

=over

=item *

Determine which of the application's nullable symbols have a dynamic semantics.
Call these the B<dynamic nullables>.

=item *
Let the C<null_value> property of every dynamic nullable be a hash key.

=item *
For every rule with a dynamic nullable on its right hand side,
write the rule's semantic Perl closure
so that it looks up that hash key
in a hash whose values are Perl closures.

=item *
The Perl closure can then use an arbitrarily complex semantics for
calculating the value of the dynamic nullable.

=back

=head1 COPYRIGHT AND LICENSE

=for Marpa::R2::Display
ignore: 1

  Copyright 2012 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
