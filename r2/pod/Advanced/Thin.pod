# Copyright 2012 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Advanced::Thin - Direct access to Libmarpa

=head1 About this document

At this moment, this document is INCOMPLETE and,
for that reason
NOT 100% RELIABLE.

Most Marpa users can ignore this document.
It describes Marpa's "thin" interface.
The provides efficient access to Marpa's core
library, Libmarpa.
It provides the ultimate in Marpa speed,
power and flexibility.

The "thin" interface is very low-level and
NOT convenient to use --
user-friendliness is expected to be provided by
an upper layer.
The "thin" interface is intended for those writing
upper layers for Marpa.
It is also for those writing applications,
when they want
to eliminate the overhead of an upper layer,
or when they want the flexibility provided by direct access to Libmarpa.

This document assumes that the reader is familiar with
the other Marpa::R2 documentation,
as well as the Libmarpa API document.
This means the reader will have to know some C language,
enough to understand C function prototypes.

=head1 How this document is written

The Libmarpa interface is described in the Libmarpa
API document,
and this document avoids duplicating the material there.
This document states general rules for the "thin" interface.
Methods that do not
depart from the general rules
are not specifically mentioned.

While this style and level of documentation 
is efficient,
and the standard for C library interfaces to Perl,
it is,
admittedly, very terse.
As an aid to
the reader,
an example of the usage of the thin interface is presented
L<below|"Example">.
While small, the example is non-trival.
It includes a full
logic flow, starting with the definition
of the grammar
and contining all the way to the iteration of
the values of an ambiguous parse.

=head1 Methods in the thin interface

As of this writing, the thin interface has
no methods of its own.
Each of its methods is a wrapper for a method
from the Libmarpa interface.

Not all Libmarpa methods have thin interface wrappers.
None of Libmarpa's internal methods are included in
the thin interface.
Additionally, some of Libmarpa's external methods
provide services that are handled internally by the thin
interface,
and wrappers to those methods
are therefore not included in the actual interface.
When an external Libmarpa method is omitted,
this will be specificially stated,
with the reason for the omission.

Whenever an external Libmarpa method is not mentioned
in this document, the reader can assume that
it has a wrapper that is implemented according
to the general guidelines, as
given below.
Where the implementation of an
external libmarpa methods
is an exception to the guidelines,
or has other peculiarities,
that will be explicitly stated.

=head1 Libmarpa time classes

As a reminder,
the classes of
Libmarpa's time objects are,
in sequence,
grammar, recognizer, bocage,
ordering, tree and value.
The one-letter abbreviations for these
are, respectively,
C<g>, C<r>, C<b>, C<o>, C<t> and C<v>.

The
Internal class instance methods for Libmarpa's time classes
have names of the form C<marpa_g_start_symbol_set>.
The name begin with a fixed six-letter prefix
C<marpa_>,
followed by a single letter,
(in this case "C<g>")
and another underscore.
The single letter is one of Libmarpa's time class
abbreviations, and indicates which
class the method belongs to.
In the thin interface,
The corresponding Perl closure would be named
C<start_symbol_set> and would be a method of the
class C<Marpa::R2::Thin:G>.

Libmarpa's class instance methods
prototypes have an object of the appropriate class
as their first ("self") argument.
Zero or more other non-self arguments follow this first time class argument.
In Perl, the corresponding 
thin Marpa method
would called as a class instance method,
and the arguments of the C function are the same
as the arguments to the Perl method closure.

As an example, here is a call to a Libmarpa function
in the C language:

=for Marpa::R2::Display
ignore: 1

  marpa_g_start_symbol_set (grammar, symbol_S);

=for Marpa::R2::Display::End

and here is the corresonding thin Marpa call:

=for Marpa::R2::Display
name: Thin example
normalize-whitespace: 1
partial: 1

    $grammar->start_symbol_set($symbol_S);

=for Marpa::R2::Display::End

In the above displays,
we have yet to explain the
translation between the C language
arguments and return values and those of Perl.
This will be done in what follows.

=head1 Methods omitted

No internal Libmarpa method is part of the thin interface.
The C<marpa_check_version()> static method is not
part of the thin interface, because the thin interface
interface handles its own version matching.

The thin interface deals with all reference counting
issues, and interconnects Libmarpa's reference counting
with Perl's.  The application can rely on Libmarpa
objects being cleaned up properly as part of Perl's
ordinary garbage collection.
For this reason, there are no thin wrappers for the 
C<mapra_g_ref()>, C<mapra_g_unref()>,
C<mapra_r_ref()>, C<mapra_r_unref()>,
C<mapra_b_ref()>, C<mapra_b_unref()>,
C<mapra_o_ref()>, C<mapra_o_unref()>,
C<mapra_t_ref()>, C<mapra_t_unref()>
C<mapra_v_ref()>, and C<mapra_v_unref()> methods.

There are no thin wrappers for the
C<marpa_g_error()> and
C<marpa_r_error()> methods.
The thin interface provides its own interface
to Libmarpa's error information,
one which is more convenient in the Perl
environment.

=head1 Libmarpa time objects and constructors

The thin interface implements a Perl class
corresponding to
each of the Libmarpa time classes.
Objects in the thin Marpa classes
should be treated as opaque scalars.
No applications should define new elements for a
thin Marpa classes,
redefine, overload or remove existing elements,
or subclass the class itself.
The only operations an application should perform
on objects blessed into the thin interfaces
classes is to assign them,
to use them to call methods in their class,
and to pass them as arguments where appropriate.

=for Marpa::R2::Display
ignore: 1

    Marpa_Grammar       Marpa::R2::Thin::G
    Marpa_Recognizer    Marpa::R2::Thin::R
    Marpa_Bocage        Marpa::R2::Thin::B
    Marpa_Ordering      Marpa::R2::Thin::O
    Marpa_Tree          Marpa::R2::Thin::T
    Marpa_Value         Marpa::R2::Thin::V

=for Marpa::R2::Display::End

Constructors for the time objects may be called using
the C<new> method of the corresponding Perl class.
For example,

=for Marpa::R2::Display
name: Thin example
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Thin::R->new($grammar);

=for Marpa::R2::Display::End

The thin interface takes care of Libmarpa's reference
counting for the user.
Marpa thin interface's time objects should be destroyed
implicitly by undefining them,
or by letting them go out of scope.

=head1 Errors

In general,
when a Libmarpa method returns -1 to indicate failure,
the thin interface return a Perl C<undef>.
In general,
when a Libmarpa method returns -2 to indicate failure,
the thin interface throws a Perl exception.
Exceptions will be indicated in what follows.

The thin interface to Libmarpa provides
error methods
more appropriate to the Perl
environment,
than Libmarpa's own.

=for Marpa::R2::Display
name: Thin grammar error methods

    my @error_names       = Marpa::R2::Thin::error_names();
    my $error_code        = $grammar->error_code();
    my $error_name        = $error_names[$error_code];
    my $error_description = $grammar->error();

=for Marpa::R2::Display::End

The C<error_code()> method returns the most
recent error code,
which is an integer.
The C<error_names()> static method returns
an array of error "names":
these are the error code macros, as listed in
the Libmarpa documentation.
The error code can be used as an index
into the array of error names.
The programmer can expect error
codes and error names to be kept stable.

The C<error()> method returns
the "error description",
a string
that provides a fuller
description
of the latest error than
does the error name.
Error descriptions are subject to change,
Because error descriptions can be kept up
to date, they may more accurately reflect
the nature of the error than the error
name.

=for Marpa::R2::Display
name: Thin recognizer error methods

    $error_code        = $recce->error_code();
    $error_name        = $error_names[$error_code];
    $error_description = $recce->error();

=for Marpa::R2::Display::End

A separate set of error methods is provided
for thin interface recognizer objects.
A recognizer does not have its own
error code,
and the error returned by the recognizer
error methods will be the one
tracked in the base grammar.
The recognizer error methods are
a convenience, to save the application
the trouble of looking up the recognizer's
base grammar.

=head1 Grammar methods

=head2 Constructor

=for Marpa::R2::Display
name: Thin example
partial: 1
normalize-whitespace: 1

    my $grammar  = Marpa::R2::Thin::G->new();

=for Marpa::R2::Display::End

Because version checking is handled by the thin interface internally,
the grammar constructor does NOT accept the version numbers as arguments.
There are no arguments to the grammar constructor.
Its return value is a thin interface grammar object.
An exception is thrown if there is a version mismatch, which should
not happen -- it indicates a problem with the way that the library
was built.

=head1 Example

=for Marpa::R2::Display
name: Thin example
normalize-whitespace: 1

    my $grammar  = Marpa::R2::Thin::G->new();
    my $symbol_S = $grammar->symbol_new();
    my $symbol_E = $grammar->symbol_new();
    $grammar->start_symbol_set($symbol_S);
    my $symbol_op     = $grammar->symbol_new();
    my $symbol_number = $grammar->symbol_new();
    my $start_rule_id = $grammar->rule_new( $symbol_S, [$symbol_E] );
    my $op_rule_id =
        $grammar->rule_new( $symbol_E, [ $symbol_E, $symbol_op, $symbol_E ] );
    my $number_rule_id = $grammar->rule_new( $symbol_E, [$symbol_number] );
    $grammar->precompute();

    my $recce = Marpa::R2::Thin::R->new($grammar);
    $recce->start_input();

    # The numbers from 1 to 3 are themselves --
    # that is, they index their own token value.
    # Important: zero cannot be itself!

    my @token_values         = ( 0 .. 3 );
    my $zero                 = -1 + +push @token_values, 0;
    my $minus_token_value    = -1 + push @token_values, q{-};
    my $plus_token_value     = -1 + push @token_values, q{+};
    my $multiply_token_value = -1 + push @token_values, q{*};

    $recce->alternative( $symbol_number, 2, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_op, $minus_token_value, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_number, $zero, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_op, $multiply_token_value, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_number, 3, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_op, $plus_token_value, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_number, 1, 1 );
    $recce->earleme_complete();

    my $latest_earley_set_ID = $recce->latest_earley_set();
    my $bocage        = Marpa::R2::Thin::B->new( $recce, $latest_earley_set_ID );
    my $order         = Marpa::R2::Thin::O->new($bocage);
    my $tree          = Marpa::R2::Thin::T->new($order);
    my @actual_values = ();
    while ( $tree->next() ) {
        my $valuator = Marpa::R2::Thin::V->new($tree);
        $valuator->rule_is_valued_set( $op_rule_id,     1 );
        $valuator->rule_is_valued_set( $start_rule_id,  1 );
        $valuator->rule_is_valued_set( $number_rule_id, 1 );
        my @stack = ();
        STEP: while ( my ( $type, @step_data ) = $valuator->step() ) {
            last STEP if not defined $type;
            if ( $type eq 'MARPA_STEP_TOKEN' ) {
                my ( undef, $token_value_ix, $arg_n ) = @step_data;
                $stack[$arg_n] = $token_values[$token_value_ix];
                next STEP;
            }
            if ( $type eq 'MARPA_STEP_RULE' ) {
                my ( $rule_id, $arg_0, $arg_n ) = @step_data;
                if ( $rule_id == $start_rule_id ) {
                    my ( $string, $value ) = @{ $stack[$arg_n] };
                    $stack[$arg_0] = "$string == $value";
                    next STEP;
                }
                if ( $rule_id == $number_rule_id ) {
                    my $number = $stack[$arg_0];
                    $stack[$arg_0] = [ $number, $number ];
                    next STEP;
                }
                if ( $rule_id == $op_rule_id ) {
                    my $op = $stack[ $arg_0 + 1 ];
                    my ( $right_string, $right_value ) = @{ $stack[$arg_n] };
                    my ( $left_string,  $left_value )  = @{ $stack[$arg_0] };
                    my $value;
                    my $text = '(' . $left_string . $op . $right_string . ')';
                    if ( $op eq q{+} ) {
                        $stack[$arg_0] = [ $text, $left_value + $right_value ];
                        next STEP;
                    }
                    if ( $op eq q{-} ) {
                        $stack[$arg_0] = [ $text, $left_value - $right_value ];
                        next STEP;
                    }
                    if ( $op eq q{*} ) {
                        $stack[$arg_0] = [ $text, $left_value * $right_value ];
                        next STEP;
                    }
                    die "Unknown op: $op";
                } ## end if ( $rule_id == $op_rule_id )
                die "Unknown rule $rule_id";
            } ## end if ( $type eq 'MARPA_STEP_RULE' )
            die "Unexpected step type: $type";
        } ## end while ( my ( $type, @step_data ) = $valuator->step() )
        push @actual_values, $stack[0];
    } ## end while ( $tree->next() )

=for Marpa::R2::Display::End

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2012 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
