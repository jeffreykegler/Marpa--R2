\input texinfo @c -*-texinfo-*- 
@c %**start of header
@setfilename api.info 
@settitle libmarpa @value{VERSION}
@c %**end of header 
@include version.texi
@copying 
This manual is for libmarpa @value{VERSION}. 
Copyright @copyright{} 2012 Jeffrey Kegler.
@quotation 
Permission is granted to copy, distribute and/or modify this document 
under the terms of the GNU Free Documentation License, Version 1.2 or 
any later version published by the Free Software Foundation;
@end quotation 
@end copying 
@finalout
@titlepage 
@title libmarpa
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Jeffrey Kegler
@c The following two commands 
@c start the copyright page. 
@page 
@vskip 0pt plus 1filll 
@insertcopying

Published @value{UPDATED} by Jeffrey Kegler
@end titlepage 
@c So the toc is printed at the start. 
@contents 
@ifnottex 
@node Top, How to read this document, (dir), (dir)
@top libmarpa: The Marpa low-level library

This manual is for libmarpa, version @value{VERSION}. 

@end ifnottex 
@menu
* How to read this document::   
* About libmarpa::              What is libmarpa?
* Time objects::                
* The architecture of Marpa::   
* Threads::                     
* Numbered objects::            
* Semantics::                   
* Version checking::            Checking the libmarpa version.
* Grammars::                    Grammar time objects
* Events::                      libmarpa Events
* Recognizers::                 Recognizers.
* Bocage::                      Bocage objects.
* Order::                       Order objects.
* Tree::                        Parse Trees.
* Value::                       Value objects.
* Error handling::              

@detailmenu
 --- The Detailed Node Listing ---

How to read this document

* What is this document::       What is this document?
* Prerequisites::               Prerequisites.
* Which chapters to read first::  Which chapters to read first.
* Parsing theory::              Parsing theory.

Time objects

* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  

The architecture of Marpa

* Architecture - Grammar::      
* Recognition versus parsing::  
* Why so many time objects::    

Grammars

* Precomputation::              

Numbered objects

* Numbered object implementation::  

Semantics

* Token values::                

Grammars

* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals::                   Terminal symbols.
* Rules::                       
* Grammar precomputation::      Precomputing the Grammar.
* Symbol internals::            Methods that deal with symbol internals.
* Rule internals::              
* Grammar internals::           Methods that deal with grammar internals.

Events

* Event accessor::              Event accessor.
* Event codes::                 Event codes.

Recognizer objects

* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life::             Taking a recognizer through its life cycle.
* Recognizer internals::        Meddling with the recognizer internals.

Bocage objects

* Bocage reference counting::   
* Bocage internals::            Bocage internals.

Orderings

* Ordering constructor::        
* Ordering reference counting::  
* Ordering internals::          

Tree iterators

* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              
* Tree internals::              Internals.

Value objects

* Valuator constructor::        
* Valuator access macros::      
* Valuator reference counting::  
* Valuator stepping::           
* Valuator tracing::            

@end detailmenu
@end menu

@node How to read this document, About libmarpa, Top, Top
@chapter How to read this document

@menu
* What is this document::       What is this document?
* Prerequisites::               Prerequisites.
* Which chapters to read first::  Which chapters to read first.
* Parsing theory::              Parsing theory.
@end menu 

@node What is this document, Prerequisites, How to read this document, How to read this document
@section What is this document?

This document is intended as a reference manual
for a complex low-level tool.
The reader might compare it to the GNU C Language
manual, which makes no attempt to teach much of
the technical knowledge required to appreciate its
contents or, for that matter,
even the C language itself.

@node Prerequisites, Which chapters to read first, What is this document, How to read this document
@section Prerequisites

This document is very far from self-contained.
It assumes the following:
@itemize
@item
The reader knows the C programming language.
@item
The reader
has read the documents for one of libmarpa's upper layers.
@item
The reader
is at least slightly familiar with Glib,
and has the @cite{Glib Reference  Manual} available.
In particular, the reader should know the type system
described in its "Basic Types" section.
@item
The reader knows some parsing theory.
@xref{Parsing theory}.
@end itemize

@node Which chapters to read first, Parsing theory, Prerequisites, How to read this document
@section Which chapters to read first

Early chapters of this document lay out concepts,
while later chapters describe libmarpa's object in
detail,
or deal with optional topics.
This document expects the reader will read its
"concept" chapters first, and in the order of
presentation.
With those as background, the reader should
then be able to read the rest of the material
in the order,
and to the extent,
of his interest.

@node Parsing theory,  , Which chapters to read first, How to read this document
@section Parsing theory

This document also assumes an acquaintance
with parsing theory.
As a test of whether he needs to refresh
his knowledge before tackling
this document,
I hope the reader will find it helpful to
ask himself the
following list of questions.
@itemize @bullet
@item
What is a BNF rule?
@item
What is a Marpa sequence rule?
@item
As a reminder,
Marpa's sequence rules are implemented
as left recursions.
What does that mean?
@item
If you were given a Marpa sequence rule,
could you rewrite it in BNF?
@item
Would you know whether your rewrite was
left- or right-recursive?
@item
Could you change it from one to the other?
@end itemize
For a reader to be satisfied with the level of detail
in the following pages,
he probably should be able to answer all the questions
in the above list either off the top of his head,
or after a moment of thought.

On the encouraging side,
while BNF has been overshadowed
by regular expressions, and is now considered
an advanced skill,
BNF is in fact as easy (or easier) to learn
and manipulation than regular expressions.
If a reader who has learned how to use
one of the packages that extend
regular expressions,
he should have no trouble with BNF.

@node About libmarpa, Time objects, How to read this document, Top
@chapter About libmarpa
This is the reference manual for libmarpa.
Libmarpa implements the Marpa parsing algorithm.
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

Libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees.
It also supports the ordering and evaluation of the parse
trees.

However, it is very low-level.
libmarpa, for example, has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for most applications.
A user will almost always want,
at a minimum,
names for the symbols and non-integer values for
tokens.
Typically, an application will use arrays to
translate libmarpa's integer IDs to strings or other
values as required.

libmarpa also does NOT implement most of the semantics.
libmarpa does have an evaluator, but it does NOT
manipulate the stack directly.
Instead, libmarpa,
based on its traversal of the parse tree,
passes step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved
involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.

While libmarpa passes instruction for stack manipulation,
it does not actually maintain a stack.
This leaves the upper layer in total control of the
stack and the values which are placed on it.

As example may make this clearer.
Suppose the evalution is at a place in the parse tree
where an addition is being performed.
libmarpa does not know that the operation
is an addition.
It will tell the application that rule number R
is to be applied to the arguments at stack locations
N and N+, and that the result is to placed in
stack location N.

In this system,
The application keeps track of the semantics for all
rules, so it looks up rule R and determines that it
is an addition.
The application can do this by using R as an index
into an array of callbacks, or by any other method
it chooses.
Let's assume a callback implements the semantics
for rule R.
libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations N and N+1 in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let's say, 753.
libmarpa has told the application that the result
belongs at location N in the stack,
so the application writes 752 to location N.

Since libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers; or objects which may be any
or all of these and more.

This technique
hides libmarpa's grammar rewrites from the application,
and is actually quite efficient.
libmarpa knows which rules are sequences
and optimizes stack manipulations based on this knowledge.
Many practical grammars use long sequences heavily,
and for these libmarpa the series of steps
suggest by libmarpa will be significantly faster than the standard 
stack evaluation algorithm in the textbooks.

To make it clear,
I am under no illusion that libmarpa's evaluator will be found
satisfactory even to most application programmers.
I certainly avoid using it directly.
It is intended to be used via an upper layer,
one which does know about semantics.

But, by isolating libmarpa from semantics, libmarpa avoids
imposing any arbitrary restrictions on the semantics used
with the Marpa algorithm.
To see the advantage suppose, as I expect will often be the case,
libmarpa is used as the basis
for a higher-level language which needs callbacks in that higher level language.
For generality, libmarpa would have to deal in C callback,
which wrapper the callbacks in the higher level language.
This is complex to code and inefficient,
but that is not its worst aspect.
The worst aspect happens when there is a programming error.
This error will occur inside libmarpa,
and inside code about which libmarpa can make no assumptions.

If all semantics are implemented in the application,
the application is in a much better position to prevent errors,
to catch them at runtime or
failing all else,
to successfully debug the logic.

@node Time objects, The architecture of Marpa, About libmarpa, Top
@chapter Time objects

Libmarpa's most important objects are time objects.
Grammars and recognizers are examples of time objects.
Time objects are so called for two related reasons.
First, they relate to a "time" in the progress of a parse.
Second, each time object has a lifetime and is reference counted.

Libmarpa's major objects are called "time" objects instead
of phase objects,
because phases are exclusive and non-simultaneous
-- when one phase ends, another begins.
Time objects are often in use simultaneously.
For example, infancy, adolescent and adulthood are phases in
our lives.
Work and play are different times.

The time objects are, in sequence:
@itemize 
@item Grammars.
@item Recognizers.
@item Bocages.
@item Orderings.
@item Trees.
@item Valuators.
@end itemize 

@menu
* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  
@end menu

@node The sequence of time objects, Base grammars, Time objects, Time objects
@section The sequence of time objects

Above I said "in sequence".
While time objects do not correspond to phases,
they do have a well-defined sequence.
Except for grammars,
all time objects are created from another time
object.
A recognizer cannot be created without a precomputed grammar;
a bocage cannot be created without a recognizer;
and so on.

@node Base grammars, The lifetime of time objects, The sequence of time objects, Time objects
@section Every time object has a base grammar

When one time object is used to create a second
time object,
the first time object is the @dfn{parent object}
and the second time object is the @dfn{child object}.
For example, when a bocage is created from a
recognizer,
the recognizer is the parent object,
and the bocage is the child object.

Grammars have no parent object.
Every other time object has exactly one parent object.
Valuation objects have no child objects.
All other time objects can have any number of children,
from zero up to a number determined by the memory limits
or the architecture.

Every time object has a @dfn{base grammar}.
A grammar object is its own base grammar.
The base grammar of a recognizer is the grammar
that it was created with.
The base grammar of any other time object is the base
grammar of its parent object.
For example,
the base grammar of a bocage is the base
grammar of the recognizer that it was created
with.

@node The lifetime of time objects,  , Base grammars, Time objects
@section The lifetime of time objects

Time objects are reference-counted.
Every time object is created with a reference count of 1.
Whenever one time object is created from another,
the parent time object has its reference count incremented
by 1.

Every time object has a method which decrements its
reference count by 1.
Time objects do not have explicit destructors.
When the reference count of a time object reaches
0, that time object is destroyed.

In ordinary circumstances, all an application has to
do is keep in mind that it "owns" the time objects
it has created, and that it must call to method
to "unreference" that object when it is finished.

In some applications, multiple parts of it
may need to share ownership of an object.
For such situations,
every time object has a method to increment
the reference count.

@node The architecture of Marpa, Threads, Time objects, Top
@chapter The architecture of Marpa

@menu
* Architecture - Grammar::      
* Recognition versus parsing::  
* Why so many time objects::    
@end menu

@node Architecture - Grammar, Recognition versus parsing, The architecture of Marpa, The architecture of Marpa
@section Grammars

As per parsing theory,
before an input can be parsed,
a grammar must be defined.
Traditionally,
A grammar consists of a set of terminal symbols,
a set of non-terminal symbols,
a set of rules,
and a distinguished start symbol.

A terminal symbol is symbol which
may appear in the input.
The rules have a single symbol
on their left hand side (LHS),
and a right hand side which consists of zero or more
symbols.
RHS symbols can be either terminals or non-terminals.
Traditionally,
all LHS symbols, as well as
the start symbol, must be non-terminals.

Marpa's grammars differ from the traditional ones
in that there is no necessary distinction between
terminals and non-terminals.
In Marpa,
a terminal may be the start symbols,
and may appear on the LHS of a rule.
By default, all symbols are terminals.

Marpa's idea
in losing the sharp division between terminals
and non-terminals is that the distinction,
while helpful for proving theorems,
is not essential in practice.
If LHS symbols 
appear in the input they, in effect,
"short circuiting" the rules in which they occur.
This may
be helpful in debugging, or have other applications.

However,
it also can be useful, 
for checking input validity as well as for efficiency,
to follow tradition and distingush
non-terminals from terminals.
Marpa allows the user to mark each symbol
as a terminal or a non-terminal.
Symbols marked as non-terminals will not be allowed as input.
The user also has the option of banning terminals from
the LHS of rules.
Marpa allows a
user who prefers the tradition distinction
to restore it, partially or completely.

@menu
* Precomputation::              
@end menu

@node Precomputation,  , Architecture - Grammar, Architecture - Grammar
@subsection Precomputation

Before a recognizer can be created from a grammar,
it must be precomputed.
Internally, precomputation is what the term
suggests --
the precomputation of a large number
of facts about the grammar that allow
the recognizer to proceed very efficiently.

Whether or not to precompute is another case
of the common choice between lazy and eager evaluation.
It is Marpa's strategy to make very aggressive use of
precomputation at grammar time.

Precomputation "freezes" a grammar.
New symbols, rules and sequences cannot be added
to a precomputed grammar
are disallowed,
as are most other changes.

@node Recognition versus parsing, Why so many time objects, Architecture - Grammar, The architecture of Marpa
@section Recognition versus parsing

Even in the academic literature,
parsing is used in many senses,
Some algorithms,
distinguish between between determining whether
a given string matches the grammar,
and finding the structure of the recognized string
according to the grammar.
Earley's algorithm was one such algorithm.
Marpa is another.

Determining whether a string matches a grammar is called
@dfn{recognition}.
Finding the structure of the recognized string according
to the grammar is
@dfn{parsing} in a very strict sense of the term.
Strictly speaking,
Earley's algorithm was a recognizer,
and not a parser.
Marpa contains both a recognizer
and a parser in the strict sense.
Marpa's recognizer is implemented by its recognizer time objects.
Marpa's parser in the strict sense
is implemented by its bocage class and the classes
which follow the bocage in the time object sequence.

@node Why so many time objects,  , Recognition versus parsing, The architecture of Marpa
@section Why so many time objects?

Readers accustomed to other appraoches to parsing,
particular those in fashion at this writing,
may wonder on the number of time objects
in the Marpa architecture.
Several of Marpa's time objects (bocages,
orderings and trees) are required
because Marpa allows,
and offers powerful tools for dealing with,
ambigious grammars.

It may seem, then, that users of unambiguous grammars,
are paying a considerable price in time effiency
for the ability to parse
ambiguous ones.
This is not the case.
In the trivial case, the cost of the orderings
object is a single, very brief, subroutine call.

Bocage objects come at minimal cost,
because the same pass which creates the bocage
also deals with other issues which are of major
significance even for unambiguous parses.
The same pass which creates the bocage
enables Marpa to do both left-
and right-recursion in linear time.

Tree objects come at mininal cost to unambiguous grammars,
because the same pass that allows iteration through multiple
parse trees does the tree traversal, so that the valuation time object
has very litle to do -- it just steps through the sequence.

But what about the many passes over the data this requires?
Marpa is an aggressively multi-pass algorithm.
Marpa achieves its efficiency,
not in spite of making multiple
passes over the data, but because of it.
Marpa is @math{O(n)} for LR-regular grammars,
both in theory and in implementation,
because Marpa regularly substitutes
two fast @math{O(n)} passes for a single
@math{O(n log n)} pass.

@node Threads, Numbered objects, The architecture of Marpa, Top
@chapter Threads

Libmarpa is thread-safe, with a restriction.
No attempt is make to lock a parent object
which it is used by child time object.
In particular,
every time object with the same base grammar shares data
from that grammar.
This means that, for every base grammar,
its time objects can be used safely in at most one thread.

Libmarpa uses no global data.
As long as libmarpa time objects which have
the same base grammar are not
used in two different threads,
libmarpa is thread-safe.

Libmarpa makes heavy use of GNU's glib,
but Glib is thread-safe internally,
and libmarpa's use of Glib structures is thread-safe
if the above mentioned restriction is obeyed.
Except for Glib,
libmarpa makes little use of outside libraries,
and always in a thread-safe fashion.

@node Numbered objects, Semantics, Threads, Top
@chapter Numbered objects

In addition to its major, "time" objects, libmarpa also has
numbered objects
Examples of numbered objects are rules and symbols.
Numbered objects do not have lifetimes of their own.
Every numbered object belongs to a timed object,
and is destroyed with it.

@menu
* Numbered object implementation::  
@end menu

@node Numbered object implementation,  , Numbered objects, Numbered objects
@section Implementation

Numbered objects are implemented as integers, and not as
pointers.
Pointers cannot easily be checked for validity.
Integers on the other hand, especially if they are assigned
in sequence, are easy to check safely and portably.
It is easy to safely check an integer for validity.

There are efficiency tradeoffs between pointers and
integers but these go both ways.
Pointers can be faster, but integers can be used
as indexes into more than one data structure.
Which is actually faster depends on the design,
and since integers allow for a more flexible design,
careful programming can make them a win,
possibly a very big one.

The author decided to settle on integers from the
outset, and to design libmnarpa taking full
advantage of that choice.
In many or most cases, that would make integers
more efficient.
In the cases where pointers were faster, it would
not be by much --
a small price to pay for
safe, portable validity checking.

@node Semantics, Version checking, Numbered objects, Top
@chapter Semantics

@menu
* Token values::                
@end menu

@node Token values,  , Semantics, Semantics
@section Token values

Token values are @code{gpointer}'s.
(In Glib, @code{gpointer}'s is @code{typedef}'d to @code{void *}.)
libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.

In fact,
the author recommends that token values always
be integers.
While token values are simply passed into libmarpa and back out,
but the user may need to check their validity.
This could be the case, for example, during development.
When the values are integers, validity checking is easy
to do safely.
When they are pointers,
validity checking without risking an abend is hard
or impossible.
Integers can be used to access any kind of data
using an array,
so that the higher levels can translate integers back
and forth into whatever the application requires.

Integers of types @code{gint}, @code{guint}, @code{gsize}
can be portably converted into @code{gpointer}'s using
Glib macros.
These are described in the "Type Conversion Macros" section
of the Glib Reference Manual ( @code{GINT_TO_POINTER}, etc.)

Since the author strongly recommends using integers,
why are token values always @code{gpointer}'s?
Pointers can portably be converted into integers
and back,
while the reverse is not true.
In some circumstances an
application programmer may find minor
efficiencies from the direct use of pointers,
and may believe these outweigh the safety
issues advanced by this author.
It is in the UNIX and Perl traditions to
avoid imposing choices on the user.

@node Version checking, Grammars, Semantics, Top
@chapter Checking the libmarpa version
@cindex version checking

@deftypefun const char* marpa_check_version @
    (unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro} @
    )

Checks that the Marpa library in use is compatible with the
given version. Generally you would pass in the constants
@code{MARPA_MAJOR_VERSION},
@code{MARPA_MINOR_VERSION},
@code{MARPA_MICRO_VERSION}
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of libmarpa the application or module was compiled
against.

Once we are beyond alpha releases,
compatibility will be defined by three things:
first the version
of the running library is newer than the version
@var{required_major}.@var{required_minor}.@var{required_micro}.
Second
the running library must be binary compatible with the
version
@var{required_major}.@var{required_minor}.@var{required_micro}
(same major version.)

Currently libmarpa is undergoing rapid development,
and backward compatibility is not maintained.
This will be the case as long as libmarpa stays
alpha.

While libmarpa is still alpha, much stricter compatibility
will be enforced.
While libmarpa is alpha 
the major, minor and micro numbers must match exactly.
Technically, the post-alpha rules can be said to apply
because the very strict alpha rules imply them.

Return value: %NULL if the Marpa library is compatible with the
  given version, or a string describing the version mismatch.
  The returned string is owned by Marpa and must not be modified
  or freed.

@end deftypefun

@node Grammars, Events, Version checking, Top
@chapter Grammars
@cindex grammars

@menu
* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals::                   Terminal symbols.
* Rules::                       
* Grammar precomputation::      Precomputing the Grammar.
* Symbol internals::            Methods that deal with symbol internals.
* Rule internals::              
* Grammar internals::           Methods that deal with grammar internals.
@end menu 

@node Grammar constructor, Grammar reference counting, Grammars, Grammars
@section Creating a new grammar
@cindex grammar constructor

@deftypefun Marpa_Grammar marpa_g_new ( @
    guint @var{required_major}, @
    guint @var{required_minor}, @
    guint @var{required_micro})

Creates a new grammar time object.
The returned grammar object not be precomputed,
and will have no symbols and rules.
Its reference count will be 1.

After a marpa_g_new call, the next step is
usually the addition of rules and symbols
in preparation for grammar precomputation.

The expected major, minor and micro version
numbers must be passed as arguments,
While libmarpa is alpha,
any mismatch with the actual version will
cause a failure.

Return value: On success, the grammar object.
On failure, @code{NULL}.

@end deftypefun

@node Grammar reference counting, Symbols, Grammar constructor, Grammars
@section Tracking the reference count of the grammar
@cindex grammar destructor
@cindex grammar reference
@cindex grammar reference count

Grammar time objects are created by
@code{marpa_g_new} with a reference count of 1.
@code{marpa_r_new} and @code{marpa_g_ref} increment the
reference count by 1.
@code{marpa_g_unref} decrements the reference count by 1.

@deftypefun void marpa_g_unref (Marpa_Grammar @var{g})
@end deftypefun

Decreases the reference count by 1,
destroying @var{g} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

Return value: None

@deftypefun Marpa_Grammar marpa_g_ref (Marpa_Grammar @var{g})
@end deftypefun

Increases the reference count.

Return value:
On success, the grammar object it was called with;
@code{NULL} on failure.

@node Symbols, Terminals, Grammar reference counting, Grammars
@section Symbols

@deftypefun Marpa_Symbol_ID marpa_g_symbol_new (Marpa_Grammar @var{g})

Creates a new symbol.
Symbols are initialized to non-terminals.

Return value: On success, the ID of the new symbol; 
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{id})

Sets the start symbol of grammar @var{g} to symbol @code{id}.
To be precomputed, a grammar must have a start symbol.

Return value: On success, the ID of the new start symbol.
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol (Marpa_Grammar @var{g})

Returns current value of the start symbol of grammar @var{g}.
The value is that of the user's start
symbol, as specified in the @var{marpa_g_start_symbol_set} call,
if there has been one.
Marpa "augments" its grammars,
creating one or two new, internal start symbols.

Return value:
On failure, -2;
-1 if there is no start symbol yet;
otherwise the ID of the new start symbol.

@end deftypefun

@deftypefun gint marpa_g_symbol_count (Marpa_Grammar @var{g})
@end deftypefun

@node Terminals, Rules, Symbols, Grammars
@section Methods that deal with terminal symbols

@deftypefun gint marpa_g_is_lhs_terminal_ok (Marpa_Grammar @var{g})
@deftypefunx gint marpa_g_is_lhs_terminal_ok_set ( @
    Marpa_Grammar @var{g}, @
    gint @var{value})
@end deftypefun

@deftypefun gint marpa_g_symbol_is_terminal ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@deftypefunx gint marpa_g_symbol_is_terminal_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 gint @var{value})
@end deftypefun

@deftypefun gint marpa_g_symbol_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_counted (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_nullable (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun

@node Rules, Grammar precomputation, Terminals, Grammars
@section Rules

@deftypefun gint marpa_g_rule_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_rule_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs}, @
 Marpa_Symbol_ID *@var{rhs}, @
     gint @var{length})
@end deftypefun

@deftypefun gint marpa_g_sequence_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs_id}, @
 Marpa_Symbol_ID @var{rhs_id}, @
     Marpa_Symbol_ID @var{separator_id}, @
    gint @var{min}, @
 gint @var{flags} )
@end deftypefun

@deftypefun gint marpa_g_rule_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
@end deftypefun

@deftypefun gint marpa_g_rule_is_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun

@deftypefun gint marpa_g_rule_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun

@deftypefun gint marpa_g_rule_is_discard_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id}, @
    gint @var{ix})
@end deftypefun

@deftypefun gint marpa_g_rule_whatever_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx gint marpa_g_rule_first_child_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx gint marpa_g_rule_ask_me_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx gint marpa_g_rule_is_ask_me ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})

Usually,
most of the semantics must be implemented by Marpa's
higher layers.
This is called @dfn{"ask me" semantics}.
In two special but common cases, however,
Marpa can implement the semantics internally,
eliminating an evaluation step.
This can be an considerable efficiency.

The two optimizable cases are "whatever semantics
and "first child" semantics.
If a rule has
@dfn{whatever semantics}, that means
that the higher layers
do not care about the value of the rule.
If a rule has
@dfn{first child semantics}, the value of the rule
should be the value of its first child node.
In the current implementation, both of these
can be implemented as stack no-ops.

In the current implementation,
first child semantics is equivalent to whatever semantics.
It is possible that a future implementation will
be unable to implement first child semantics as a stack
no-op.
At that point first child semantics will made equivalent
to "ask me" semantics.

Return value: -2 if there was an error.
  On success, 1 if the resulting semantics after
  the function call is the "ask me" semantics.
  Otherise, 0 otherwise.

@end deftypefun

@node Grammar precomputation, Symbol internals, Rules, Grammars
@section Precomputing the Grammar

@deftypefun gint marpa_g_precompute (Marpa_Grammar @var{g})
@end deftypefun

@deftypefun gint marpa_g_is_precomputed (Marpa_Grammar @var{g})
@end deftypefun

@deftypefun gint marpa_g_has_loop (Marpa_Grammar @var{g})
@end deftypefun

@node Symbol internals, Rule internals, Grammar precomputation, Grammars
@section Methods that deal with symbol internals

@deftypefun gint marpa_g_symbol_is_start ( Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})

This return value of this call indicates whether @var{symid}
is the ID of one of Marpa's internal start symbols.
Marpa rewrites its grammars to add
a new start rule
and one or two new, internal, start symbols.
The first start symbol is always non-nullable.
It is the LHS of the new start rule,
and that is its only occurrence in any rule.

The second start symbol is 
a nulling start symbol.
It is only present
if the grammar allows the null parse.
For Marpa, null parses are handled as
a very special case.
The nulling start symbol is used,
but no nulling rule is created,
so that the nulling start symbol is
never on the LHS or RHS of any rule.

Rewriting a grammar to add a new start
is a very standard procedure,
so much so that it has a special
name:
@dfn{augmenting the grammar}.
The rewritten grammar is called
an @dfn{augmented grammar}.

Return value: -2 if the grammar is not precomputed or
    @var{symid} is not valid;
    1 if @var{symid} is a start symbol in the rewritten grammar;
    0 otherwise.

@end deftypefun

@deftypefun gint marpa_g_symbol_ask_me_when_null_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id}, @
    int value)
@deftypefunx gint marpa_g_symbol_is_ask_me_when_null ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id})

In Marpa,
most of the semantics is usually be implemented by the
higher layers.
This is called @dfn{"ask me" semantics}.
The "ask me when null"
calls deal with the handling of semantics
in case when the symbol is nulling.
For proper nullables,
the "Ask me when null" setting is relevant
only in cases where the symbol is nulled.

Marpa's default is to assume that the
value of nulled symbols will be ignored,
and to let that value be arbitrary.
"Arbitrary" here means it may not be relied
and may change from instance to instance.
Marpa optimizes for cases where symbols
have arbitrary values.

Return value: -2 if there was an error.
  On success, 1 if the resulting semantics after
  the function call is the "ask me" semantics.
  Otherise, 0 otherwise.

@end deftypefun

@deftypefun gint marpa_g_symbol_lhs_count (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_symbol_lhs (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 gint @var{ix})
@end deftypefun
@deftypefun gint marpa_g_symbol_rhs_count (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_symbol_rhs (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 gint @var{ix})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_symbol_proper_alias (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_symbol_null_alias (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_symbol_virtual_lhs_rule (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun

@node Rule internals, Grammar internals, Symbol internals, Grammars
@section Rule internals

@deftypefun gint marpa_g_rule_is_virtual_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_used (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_virtual_lhs (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_virtual_rhs (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun guint marpa_g_virtual_start (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun guint marpa_g_virtual_end (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_rule_original (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_real_symbol_count (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_rule_semantic_equivalent (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun

@node Grammar internals,  , Rule internals, Grammars
@section Methods that deal with grammar internals

The methods in this section are accessors for libmarpa's
AHFA items and states.
Their use requires familiarity with
Marpa's internals, as described in
@cite{Marpa: The Program}.
These methods will not be of interest to most users.

@deftypefun gint marpa_g_AHFA_item_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_AHFA_item_rule (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_item_position (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_AHFA_item_postdot (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_item_sort_key (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_item_count (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_AHFA_Item_ID marpa_g_AHFA_state_item (Marpa_Grammar @var{g}, @
     Marpa_AHFA_State_ID @var{AHFA_state_id}, @
 gint @var{item_ix})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_is_predict (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_AHFA_state_leo_lhs_symbol (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_transitions (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id}, @
    GArray *@var{result})
@end deftypefun
@deftypefun Marpa_AHFA_State_ID marpa_g_AHFA_state_empty_transition (Marpa_Grammar @var{g}, @
     Marpa_AHFA_Item_ID @var{AHFA_item_id})
@end deftypefun

@node Events, Recognizers, Grammars, Top
@chapter Events

@menu
* Event accessor::              Event accessor.
* Event codes::                 Event codes.
@end menu

@node Event accessor, Event codes, Events, Events
@section Accessing events

@deftypefun gint marpa_g_event (Marpa_Grammar @var{g}, @
    Marpa_Event @var{public_event}, @
	       gint @var{ix})
@end deftypefun

@node Event codes,  , Event accessor, Events
@section Event codes

@deftypevr Macro int MARPA_EVENT_NONE
Suggested message: "No error."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EXHAUSTED
Suggested message: "Recognizer is exhausted."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EARLEY_ITEM_THRESHOLD
Suggested message: "Too many Earley items."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_LOOP_RULES
Suggested message: "A rule is part of a infinite loop."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NEW_SYMBOL
Suggested message: "New symbol."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NEW_RULE
Suggested message: "New rule."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_COUNTED_NULLABLE
Suggested message: "Grammar has a counted nullable."
@end deftypevr

@node Recognizers, Bocage, Events, Top
@chapter Recognizer objects

@menu
* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life::             Taking a recognizer through its life cycle.
* Recognizer internals::        Meddling with the recognizer internals.
@end menu 

@node Recognizer constructor, Recognizer reference counting, Recognizers, Recognizers
@section Creating a new recognizer

@deftypefun Marpa_Recognizer marpa_r_new ( Marpa_Grammar @var{g} )
@end deftypefun

@node Recognizer reference counting, Recognizer life, Recognizer constructor, Recognizers
@section Keeping the reference count of a recognizer

@deftypefun Marpa_Recognizer marpa_r_ref (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun void marpa_r_unref (Marpa_Recognizer @var{r})
@end deftypefun

@node Recognizer life, Recognizer internals, Recognizer reference counting, Recognizers
@section Taking a recognizer through its life cycle

@deftypefun gint marpa_r_start_input (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_alternative (Marpa_Recognizer r, Marpa_Symbol_ID @var{token_id}, gpointer @var{value}, gint @var{length})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme_complete (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Error_Code marpa_r_error @
    (Marpa_Recognizer @var{r}, @
    const char** @var{p_error_string})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{set_id})

Given the ID (ordinal) of an Earley set,
return the earleme.
In the default, token-stream model, ID and earleme
are the same, but this is not the case in other input
models.
If the ordinal is out of bounds, this function
returns -1, which can be treated as a soft failure.
On other problems, it returns -2.
@end deftypefun

@deftypefun guint marpa_r_current_earleme (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_earley_item_warning_threshold (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_earley_item_warning_threshold_set (Marpa_Recognizer @var{r}, @
    gint @var{threshold})
@end deftypefun

@deftypefun guint marpa_r_furthest_earleme (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_terminals_expected (Marpa_Recognizer @var{r}, GArray* @var{result})
@end deftypefun

@deftypefun gint marpa_r_is_use_leo (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_is_use_leo_set ( Marpa_Recognizer @var{r}, @
    gint @var{value})
@end deftypefun

@deftypefun gint marpa_r_is_exhausted (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_event (Marpa_Recognizer @var{r}, @
    Marpa_Event @var{public_event}, @
    gint @var{ix})
@end deftypefun

@node Recognizer internals,  , Recognizer life, Recognizers
@section Meddling with the recognizer internals

@deftypefun Marpa_Earley_Set_ID marpa_r_trace_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_latest_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_earley_set_size (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earley_set_trace (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_earley_item_trace (Marpa_Recognizer r, Marpa_Earley_Item_ID @var{item_id})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_earley_item_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_leo_predecessor_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_leo_base_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_base_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_expansion_ahfa (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_postdot_symbol_trace (Marpa_Recognizer r, Marpa_Symbol_ID @var{symid})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_postdot_item_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_source_predecessor_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_token (Marpa_Recognizer r, gpointer *@var{value_p})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_leo_transition_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_source_middle (Marpa_Recognizer @var{r})
@end deftypefun

@node Bocage, Order, Recognizers, Top
@chapter Bocage objects

@menu
* Bocage reference counting::   
* Bocage internals::            Bocage internals.
@end menu

@deftypefun Marpa_Bocage marpa_b_new (Marpa_Recognizer @var{r}, @
    Marpa_Rule_ID @var{rule_id}, @
    Marpa_Earley_Set_ID @var{ordinal_arg})
@end deftypefun

@deftypefun Marpa_Grammar marpa_b_g (Marpa_Bocage @var{b})
@end deftypefun

@node Bocage reference counting, Bocage internals, Bocage, Bocage
@section  Reference counting
@deftypefun Marpa_Bocage marpa_b_ref (Marpa_Bocage @var{b})
@end deftypefun

@deftypefun void marpa_b_unref (Marpa_Bocage @var{b})
@end deftypefun

@node Bocage internals,  , Bocage reference counting, Bocage
@section Internals

@deftypefun gint marpa_b_and_node_count ( @
    Marpa_Bocage @var{b})
@end deftypefun

@deftypefun gint marpa_b_and_node_parent ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun gint marpa_b_and_node_predecessor ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun gint marpa_b_and_node_cause ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun gint marpa_b_and_node_symbol ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_b_and_node_token ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id}, @
    gpointer* @var{value_p})

Returns the data for the token of the and-node.
The symbol id is the return value,
and the token value is placed
in the location pointed
to by @var{value_p}, if that is non-null.
If @var{and_node_id} is not the ID of an and-node
whose cause is a token,
returns -1,
without changing @var{value_p}.
On hard failure, returns -2 without changing
@var{value_p}.

There is no function to simply return the token value --
because of the need to indicate errors, it is just as
easy to return the symbol ID as well.
@end deftypefun

@deftypefun Marpa_Or_Node_ID marpa_b_top_or_node ( @
    Marpa_Bocage @var{b})

Return the ID of the top or-node.
@end deftypefun

@deftypefun gint marpa_b_or_node_set ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})

Return the ordinal of the current (final) Earley set of
the or-node.
@end deftypefun

@deftypefun gint marpa_b_or_node_origin ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_rule ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_position ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_first_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_last_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_and_count ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@node Order, Tree, Bocage, Top
@chapter Orderings

@menu
* Ordering constructor::        
* Ordering reference counting::  
* Ordering internals::          
@end menu

@node Ordering constructor, Ordering reference counting, Order, Order
@section Creating an ordering

@deftypefun Marpa_Order marpa_o_new ( @
    Marpa_Bocage @var{b})
@end deftypefun

@deftypefun Marpa_Grammar marpa_o_g ( @
    Marpa_Order @var{o})
@end deftypefun

@node Ordering reference counting, Ordering internals, Ordering constructor, Order
@section Reference counting

@deftypefun void marpa_o_unref ( @
    Marpa_Order @var{o})
@end deftypefun

@deftypefun Marpa_Order marpa_o_ref ( @
    Marpa_Order @var{o})
@end deftypefun

@node Ordering internals,  , Ordering reference counting, Order
@section Internals

@deftypefun gint marpa_o_and_order_set ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    Marpa_And_Node_ID* @var{and_node_ids}, @
    gint @var{length})
@end deftypefun

@deftypefun Marpa_And_Node_ID marpa_o_and_order_get ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    gint @var{ix})
@end deftypefun

@node Tree, Value, Order, Top
@chapter Tree iterators

Within Marpa,
when it makes sense in context,
"tree" means a parse tree.
Marpa's parse trees are also bocage iterators.

@menu
* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              
* Tree internals::              Internals.
@end menu

@node Tree constructor, Tree reference counting, Tree, Tree
@section Creating a new tree iterator

@deftypefun Marpa_Tree marpa_t_new (Marpa_Order @var{o})
@end deftypefun

@deftypefun Marpa_Grammar marpa_t_g (Marpa_Tree @var{o})

This function returns the grammar of the tree.
It never returns an error.
The grammar is always set when the tree is initialized,
and is never changed while the tree exists.
Fatal state is not reported,
because it is kept in the grammar,
so that
either we can return the grammar in spite of
its fatal state,
or the problem is so severe than no
errors can be properly reported.

@end deftypefun

@node Tree reference counting, Tree iteration, Tree constructor, Tree
@section Reference counting

@deftypefun Marpa_Tree marpa_t_ref (Marpa_Tree @var{t})
@end deftypefun

@deftypefun void marpa_t_unref (Marpa_Tree @var{t})
@end deftypefun

@node Tree iteration, Tree internals, Tree reference counting, Tree
@section Iterating through the trees

@deftypefun gint marpa_t_next ( @
	Marpa_Tree @var{t})
@end deftypefun

@deftypefun gint marpa_t_parse_count ( @
	Marpa_Tree @var{t})
@end deftypefun

@node Tree internals,  , Tree iteration, Tree
@section Internals

In Marpa, a nook is any node of a parse tree.
The usual term is "node",
but within Marpa,
the word "node" is already heavily overloaded.
So what most texts call "tree nodes" are here
called "nooks".
"Nook" can be thought of as a pun on both
"node" and "fork".

@deftypefun gint marpa_t_size ( @
	Marpa_Tree @var{t})

Return the size of the parse tree.
This is the number of nooks in its stack.
If there is a serioius error,
or if the tree is uninitialized, return -2.
If the tree is exhausted, return -1.
@end deftypefun

@deftypefun Marpa_Or_Node_ID marpa_t_nook_or_node ( @
    Marpa_Tree @var{t}, @
    Marpa_Nook_ID @var{nook_id})

Return the ID of the or-node for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_choice ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the current choice for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_parent ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the parent nook's ID for @var{nook_id}.
As with the other nook trace functions,
-1 is returned if @var{nook_id} is not the ID of
a nook on the stack,
but -1 can also be a valid value.
If that's an issue, the @var{nook_id} needs
to be checked with one of the trace functions
where -1 is never a valid value ---
for example, @code{marpa_t_nook_or_node}.
@end deftypefun 
@deftypefun gint marpa_t_nook_cause_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the cause-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_predecessor_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the predecessor-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_is_cause ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-cause bit for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_is_predecessor ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-predecessor bit for @var{nook_id}.
@end deftypefun

@node Value, Error handling, Tree, Top
@chapter Value objects

@menu
* Valuator constructor::        
* Valuator access macros::      
* Valuator reference counting::  
* Valuator stepping::           
* Valuator tracing::            
@end menu

@node Valuator constructor, Valuator access macros, Value, Value
@section Creating a new valuator

@deftypefun Marpa_Value marpa_v_new ( @
    Marpa_Tree @var{t})
@end deftypefun

@deftypefun Marpa_Grammar marpa_v_g (Marpa_Value @var{v})
@end deftypefun

@deftypefun void marpa_v_unref (Marpa_Value @var{v})
@end deftypefun

@deftypefun gint marpa_v_symbol_ask_me_when_null_set( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid}, @
    int @var{value})
@end deftypefun

@deftypefun gint marpa_v_symbol_is_ask_me_when_null( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun

@node Valuator access macros, Valuator reference counting, Valuator constructor, Value
@section Valuator access macros

Accessors which are implemented as macros.

@defmac Marpa_Symbol_ID marpa_v_semantic_token(Marpa_Value @var{v})
@end defmac

@defmac gpointer marpa_v_token_value(Marpa_Value @var{v})
@end defmac

@defmac Marpa_Rule_ID marpa_v_semantic_rule(Marpa_Value @var{v})
@end defmac

@defmac gint marpa_v_arg_0(Marpa_Value @var{v})
@end defmac

@defmac gint marpa_v_arg_n(Marpa_Value @var{v})
@end defmac

@node Valuator reference counting, Valuator stepping, Valuator access macros, Value
@section Reference counting

@deftypefun Marpa_Value marpa_v_ref (Marpa_Value @var{v})

Returns the grammar of the value.
It never returns an error.
The grammar is always set when the value is initialized,
and is never changed while the value exists.
Fatal state is not reported,
because it is kept in the grammar,
so that
either we can return the grammar in spite of
its fatal state,
or the problem is so severe than no
errors can be properly reported.

@end deftypefun

@node Valuator stepping, Valuator tracing, Valuator reference counting, Value
@section Stepping through the valuator

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_TRACE
The data for tracing is ready.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_TOKEN
The data for a semantic token is ready.
The token is non-nulling and will have a value.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_NULLING_TOKEN
The data for a semantic token is ready.
The token is nulling and it is up to the application
to provide any value, if one is needed.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_RULE
The data for a semantic rule is ready.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_INACTIVE
The valuator is inactive.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_INTERNAL1
@deftypevrx Macro Marpa_Value_Type MARPA_VALUE_INTERNAL2
These value types are reserved for internal purposes
@end deftypevr

@deftypefun Marpa_Value_Type marpa_v_step ( @
    Marpa_Value @var{v})
@end deftypefun

@node Valuator tracing,  , Valuator stepping, Value
@section Tracing the valuator

@deftypefun gint marpa_v_trace ( @
    Marpa_Value @var{v}, @
    gint @var{flag})
@end deftypefun

@deftypefun Marpa_Nook_ID marpa_v_nook ( @
    Marpa_Value @var{v})
@end deftypefun

@node Error handling,  , Value, Top
@chapter Error handling

@section Soft and hard errors

Soft errors are errors which may be a result of normal processing.
Soft errors often do not disrupt the flow of processing,
and applications typically do not treat soft errors
as fatal errors.
When a soft error is an interruption of normal processing,
the disruption is usually recoverable.

Hard errors are errors which are never the result of
normal processing.
They almost always disrupt the flow of processing.
Recovery from a hard error is usually not possible,
and an application will usually treat a hard error
as a fatal error.

The difference between hard and soft errors can
depend, to a certain extent,
on the application.
libmarpa has its own idea of what is a hard
and soft error but,
whenever possible,
it does not enforce this on the application.
An application is also free to treat a soft
error as a hard error.
And libmarpa makes
every attempt to allow an application to
reinterpret a hard error as a soft error.

@section Methods

@deftypefun Marpa_Error_Code marpa_g_error @
    ( Marpa_Grammar @var{g}, @
    const char** @var{p_error_string})
@end deftypefun

@section Error Macros

@deftypevr Macro int MARPA_ERRCODE_COUNT
The number of error codes.
@end deftypevr

@section Error Codes

@deftypevr Macro int MARPA_ERR_NONE
No error condition since the last time the
error code was reset or,
if there was no reset,
since grammar initialization.
Suggested message: "No error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_COUNTED_NULLABLE
A "counted" symbol is also a nullable symbol.
A "counted" symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting occurrences of it,
which is what sequence rules do for their RHS
symbols,
becomes very difficult.
All sorts of questions of definition and
problems of implementation arise.
At a minimum, such a sequence would be wildly
ambigious.

Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
Suggested message: "Nullable symbol on RHS of a sequence rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DEVELOPMENT
The "development" errors is for use during
libmarpa's development,
while it is not yet clear how precisely
to classify every error condition.
The error string is a
short 7-bit ASCII error string
which describes the error.
Classifying an error as "development"
is a temporary measure,
taken until the error can be more
precisely defined and classed.
Suggested message: "Development error, see string."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_RULE
This error indicates an attempt to add a rule which
is a duplicate of a rule already in the grammar.
Two rules are considered duplicates if

@itemize @bullet
@item
Both rules have the same left hand symbol.
@item
Both rules have the same right hand symbols in the same order.
@end itemize

This definition applies to sequence rules, as well as to ordinary rules. As a consequence, sequence rules can be considered duplicates even when they have different separators and/or different minimum counts.
Suggested message: "Duplicate rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_COUNT
libmarpa allows a maximum number of earley
items per Earley set.
This error code indicates that limit was
exceeded.
Note that this limit is different from
the optional earley item
warning threshold, which can be set
by the application.
Exceeding the warning threshold causes
a libmarpa event, which the application
is free to treat as a hard or soft error.
Suggested message: "Maximum number of earley items exceeded."

Most likely, memory will run out for
other reasons long before this error can
occur.
The maximum earley item count for the
purposes of this error code
is over a billion.
As a contrast, a reasonable setting for the
warning threshold,
even when exceeding the threshold is
treated as a fatal error,
will usually be well under 1000.
If this error code ever does occur,
it is almost certainly both a hard and a 
fatal error.
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL
Internal errors are errors which
"should not happen".
They could result when the calling program
overwrites libmarpa's internal data.
They may also indicate a bug in libmarpa.
An internal error will usually be a hard error.
Suggested message: "Internal error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_LHS_IS_TERMINAL
By default,
and unlike most parsing algorithms,
libmarpa allow LHS terminals
-- symbols on the LHS side of a rule,
but which may also be terminals.
This behavior is configurable,
and if
the LHS terminals flag for a grammar is unset,
LHS terminals become illegal,
and cause this error.
Suggested message: "There is a LHS terminal in a grammar which has disallowed them."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NULL_RULE_UNMARKED_TERMINALS
Marpa allows all symbols to be terminals, even those on the LHS,
and this is the default.
But when there is an null rule in the grammar,
having lots of terminals is an efficiency hit.
For that reason, if a grammar has a null rule,
libmarpa requires the application to explictly
indicate which symbols are terminals,
and will not accept the default.

An application is still able to have as many terminals
as it wants,
including terminals on the LHS of rules.
The only requirement is the the user explicitly
set those symbols which are terminals.
Terminals may be explicitly marked on a per-symbol
basis.
The application can
also prevent this error by
unsetting the LHS terminals flag for a grammar.
Suggested message: "A grammar with null rules must mark its terminals."
@end deftypevr

@deftypevr Macro int MARPA_ERR_PRECOMPUTED
An attempt was made to use a precomputed grammar
in a way that is not allowed.
After a grammar is precomputed,
any changes to it that would invalidate
the precomputation
is not allowed.
Almost all changes to a grammar invalidate
the precomputations.
Suggested message: "This grammar is precomputed."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_PARSE
The application attempted to create a bocage
from a recognizer without a parse.
The application will often treat this as
a soft error.
Suggested message: "No parse."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_RULES
A grammar which has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
The precomputations are not defined
for grammar without rules,
in large part because it would be useless to do so.
Suggested message: "This grammar does not have any rules."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_START_SYMBOL
The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one.
For example, no grammar without a start
symbol can be precomputed.
Suggested message: "This grammar has no start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_START_NOT_LHS
The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Start symbol not on LHS of any rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SYMBOL_NOT_NULLABLE
In circumstances where a symbol is required to be a nullable
symbol,
it is not.
One such circumstance when the symbol is the
argument of a
@code{marpa_v_symbol_ask_me_when_null_set}
call.
Suggested message: "Symbol not nullable."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNKNOWN
The cause of the error could not be determined.
This usually indicates a problem in the error handling
logic itself.
This will usually be a hard error.
Suggested message: "Unknown error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNPRODUCTIVE_START
The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Unproductive start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_ORDER_FROZEN
The Marpa order object has been frozen.
Multiple trees can share a Marpa order object,
but that order object is @dfn{frozen} after the first tree
is created from it.
If a Marpa order object is @dfn{frozen}, it cannot be
changed.
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.
@end deftypevr

@bye
