\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename api.info
@settitle Libmarpa @value{VERSION}
@c %**end of header
@include version.texi
@copying
This manual is for Libmarpa @value{VERSION}.
Copyright @copyright{} 2012 Jeffrey Kegler.
@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation;
@end quotation
@end copying
@finalout
@titlepage
@title Libmarpa
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Jeffrey Kegler
@c The following two commands
@c start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying

Published @value{UPDATED} by Jeffrey Kegler
@end titlepage
@c So the toc is printed at the start.
@contents
@ifnottex
@node Top, How to read this document, (dir), (dir)
@top Libmarpa: The Marpa low-level library

This manual is for Libmarpa, version @value{VERSION}.

@end ifnottex
@menu
* How to read this document::   
* About Libmarpa::              What is Libmarpa?
* Libmarpa objects::            
* The architecture of Marpa::   
* Threads::                     
* Terminal and tokens::         
* Semantics::                   
* Error handling concepts::     
* Introduction to the External Interface::  
* Static Methods::              
* Grammar objects::             
* Recognizers::                 Recognizers.
* Bocage::                      Bocage objects.
* Ordering objects::            
* Tree::                        Parse Trees.
* Value::                       Value objects.
* Events::                      Libmarpa Events
* Error macros and code::       
* Design considerations::       
* Things To Do::                
* Internal Interface::          

@detailmenu
 --- The Detailed Node Listing ---

How to read this document

* Prerequisites::               Prerequisites.
* Parsing theory::              Parsing theory.

Libmarpa objects

* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  
* Numbered objects::            

The architecture

* Architecture - Grammar::      
* Recognition versus parsing::  

Grammars

* Precomputation::

Recognition versus parsing

* Precomputation::              

Threads

* C89 and thread-safety::       
* Base grammars cannot be shared between threads::  

C89 and thread-safety

* C89 and thread-safety::

Terminal and tokens

* LHS Terminals::               
* Token values::                

Semantics

* Whatever values::             
* Caution about whatever values::  

Error handling

* Memory allocation failures::  
* Soft and hard errors::        

Introduction to the External Interface

* Return value descriptions::   

Grammar objects

* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals::                   Terminal symbols.
* Rules::                       
* Sequences::                   
* Grammar precomputation::      Precomputing the Grammar.
* Grammar events::              

Recognizer objects

* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life::             Taking a recognizer through its life cycle.
* Recognizer events::           

Bocage objects

* Bocage reference counting::   

Ordering objects

* Ordering constructor::        
* Ordering reference counting::  

Tree iterators

* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              

Value objects

* About the valuator::          
* Valuator constructor::        
* Valuator reference counting::  
* Valuator stepping::           
* Step accessors::              

Events

* Event codes::                 Event codes.

Error macros and code

* Methods::                     
* Error Macros::                
* Error Codes::                 

Design considerations

* Why so many time objects::    
* Design of numbered objects::  

Internal Interface

* Symbol internal methods::     
* Rule internals::              
* Grammar internals::           
* Recognizer internals::        
* Bocage internals::            
* Ordering internals::          
* Tree internals::              
* Valuator internals::          

@end detailmenu
@end menu

@node How to read this document, About Libmarpa, Top, Top
@chapter How to read this document

@menu
* Prerequisites::               Prerequisites.
* Parsing theory::              Parsing theory.
@end menu

@node Prerequisites, Parsing theory, How to read this document, How to read this document
@section Prerequisites

This document is very far from self-contained.
It assumes the following:
@itemize
@item
The reader knows the C programming language.
@item
The reader
has read the documents for one of Libmarpa's upper layers.
@item
The reader knows some parsing theory.
@xref{Parsing theory}.
@end itemize

@node Parsing theory,  , Prerequisites, How to read this document
@section Parsing theory

This document assumes an acquaintance
with parsing theory.
As a test of whether he needs to refresh
his knowledge before tackling
this document,
I hope the reader will find it helpful to
ask himself the
following list of questions.
@itemize @bullet
@item
What is a BNF rule?
@item
What is a Marpa sequence rule?
@item
As a reminder,
Marpa's sequence rules are implemented
as left recursions.
What does that mean?
@item
Take a Marpa sequence rule at random.
What does it look like when rewritten in BNF?
@item
What does the sequence look like when rewritten
in BNF as a right-recursion?
@end itemize
For a reader to be satisfied with the level of detail
in the following pages,
he probably should be able to answer all the questions
in the above list after a moment of thought.

On the encouraging side,
while BNF has been overshadowed
by regular expressions, and is now considered
an advanced skill,
BNF is in fact as easy (or easier) to learn
and manipulation than regular expressions.
If a reader has learned how to use
one of the packages that extend
regular expressions,
he should have no trouble with BNF.

@node About Libmarpa, Libmarpa objects, How to read this document, Top
@chapter About Libmarpa
Libmarpa implements the Marpa parsing algorithm.
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

Libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees.
It also supports the ordering and evaluation of the parse
trees.

Libmarpa is very low-level.
For example, it has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for most applications.
A user will almost always want,
at a minimum,
names for the symbols and non-integer values for
tokens.
Typically, an application will use arrays to
translate Libmarpa's integer ID's to strings or other
values as required.

Libmarpa also does @strong{not} implement most of the semantics.
Libmarpa does have an evaluator, but it does @strong{not}
manipulate the stack directly.
Instead, Libmarpa,
based on its traversal of the parse tree,
passes optimized step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved
involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.

Marpa requires most semantics to be
implemented in the application.
This allows the application total flexibility.
It also puts
the application is in a much better position to prevent errors,
to catch errors at runtime or,
failing all else,
to successfully debug the logic.

@node Libmarpa objects, The architecture of Marpa, About Libmarpa, Top
@chapter Libmarpa objects

Libmarpa's most important objects are time objects.
Time objects are so called for two related reasons.
First, they relate to a ``time'' in the progress of a parse.
Second, each time object has a lifetime and is reference counted.

Libmarpa's major objects are called ``time'' objects instead
of phase objects,
because phases are exclusive and non-simultaneous
-- when one phase ends, another begins.
Time objects are often in use simultaneously.
In our lives, work and play are times.
Infancy, adolescent and adulthood are phases.

The time objects are, in sequence:
@itemize
@item Grammars.
@item Recognizers.
@item Bocages.
@item Orderings.
@item Trees.
@item Valuators.
@end itemize

@menu
* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  
* Numbered objects::            
@end menu

@node The sequence of time objects, Base grammars, Libmarpa objects, Libmarpa objects
@section The sequence of time objects

While time objects do not correspond to phases,
they do have a well-defined sequence.
Except for grammars,
all time objects are created from another time
object.
A recognizer cannot be created without a precomputed grammar;
a bocage cannot be created without a recognizer;
and so on.

@node Base grammars, The lifetime of time objects, The sequence of time objects, Libmarpa objects
@section Every time object has a base grammar

When one time object is used to create a second
time object,
the first time object is the @dfn{parent object}
and the second time object is the @dfn{child object}.
For example, when a bocage is created from a
recognizer,
the recognizer is the parent object,
and the bocage is the child object.

Grammars have no parent object.
Every other time object has exactly one parent object.
Valuation objects have no child objects.
All other time objects can have any number of children,
from zero up to a number determined by the memory limits
or the architecture.

Every time object has a @dfn{base grammar}.
A grammar object is its own base grammar.
The base grammar of a recognizer is the grammar
that it was created with.
Similarly,
the base grammar of any other time object is the base
grammar of its parent object.
For example,
the base grammar of a bocage is the base
grammar of the recognizer that it was created
with.

@node The lifetime of time objects, Numbered objects, Base grammars, Libmarpa objects
@section The lifetime of time objects

Time objects are reference-counted.
Every time object is created with a reference count of 1.
Whenever one time object is created from another,
the parent time object has its reference count incremented
by 1.

Time objects do not have explicit destructors.
Every time object has a method which decrements its
reference count by 1.
When the reference count of a time object reaches
0, that time object is destroyed.

In ordinary circumstances, all an application has to
do is keep in mind that it ``owns'' the time objects
it has created,
and that it must call a method
to ``unreference'' that object when it is finished.

In some applications, multiple parts of it
may need to share ownership of an object.
For such situations,
every time object has a method to increment
the reference count.

@node Numbered objects,  , The lifetime of time objects, Libmarpa objects
@section Numbered objects

In addition to its major, ``time'' objects, Libmarpa also has
numbered objects.
Numbered objects do not have lifetimes of their own.
Every numbered object belongs to a timed object,
and is destroyed with it.

Rules and symbols are numbered objects.
Tokens values are
another examples of numbered objects.

@node The architecture of Marpa, Threads, Libmarpa objects, Top
@chapter The architecture

@menu
* Architecture - Grammar::      
* Recognition versus parsing::  
@end menu

@node Architecture - Grammar, Recognition versus parsing, The architecture of Marpa, The architecture of Marpa
@section Grammars

As per parsing theory,
before an input can be parsed,
a grammar must be defined.
Traditionally,
a grammar consists of a set of terminal symbols,
a set of non-terminal symbols,
a set of rules,
and a distinguished start symbol.

@menu
* Precomputation::
@end menu

@node Recognition versus parsing,  , Architecture - Grammar, The architecture of Marpa
@section Recognition versus parsing

Even in the academic literature,
parsing is used in many senses,
Determining whether a string matches a grammar is called
@dfn{recognition}.
Finding the structure of the recognized string according
to the grammar is
@dfn{parsing} in a very strict sense of the term.
Strictly speaking,
Earley's algorithm was a recognizer,
and not a parser.
Marpa contains both a recognizer
and a parser in the strict sense.
Marpa's recognizer is implemented by its recognizer time objects.
Marpa's parser in the strict sense
is implemented by its bocage class and the classes
which follow the bocage in the time object sequence.

@menu
* Precomputation::              
@end menu

@node Precomputation,  , Recognition versus parsing, Recognition versus parsing
@subsection Precomputation

Before a recognizer can be created from a grammar,
it must be precomputed.
Internally, precomputation is what the term
suggests --
the memoization of a large number
of facts about the grammar to allow
the recognizer to proceed more efficiently.
Marpa makes aggressive use of grammar precomputation.

Precomputation ``freezes'' a grammar.
New symbols, rules and sequences cannot be added
to a precomputed grammar
are disallowed,
as are most other changes.

@node Threads, Terminal and tokens, The architecture of Marpa, Top
@chapter Threads

Libmarpa is thread-safe,
if used as described below.
The Libmarpa methods are not reentrant.

@menu
* C89 and thread-safety::       
* Base grammars cannot be shared between threads::  
@end menu

@node C89 and thread-safety, Base grammars cannot be shared between threads, Threads, Threads
@section C89 and thread-safety

Libmarpa is C89-compliant.
It uses no global data,
and it does not use those C library functions which
are inherently thread-unsafe.

Libmarpa calls only the routines
that are defined in the C89 standard
and that can be made thread-safe.
In most modern implementations these are thread-safe.
But the C89 standard does not require thread-safety,
and even most modern environments allow the user
to turn thread safety off.
To be thread-safe, Libmarpa must be compiled
and linked in an environment that provides
thread-safety.

@menu
* C89 and thread-safety::
@end menu

@node Base grammars cannot be shared between threads,  , C89 and thread-safety, Threads
@section Base grammars cannot be shared between threads
While Libmarpa can be used safely across
multiple threads,
a Libmarpa grammar cannot be.
Further, a Libmarpa time object can
only be used safely in the same thread
as its base grammar.
This is because all
time objects with the same base grammar share data
from that base grammar.

To work around this limitation,
the same grammar definition can be
used to a create a new
Libmarpa grammar
time object in each thread.
If there is sufficient interest, future versions of
Libmarpa could allow thread-safe
cloning of grammars and other
time objects.

@node Terminal and tokens, Semantics, Threads, Top
@chapter Terminal and tokens

A terminal symbol is a symbol which
may appear in the input.
Traditionally,
all LHS symbols, as well as
the start symbol, must be non-terminals.
Marpa's grammars differ from the traditional ones
in that there is no necessary distinction between
terminals and non-terminals.
In Marpa,
a terminal may be the start symbol,
and may appear on the LHS of a rule.
However,
since terminals can never be zero length,
it is a logical contradiction for a nulling
symbol to also be a terminal
and Marpa does not allow it.

@menu
* LHS Terminals::               
* Token values::                
@end menu

@node LHS Terminals, Token values, Terminal and tokens, Terminal and tokens
@section Uses for LHS terminals

Marpa's idea
in losing the sharp division between terminals
and non-terminals is that the distinction,
while helpful for proving theorems,
is not essential in practice.
If LHS symbols
appear in the input they, in effect,
``short circuiting'' the rules in which they occur.
This may
be helpful in debugging, or have other applications.

However,
it also can be useful,
for checking input validity as well as for efficiency,
to follow tradition and distingush
non-terminals from terminals.
For this reason,
the traditional behavior is the default
in Marpa.

@node Token values,  , LHS Terminals, Terminal and tokens
@section Token values

Token values are @code{int}'s.
Libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.
Integers are used as token values instead of
pointers because their validity can be safely checked.
It is hard or impossible
to check the validity of pointers
without risking an abend.
Integers can be used to access any kind of data
using an array,
so that the higher levels can translate integers back
and forth into whatever the application requires.

@node Semantics, Error handling concepts, Terminal and tokens, Top
@chapter Semantics

@menu
* Whatever values::             
* Caution about whatever values::  
@end menu

@node Whatever values, Caution about whatever values, Semantics, Semantics
@section ``Whatever'' values

Libmarpa allows
``whatever'' semantics, because it can be easily optimized and it occurs
quite frequently in practical parsing situations.  ``Whatever''
values are more frequently called "arbitrary" values.
The author's problem
with the term "arbitrary" is that it is heavily overloaded, with
several closely related meanings, so that it is hard to understand
exactly what is meant.  And unfortunately, it is used in circumstances
where the exact meaning can be quite important.

In Libmarpa, a ``whatever'' value is a value each instance of which can
be any value in the universe of possible values, and which has no
other property that can be relied on.  ``Whatever'' values may stay
constant, or they may vary from instance to instance.  If and when
they do vary, they may do so randomly, or according to an arbitrary
pattern.

@node Caution about whatever values,  , Whatever values, Semantics
@section A caution about ``Whatever'' values

If a value is not a ``whatever'' value, this document calls
it a defined value.
It is important to realize that
it is impossible to tell the difference between a defined value
and a ``whatever'' value:
they could by coincidence be exactly the same.
Marpa::R2, as of this writing the standard upper layer for Libmarpa,
does not allow any symbol
to have both ``whatever'' and defined semantics.

But
Libmarpa itself does nothing to prevent the application from
mixing ``whatever'' and defined
values in any way it pleases.
This is in keeping with Libmarpa's design goals of maximum
flexibility and minimal overhead.
This flexibility might be exploited,
for example, by applications
that distinguish ``whatever'' values from defined values,
by context.

@node Error handling concepts, Introduction to the External Interface, Semantics, Top
@chapter Error handling

@menu
* Memory allocation failures::  
* Soft and hard errors::        
@end menu

@node Memory allocation failures, Soft and hard errors, Error handling concepts, Error handling concepts
@section Memory allocation failures

Libmarpa leaves the decision of what is a fatal
error up to the application,
with one exception.
Currently, if @code{malloc} fails to allocate memory,
Libmarpa terminates the program with a fatal error.

While this is in keeping with current practice,
future versions of Libmarpa are likely to both allow
an alternative memory allocator to be specificied,
and to allow the user to specifier a handler to
be called when an out-of-memory condition occurs.

@node Soft and hard errors,  , Memory allocation failures, Error handling concepts
@section Soft and hard errors

Soft errors are errors which may be a result of normal processing.
Soft errors often do not disrupt the flow of processing,
and applications typically do not treat soft errors
as fatal errors.
When a soft error is an interruption of normal processing,
the disruption is usually recoverable.

Hard errors are errors which are never the result of
normal processing.
They almost always disrupt the flow of processing.
Recovery from a hard error is usually not possible,
and an application will usually treat a hard error
as a fatal error.

The difference between hard and soft errors can
depend, to a certain extent,
on the application.
Libmarpa has its own idea of what is a hard
and soft error but,
whenever possible,
it does not enforce this on the application.
An application is also free to treat a soft
error as a hard error.
And Libmarpa makes
every attempt to allow an application to
reinterpret a hard error as a soft error.

@node Introduction to the External Interface, Static Methods, Error handling concepts, Top
@chapter Introduction to the External Interface

The following chapters describe Libmarpa's external
interface in detail.

@menu
* Return value descriptions::   
@end menu

@node Return value descriptions,  , Introduction to the External Interface, Introduction to the External Interface
@section Return value descriptions

Most function descriptions have a section describing their
return values.
In these sections, @dfn{success} means that the method
successfully accomplished its primary purpose.
A @dfn{hard failure}, or sometimes simply a @dfn{failure}
means that the method failed in a way that
is usually not part of the normal processing.
A @dfn{soft failure} means that
the method accomplished a secondary purpose,
one which can be considered either a failure
or a success depending on the circumstances.
Where function return an integer value,
unless otherwise stated,
-1 will indicate a soft failure
and -2 will indicate a hard failure.

Soft failures are always recoverable.
An example of a soft failure
is when @code{marpa_r_alternative}'s
finds that token is unexpected.
In some cases,
this error will also be unexpected by the
application
and will be an unrecoverable failure.
But the ``Ruby slippers'' parsing method can
incorporate this return value into its normal processing,
as a means of testing alternative inputs and/or
checking the state of the parse.

@dfn{Hard failures} are not always recoverable.
Libmarpa attempts to allow applications to,
on one hand, reclass failures from hard to
soft and proceed whenever possible.
On the other hand, Libmarpa is liberal in
classing problems as soft failures,
and there are many cases that
Libmarpa treats as successes
or soft failures, that an application
will want to escalate to hard
failures.

@node Static Methods, Grammar objects, Introduction to the External Interface, Top
@chapter Static Methods

@deftypefun Marpa_Error_Code marpa_check_version @
    (unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro} @
    )

Checks that the Marpa library in use is compatible with the
given version. Generally you would pass in the constants
@code{MARPA_MAJOR_VERSION},
@code{MARPA_MINOR_VERSION},
@code{MARPA_MICRO_VERSION}
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of Libmarpa the application or module was compiled
against.

Currently Libmarpa is undergoing rapid development,
and backward compatibility is not maintained.
This will be the case as long as Libmarpa stays
alpha.
While Libmarpa is still alpha, much stricter compatibility
will be enforced.
While Libmarpa is alpha
the major, minor and micro numbers must match exactly.

Once Libmarpa is beyond alpha releases,
compatibility will be defined by two things:
first the version
of the running library is newer than the version
@var{required_major}.@var{required_minor}.@var{required_micro}.
Second
the running library must be binary compatible with the
version
@var{required_major}.@var{required_minor}.@var{required_micro}
(same major version.)

Return value: @code{MARPA_ERR_NONE} if the Marpa library is compatible with the
  requested version.  If the library is not compatible,
  one of @code{MARPA_ERR_MAJOR_VERSION_MISMATCH},
  @code{MARPA_ERR_MINOR_VERSION_MISMATCH} or
  @code{MARPA_ERR_MICRO_VERSION_MISMATCH}
  is returned, depending on the nature of the mismatch.

@end deftypefun

@node Grammar objects, Recognizers, Static Methods, Top
@chapter Grammar objects
@cindex grammars

@menu
* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals::                   Terminal symbols.
* Rules::                       
* Sequences::                   
* Grammar precomputation::      Precomputing the Grammar.
* Grammar events::              
@end menu

@node Grammar constructor, Grammar reference counting, Grammar objects, Grammar objects
@section Creating a new grammar
@cindex grammar constructor

@deftypefun Marpa_Grammar marpa_g_new ( @
    unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro})

Creates a new grammar time object.
The returned grammar object is not yet precomputed,
and will have no symbols and rules.
Its reference count will be 1.

After a @code{marpa_g_new} call, the next step is
usually the addition of rules and symbols
in preparation for grammar precomputation.

The expected major, minor and micro version
numbers must be passed as arguments,
While Libmarpa is alpha,
any mismatch with the actual version will
cause a failure.

Return value: On success, the grammar object.
On failure, @code{NULL}.

@end deftypefun

@node Grammar reference counting, Symbols, Grammar constructor, Grammar objects
@section Tracking the reference count of the grammar
@cindex grammar destructor
@cindex grammar reference
@cindex grammar reference count

@deftypefun void marpa_g_unref (Marpa_Grammar @var{g})
Decreases the reference count by 1,
destroying @var{g} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

@end deftypefun

@deftypefun Marpa_Grammar marpa_g_ref (Marpa_Grammar @var{g})

Increases the reference count.

Return value:
On success, the grammar object it was called with;
@code{NULL} on failure.

@end deftypefun

@node Symbols, Terminals, Grammar reference counting, Grammar objects
@section Symbols

@deftypefun Marpa_Symbol_ID marpa_g_symbol_new (Marpa_Grammar @var{g})

Creates a new symbol.

Return value: On success, the ID of a new symbol;
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{id})

Sets the start symbol of grammar @var{g} to symbol @code{id}.
To be precomputed, a grammar must have a start symbol.

Return value: On success, the ID of the new start symbol.
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol (Marpa_Grammar @var{g})

Returns current value of the start symbol of grammar @var{g}.
The value is that of the user's start
symbol, as specified in the @code{marpa_g_start_symbol_set} call,
if there has been one.

Return value:
On failure, -2;
-1 if there is no start symbol yet;
otherwise the ID of the new start symbol.
@end deftypefun

@deftypefun int marpa_g_symbol_count (Marpa_Grammar @var{g})
Return value:
On success, the symbol count of the grammar.
On failure, -2.
@end deftypefun

@node Terminals, Rules, Symbols, Grammar objects
@section Methods for terminal symbols

@deftypefun int marpa_g_symbol_is_terminal ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
Return value: On success, 1 if @var{symid} is a terminal symbol, 0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_terminal_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 int @var{value})
This function flags symbol @var{symid} as a terminal if
@var{value} is 1,
or flags it as a non-terminal if @var{value} is 0.
By default, a symbol is a terminal if and only if it
does not appear on the LHS of any rule.
This setting overrides the default.
An attempt to flag a nulling symbol
as a terminal is a fatal error,
but this is not necesssarily detected before precomputation.

Return value: On success, 1 if @var{symid} is a terminal symbol after the
call, 0 otherwise.
If @var{value} is not 0 or 1;
if the grammar @var{g} is precomputed;
or on some other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{accessible} if it can be reached from the start symbol.
This is not known until the grammar is precomputed.

Return value: On success, 1 if accessible, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{productive} if it can produce a string of terminals.
All nullable symbols are considered productive.
This is not known until the grammar is precomputed.

Return value: On success, 1 if productive, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_start ( Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})

This return value of this call indicates whether @var{symid}
is the start symbol.

Return value: -2 if @var{symid} is not valid;
    1 if @var{symid} is the start symbol;
    0 otherwise.

@end deftypefun

@deftypefun int marpa_g_symbol_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{nulling} if it always produces the empty string.
This is not determined until the grammar is precomputed.

Return value: On success, 1 if symbol is nulling, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_nullable ( @
  Marpa_Grammar g, Marpa_Symbol_ID symid)
A symbol is @dfn{nullable} if it sometimes produces the empty string.
A @strong{nulling} symbol is always a @strong{nullable} symbol,
but not all @strong{nullable} symbols are @strong{nulling} symbols.
This is not determined until the grammar is precomputed.

Return value: On success, 1 if symbol is nullable, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_ask_me_when_null_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id}, @
    int value)
@deftypefunx int marpa_g_symbol_is_ask_me_when_null ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id})

In Marpa,
most of the semantics is usually be implemented by the
higher layers.
This is called @dfn{``ask me'' semantics}.
The ``ask me when null''
calls deal with the handling of semantics
in case when the symbol is nulling.
For proper nullables,
the ``Ask me when null'' setting is relevant
only in cases where the symbol is nulled.

Marpa's default is to assume that the
value of nulled symbols will be ignored,
and to let that value be ``whatever''.
``Whatever'' here means it may not be relied
and may change from instance to instance.
Marpa optimizes for cases where symbols
have ``whatever'' values.

Return value: On success, 1 if the resulting semantics after
  the function call is the ``ask me'' semantics,
  0 if not.
On failure, -2.

@end deftypefun

@node Rules, Sequences, Terminals, Grammar objects
@section Rules

@deftypefun int marpa_g_rule_count (Marpa_Grammar @var{g})
Return value: On success, the current number of rules in grammar @var{g}.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Rule_ID marpa_g_rule_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs}, @
 Marpa_Symbol_ID *@var{rhs}, @
     int @var{length})
Creates a new external rule in grammar @var{g}.
The LHS symbol is @var{lhs},
and there are @var{length} symbols on the RHS,
which is pointed to by @var{rhs}.

An attempt to add a duplicate rule is a hard failure.
A rule is considered a duplicate if it has the same
LHS symbol,
and the same RHS symbols in the same order.
A rule is also considered a duplicate if it has
the same LHS symbol as a sequence rule,
regardless of the right hand sides of the
two rules.

Return value:  On success, the ID of new external rule.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value: On success, the LHS symbol of the rule.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
The length of a rule is the number of symbols on its RHS.

Return value: On success, the rule length.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id}, @
    int @var{ix})
The position in the rule, @var{ix}, is zero-based.
If @var{ix} is greater than or equal the length of the
rule, it is a soft failure.
This can be used in loops, to avoid having to determine
the rule's length explicitly.

Return value: On success, the symbol in position @var{ix}
on the rules RHS.
If @var{ix} is greater than or equal to the length of
the rule, -1.
On other failures, -2.
@end deftypefun

@deftypefun int marpa_g_rule_whatever_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx int marpa_g_rule_first_child_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx int marpa_g_rule_ask_me_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx int marpa_g_rule_is_ask_me ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})

Usually,
most of the semantics must be implemented by Marpa's
higher layers.
This is called @dfn{``ask me'' semantics}.
In two special but common cases, however,
Marpa can implement the semantics internally,
eliminating an evaluation step.
This can be an considerable efficiency.

The two optimizable cases are ``whatever'' semantics
and ``first child'' semantics.
If a rule has
@dfn{whatever semantics}, that means
that the higher layers
do not care about the value of the rule.
If a rule has
@dfn{first child semantics}, the value of the rule
should be the value of its first child node.
In the current implementation, both of these
can be implemented as stack no-ops.

In the current implementation,
first child semantics is equivalent to whatever semantics.
It is possible that a future implementation will
be unable to implement first child semantics as a stack
no-op.
At that point first child semantics will made equivalent
to ``ask me'' semantics.

Return value: On success, 1 if the resulting semantics after
  the function call is the ``ask me'' semantics;
  0 otherwise.
  On failure, -2.

@end deftypefun

@deftypefun int marpa_g_rule_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{ruleid})
A rule is @dfn{nulling} if it always produces the empty string.
This is not determined until the grammar is precomputed.

Return value: On success, 1 if @var{ruleid} is nulling, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_nullable ( @
  Marpa_Grammar g, Marpa_Rule_ID ruleid)
A rule is @dfn{nullable} if it sometimes produces the empty string.
This is not determined until the grammar is precomputed.
A @strong{nulling} rule is always a @strong{nullable} rule,
but not all @strong{nullable} rules are @strong{nulling} rules.

Return value: On success, 1 if @var{ruleid} is nullable, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{accessible} if it can be reached from the start symbol.
This is not known until the grammar is precomputed.
A rule is accessible if and only if its LHS symbol is accessible.
The start rule is always an accessible rule.

Return value: On success, 1 if accessible, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{productive} if it can be produce a string of terminals.
including the empty string.
This is not known until the grammar is precomputed.
An rule is productive if and only if all the symbols on
its RHS are productive.
An empty rule is considered productive, vacuously.

Return value: On success, 1 if productive, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
A rule is a loop rule if it non-trivially
produces the string of length one
which consists only of its LHS symbol.
``Non-trivially'' means the zero-step derivation does not count -- the
derivation must have at least one step.

The presence of a loop rule makes a grammar infinitely ambiguous,
and applications will typically want to treat them as fatal errors.
But nothing forces an application to do this,
and Marpa will successfully parse and evaluate grammars with
loop rules.

Return value: On success, 1 if this is a loop rule, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@node Sequences, Grammar precomputation, Rules, Grammar objects
@section Sequences

@deftypefun Marpa_Rule_ID marpa_g_sequence_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs_id}, @
 Marpa_Symbol_ID @var{rhs_id}, @
     Marpa_Symbol_ID @var{separator_id}, @
    int @var{min}, @
 int @var{flags} )
Adds a new sequence rule to grammar @var{g}.
Internally, Libmarpa translates sequences into BNF
rules, but it also optimizes their evaluation.
In practice this speedup can be considerable.

The sequence is @var{lhs_id},
and the item to be repeated in the sequence is @var{rhs_id}.
The sequence must be repeated at least @var{min} times,
where @var{min} is 0 or 1.
If @var{separator_id} is non-negative,
it is a separator symbol.

If @code{flags & MARPA_PROPER_SEPARATION} is non-zero,
separation is ``proper'', that is,
a trailing separator is not allowed.
The term @dfn{proper} is based on the idea that
properly-speaking, separators should actually separate items.

The sequence RHS, or item,
is restricted to a single symbol,
but almost arbitrary semantics can be expressed by having
@var{rhs_id} be the LHS of another rule.
@var{rhs_id} cannot be a nullable symbol.
If @var{separator_id} is a symbol, it also cannot
be a nullable symbol.

Nullables on the RHS of sequences are restricted
because they lead to highly ambiguous grammars.
Such grammars are allowed by Libmarpa, but
they must be expressed using BNF rules, not sequence rules.
This is for two reasons:
First, sequence optimizations would not work
in the presence of nullables.
Second, it is not completely clear what
an application intends
when it asks for a sequence of identical items,
some of which are nullable,
the user's intent can be more clearly expressed
directly in BNF.

Return value:  On success, the ID of the external rule.
If the rule duplicates another rule,
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_sequence ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value:  1 if @var{rule_id} is a sequence rule,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_counted (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{counted}
if it appears on the RHS of a sequence rule.
The separator symbol of a sequence rule is also considered
to be a counted symbol.

Return value: On success, 1 if the symbol is counted, 0 if not.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_proper_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value:
Returns 1 if
the proper separation flag is set,
0 if not.
Returns 0 if
@var{rule_id} is not a sequence rule.
On hard failure, returns -2.
@end deftypefun

@node Grammar precomputation, Grammar events, Sequences, Grammar objects
@section Precomputing the Grammar

@deftypefun int marpa_g_precompute (Marpa_Grammar @var{g})
This function precomputes the grammar.

In the process, precomputation creates events which
the user can access.
On success, this function returns the number of events
generated,
but it is important to note that events may be
created whether precomputation fails or succeeds.
When the method fails,
the application must call @code{marpa_g_event}
if it want to determine if any events occurred.
Since the reason for failure to precompute is often
detailed in the events, failed applications will often
be at least as interested in the events as those
which succeeded.

Each @code{MARPA_EVENT_LOOP_RULES} event is a rule
which is part of an cycle (infinite loop) in the grammar.
Cycles
are useless in current
practice.
Cycles make a grammar infinitely ambiguous
and their presence makes processing the grammar less
efficient, sometimes considerably so.
Nonetheless, they are not errors in Libmarpa,
although most applications will wish to treat them
as such.

Each @code{MARPA_EVENT_COUNTED_NULLABLE} event is a symbol
which is a nullable on the right hand side of a sequence
rule -- a ``counted'' symbol.
The presence of one or more of these is a hard failure.
So that the programmer can fix several at once,
the failure is delayed until events are created
for all of the counted nullables.

Each @code{MARPA_EVENT_NULLING_TERMINAL} event is a nulling
symbol which is also flagged as a terminal.
Since terminals cannot be of zero length, this is a logical
impossibility, and
the presence of one or more of these is a hard failure.
So that the programmer can fix several at once,
the failure is delayed until events are created
for all of the counted nullables.

Precomputation involves freezing
and then thoroughly checking the grammar,
and it is at this point that many failures
are caught and reported.
Counted nullables and nulling terminals have
already been mentioned.
Grammars without rules and those
with invalid start symbols also produce
hard failures.

Return value: On success, the number of events generated.
If the grammar is already precomputed,
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_is_precomputed (Marpa_Grammar @var{g})
Return value: On success, 1
if grammar @var{g} is already precomputed,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_has_cycle (Marpa_Grammar @var{g})
This function allows the application to determine if grammar
@var{g} has a cycle.
As mentioned, most applications will want to treat these
as fatal errors.
To determine which rules are in the cycle,
@var{marpa_g_rule_is_loop} can be used.

Return value: On success, 1 if the grammar has a cycle,
0 otherwise.
On failure, -2.
@end deftypefun

@node Grammar events,  , Grammar precomputation, Grammar objects
@section Events

@deftypefun int marpa_g_event (Marpa_Grammar @var{g}, @
    Marpa_Event* @var{event}, @
	       int @var{ix})
This method provides access to the events generated
by the @code{marpa_g_precompute} method.
The @var{ix}'th event (numbered from 0) is placed
in the @var{public_event} value.

It is a soft failure if there is no such event.
This can be used as the termination condition
in a loop over the events.

Return value:  On success, returns the type of event @var{ix},
and places the data for the event in @var{public_event}.
If there is no such event, returns -1.
On hard failure, returns -2.
@end deftypefun

@deftypefn {Macro} void* marpa_g_event_value (Marpa_Event* @var{event})
This macro provides access to the ``value'' of the event.
The semantics of the value varies according to the type
of the event, and is described in the section on event
codes.
@xref{Events}.
@end deftypefn

@node Recognizers, Bocage, Grammar objects, Top
@chapter Recognizer objects

@menu
* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life::             Taking a recognizer through its life cycle.
* Recognizer events::           
@end menu

@node Recognizer constructor, Recognizer reference counting, Recognizers, Recognizers
@section Creating a new recognizer

@deftypefun Marpa_Recognizer marpa_r_new ( Marpa_Grammar @var{g} )
Creates a new recognizer.
In order to allow settings to be changed before input starts,
the new recognizer is @strong{not} ready for input.
The @code{marpa_r_start_input} method will make the
recognizer ready for input.

Return value:  On success, the newly created recognizer.
If @var{g} is not precomputed, or on other failure, @code{NULL}.
@end deftypefun

@node Recognizer reference counting, Recognizer life, Recognizer constructor, Recognizers
@section Keeping the reference count of a recognizer

@deftypefun Marpa_Recognizer marpa_r_ref (Marpa_Recognizer @var{r})
Increases the reference count.

Return value:
On success, the @var{r};
@code{NULL} on failure.
@end deftypefun

@deftypefun void marpa_r_unref (Marpa_Recognizer @var{r})
Decreases the reference count by 1,
destroying @var{r} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

@end deftypefun

@node Recognizer life, Recognizer events, Recognizer reference counting, Recognizers
@section Taking a recognizer through its life cycle

@deftypefun int marpa_r_start_input (Marpa_Recognizer @var{r})
Makes @var{r} ready to accept input.

Return value:  On success, a non-negative value.
On failure, -2.
@end deftypefun

@deftypefun int marpa_r_alternative (Marpa_Recognizer @var{r}, @
    Marpa_Symbol_ID @var{token_id}, @
    int @var{value}, @
    int @var{length})
Reads a token into @var{r}.
The token will start at the current earleme.
Libmarpa allows tokens to be ambiguous, to be of
variable length and to overlap.
@var{token_id} is the symbol of the token,
which must be a terminal.
@var{length} is the length of the token.

@var{value} is a integer which represents the value of the
token.
In applications where the token's value is not an integer, it is
expected that the application will use this value to
find the application's value, perhaps by using @var{value}
to index an array.
@var{value} is not used inside Libmarpa -- it is simply
stored to be returned by the valuator
as a convenience for the application.
Some applications will not want to use Libmarpa's token
values, instead tracking their own, perhaps based on
the earleme location, and @var{token_id}.

A @var{value} of 0 has special significance -- it indicates
that the token's value is ``whatever'' -- that it may take an
arbitrary value.
This usually means that the application simply does not
care what the value of the token is.
The value of tokens with a ``whatever'' value
does not need to be stored, tracked or computed either
by Libmarpa or by the application.

Note that if a ``whatever'' value is specified,
it must be the case that @strong{the application}
also does not care about the value of the token.
When a token has a ``whatever'' value, Libmarpa not
only does not store a value itself,
it also optimizes away the valuator steps which
signal to the application that it needs to provide
a value for that token.
Applications which do not use Libmarpa's token values,
but which do care about a token value,
should make @var{value} an arbitrary, non-zero, constant
in order to
tell Libmarpa that the token does need a value
and prevent the valuator from optimizing away those
steps which tell the application that a token needs
to be given a value.

@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme_complete (Marpa_Recognizer @var{r})
This method does the final processing for the current earleme.
It then advances the current earleme by one.
Note that @code{marpa_r_earleme_complete} may be called
even when no tokens have been read at the current earleme --
in the character-per-earleme input model, for example, tokens
can span many characters and, if the input is unambiguous over that
span, there will be no other tokens that start inside it.

During this method, one or more events may occur.
On success, this function returns the number of events
generated,
but it is important to note that events may be
created whether earleme completion fails or succeeds.
When this method fails,
the application must call @code{marpa_r_event}
if it wants to determine if any events occurred.
Since the reason for failure to complete an earleme is often
detailed in the events, failed applications will often
be at least as interested in the events as those
which succeeded.

@code{MARPA_EVENT_EXHAUSTED} indicates that the parse is
exhausted -- that no input will be accepted at later earlemes.
Note that an exhausted parse can be a successful one -- it
just cannot succeed at a later earleme than the current one.

The @code{MARPA_EVENT_EARLEY_ITEM_THRESHOLD} event
indicates that an application-settable threshold
on the number of Earley items has been reached or exceeded.
What this means depends on the application,
but when the default threshold is exceeded,
it means that it is very likely
that the time and space resources consumed by
the parse are going to be excessive.

Return value:  On success, the number of events generated.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{set_id})

In the default, token-stream model, Earley set ID and earleme
are always equal, but this is not the case in other input
models.

Return value:
On success,
returns the earleme corresponding to Earley
set @var{set_id}.
If @var{set_id} is out of bounds,
returns -1.
On other failures, returns -2.
@end deftypefun

@deftypefun @code{unsigned int} marpa_r_current_earleme (Marpa_Recognizer @var{r})
Return value: On success, the current earleme.
If input has not started, -1.
Always succeeds or fails softly.
@end deftypefun

@deftypefun int marpa_r_earley_item_warning_threshold (Marpa_Recognizer @var{r})
@deftypefunx int marpa_r_earley_item_warning_threshold_set (Marpa_Recognizer @var{r}, @
    int @var{threshold})
These methods, respectively, report and set the earley item warning threshold.
The @dfn{Earley item warning threshold}
is a number that is compared with
the count of Earley items in each Earley set.
When it is matched or exceeded,
a @code{MARPA_EVENT_EARLEY_ITEM_THRESHOLD} event is created.

If @var{threshold} is zero or less,
an unlimited number of Earley items
will be allowed without warning.
This will rarely be what the user wants.
By default, Libmarpa calculates a value based on the grammar.
This default value is the result of a considerable amount of experience,
and most applications will
be happy with it.

Return value:
The value that the Earley item warning threshold has
after the method call is finished.
Always succeeds.
@end deftypefun

@deftypefun @code{unsigned int} marpa_r_furthest_earleme (Marpa_Recognizer @var{r})
The ``furthest'' or highest-numbered earleme.
This is the earleme of the last Earley set that contains anything.
Marpa allows variable length tokens,
and in input models which use them,
it may be necessary to track how far out tokens might be found.

Return value: On success, the furthest earleme.
Always succeeds.
@end deftypefun

@deftypefun int marpa_r_terminals_expected ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Symbol_ID* @var{buffer})
Returns a list of the ID's of the symbols
which are acceptable as tokens
at the current earleme.
@var{buffer} is expected to be large enough to hold
the result.
This is guaranteed to be the case if the buffer
is large enough to hold a number of
@code{Marpa_Symbol_ID}'s that
is greater than or equal to the number of symbols
in the grammar.

Return value:  On success, the number of @code{Marpa_Symbol_ID}'s
in @var{buffer}.
On failure, -2.
@end deftypefun

@deftypefun int marpa_r_is_exhausted (Marpa_Recognizer @var{r})
A parser is ``exhausted'' if it cannot accept any more input.
Both successful and failed parses can be ``exhausted''.
In many grammars,
the parse is always exhausted as soon as it succeeds.
And even if the parse is exhausted at a point
where there is no good parse,
there may be good parses at earlemes prior to the
earleme at which the parse became exhausted.

Return value:
1 if the parser is exhausted, 0 otherwise.
Always succeeds.
@end deftypefun

@node Recognizer events,  , Recognizer life, Recognizers
@section Events

@deftypefun int marpa_r_event (Marpa_Recognizer @var{r}, @
    Marpa_Event* @var{event}, @
	       int @var{ix})
This method provides access to the events generated
by the @code{marpa_r_earleme_complete} method.
The @var{ix}'th event (numbered from 0) is placed
in the @var{public_event} value.

It is a soft failure if there is no
@var{ix}'th event.
This can be used as the termination condition
in a loop over the events.

Return value:  On success, returns the type of event @var{ix},
and places the data for the event in @var{public_event}.
If there is no such event (a soft failure),
-1 is returned.
On hard failure, -2 is returned.
@end deftypefun

@deftypefn {Macro} void* marpa_r_event_value (Marpa_Event* @var{event})
This macro provides access to the ``value'' of the event.
The semantics of the value varies according to the type
of the event, and is described in the section on event
codes.
@xref{Events}.
@end deftypefn

@node Bocage, Ordering objects, Recognizers, Top
@chapter Bocage objects

@menu
* Bocage reference counting::   
@end menu

In Libmarpa, recognition and parsing are separate phases.
Once recognition is complete, a parse ``bocage'' must be created
from the recognizer.
(For those familiar with parse forests, a bocage is a
a specialized and extended form of a parse forest.)

@deftypefun Marpa_Bocage marpa_b_new (Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{ordinal_arg})
Return value: On success, the new bocage object.
On soft failure, returns @code{NULL} and sets the error
code to @code{MARPA_ERR_NO_PARSE}.
On other failure, returns @code{NULL} and sets the error
appropriately.
@end deftypefun

@deftypefun Marpa_Grammar marpa_b_g (Marpa_Bocage @var{b})
Return value: The base grammar of @var{b}.
Always succeeds.
@end deftypefun

@node Bocage reference counting,  , Bocage, Bocage
@section  Reference counting
@deftypefun Marpa_Bocage marpa_b_ref (Marpa_Bocage @var{b})
Increases the reference count.

Return value:
On success, @var{b}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_b_unref (Marpa_Bocage @var{b})
Decreases the reference count by 1,
destroying @var{b} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

@end deftypefun

@node Ordering objects, Tree, Bocage, Top
@chapter Ordering objects

@menu
* Ordering constructor::        
* Ordering reference counting::  
@end menu

@node Ordering constructor, Ordering reference counting, Ordering objects, Ordering objects
@section Creating an ordering

Libmarpa allows ambiguous parses.
In many applications it is necessary or desirable to
control the order in which these are traversed.
For this reason,
Libmarpa requires all parse series to be turned
into an ``ordering'' object before traversing
and evaluating them.

In many cases, the ordering is trivial.
Either the parse is unambiguous, or the
application does not care about the order in
which parses are returned.
In such cases,
the creation of the ordering object is a useless
overhead.
Future versions of libmarpa might allow this phase
to be bypassed, but there is little to be gained.
The overhead amounts to little more than two or three
extra subroutine calls.

@deftypefun Marpa_Order marpa_o_new ( @
    Marpa_Bocage @var{b})
Return value: On success, the new ordering object.
On failure, @code{NULL}.
@end deftypefun

@deftypefun Marpa_Grammar marpa_o_g ( @
    Marpa_Order @var{o})
Return value: The base grammar of @var{o}.
Always succeeds.
@end deftypefun

@node Ordering reference counting,  , Ordering constructor, Ordering objects
@section Reference counting

@deftypefun Marpa_Order marpa_o_ref ( @
    Marpa_Order @var{o})
Increases the reference count.

Return value:
On success, @var{o}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_o_unref ( @
    Marpa_Order @var{o})
Decreases the reference count by 1,
destroying @var{o} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

@end deftypefun

@node Tree, Value, Ordering objects, Top
@chapter Tree iterators

Once the bocage has an ordering, the parses can be iterated.
Marpa's tree objects are also bocage iterators.
Within Marpa,
when it makes sense in context,
``tree'' means a parse tree.

@menu
* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              
@end menu

@node Tree constructor, Tree reference counting, Tree, Tree
@section Creating a new tree iterator

@deftypefun Marpa_Tree marpa_t_new (Marpa_Order @var{o})
When created, a tree object is not initialized to
an iteration.
To position the tree to the first parse,
the application must call @code{marpa_t_next}.
(Tree objects are created uninitialized to allow for
future extensions that require the setting of
flags and parameters to control
the iteration.)
When a tree is created from an ordering, that ordering
is ``frozen'', so that it cannot be changed.

Return value:  On success, a newly created tree.
On failure, returns @code{NULL} and sets the error code.
@end deftypefun

@deftypefun Marpa_Grammar marpa_t_g (Marpa_Tree @var{t})
Return value: The base grammar of @var{t}.
Always succeeds.
@end deftypefun

@node Tree reference counting, Tree iteration, Tree constructor, Tree
@section Reference counting

@deftypefun Marpa_Tree marpa_t_ref (Marpa_Tree @var{t})
Increases the reference count.

Return value:
On success, @var{t}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_t_unref (Marpa_Tree @var{t})
Decreases the reference count by 1,
destroying @var{t} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

@end deftypefun

@node Tree iteration,  , Tree reference counting, Tree
@section Iterating through the trees

@deftypefun int marpa_t_next ( @
	Marpa_Tree @var{t})
Iterates the tree to a parse.
Trees are created uninitialized, so
this method must be called before creating a valuator
from a tree.
A tree which has finished its iterations is said to
be ``exhausted''.
It is a soft failure if the tree is exhausted.

Return value: On success, returns a non-negatve value.
If the tree is exhausted, returns -1.
On other failure, returns -2 and sets the error code.
@end deftypefun

@deftypefun int marpa_t_parse_count ( @
	Marpa_Tree @var{t})
The parse counter counts the number of parses
traversed so far.
The count includes the current iteration of the
tree, so that a value of 0 indicates a tree
which is not yet initialized.

Return value: The number of parses traversed so far.
Always succeeds.
@end deftypefun

@node Value, Events, Tree, Top
@chapter Value objects

@menu
* About the valuator::          
* Valuator constructor::        
* Valuator reference counting::  
* Valuator stepping::           
* Step accessors::              
@end menu

@node About the valuator, Valuator constructor, Value, Value
@section About the valuator
While Libmarpa passes instructions
(called ``steps'')
for stack manipulation,
it does not actually maintain a stack.
This leaves the upper layer in total control of the
stack and the values which are placed on it.

As example may make this clearer.
Suppose the evalution is at a place in the parse tree
where an addition is being performed.
Libmarpa does not know that the operation
is an addition.
It will tell the application that rule number @math{R}
is to be applied to the arguments at stack locations
@math{N} and @math{N+1}, and that the result is to placed in
stack location @math{N}.

In this system
the application keeps track of the semantics for all
rules, so it looks up rule @math{R} and determines that it
is an addition.
The application can do this by using @math{R} as an index
into an array of callbacks, or by any other method
it chooses.
Let's assume a callback implements the semantics
for rule @math{R}.
Libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations @math{N} and @math{N+1} in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let's say, 753.
Libmarpa has told the application that the result
belongs at location @math{N} in the stack,
so the application writes 753 to location @math{N}.

Since Libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers, or polymorphic objects which are
capable of being any of these things and more.

This technique
hides Libmarpa's grammar rewrites from the application,
and is actually quite efficient.
Libmarpa knows which rules are sequences
and optimizes stack manipulations based on this knowledge.
Many practical grammars use long sequences heavily
and, for these,
the series of steps
suggest by Libmarpa will be significantly faster than the standard
stack evaluation algorithm in the textbooks.

To make it clear,
we are under no illusion that direct use of Libmarpa's evaluator will be found
satisfactory even to most application programmers.
I certainly avoid using it directly.
It is intended to be used via an upper layer,
one which does know about semantics.

To see the advantage
of isolating Libmarpa from semantics,
suppose
that Libmarpa is used as the basis
for a higher-level language which needs callbacks in that higher level language.
For generality, Libmarpa would have to deal in C callback,
which wrapper the callbacks in the higher level language.
This is complex to code and inefficient,
but that is not its worst aspect.
The worst aspect happens when there is a programming error.
This error will occur inside Libmarpa,
and inside code about which Libmarpa can make no assumptions.

@node Valuator constructor, Valuator reference counting, About the valuator, Value
@section Creating a new valuator

@deftypefun Marpa_Value marpa_v_new ( @
    Marpa_Tree @var{t} @
)
Creates a new valuator from the tree @var{t},
and ``Pauses'' the tree,
so that the tree cannot move on to a new iteration
until the valuator is destroyed.
Many valuators of the same tree
can exist at once.
A tree is ``unpaused'' when
all of its valuators are destroyed.

Return value:  On success, the newly created valuator.
On failure, returns @code{NULL} and sets the error code.
@end deftypefun

@deftypefun Marpa_Grammar marpa_v_g ( @
    Marpa_Value @var{v} @
    )
Return value: The base grammar of @var{v}.
Always succeeds.
@end deftypefun

@deftypefun Marpa_Value marpa_v_ref (Marpa_Value @var{v})
Increases the reference count.

Return value:
On success, @var{v}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_v_unref ( @
    Marpa_Value @var{v})
Decreases the reference count by 1,
destroying @var{v} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

@end deftypefun

@deftypefun int marpa_v_symbol_is_ask_me_when_null ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid} )
@deftypefunx int marpa_v_symbol_ask_me_when_null_set ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid}, @
    int @var{value} )
These methods, respectively, report and set to @var{value}
the ``ask me
when null'' flag for symbol @var{symid}.
When this flag is 1,
the valuator asks the application
to supply a value for a null symbol.
When this flag is 0 (its default value),
the behavior is for a null symbol to have a
``whatever'' value.
Any setting in the valuator overrides the one chosen
in the grammar.

@var{value} should be 1 or 0.
If @var{symid} is non-nullable,
an attempt to set its @var{value} to 1 is
a hard error.

Return value:  On success, the value of the flag after the
call.
On failure, -2.
@end deftypefun

@node Valuator reference counting, Valuator stepping, Valuator constructor, Value
@section Reference counting

@node Valuator stepping, Step accessors, Valuator reference counting, Value
@section Stepping through the valuator

@deftypefun Marpa_Step_Type marpa_v_step ( @
    Marpa_Value @var{v})
This method ``steps through'' the valuator.
The return value is a @code{Marpa_Step_Type},
a integer which indicates the type of step.
How the application is expected to act on
each step is described below.

Return value:  On success, the type of the step
to be performed.
On soft failure, @code{MARPA_STEP_INACTIVE}.
On other failure, -2.
@end deftypefun

@deftypevr Macro Marpa_Step_Type MARPA_STEP_RULE
The semantics of a rule should be performed.
The application can find the value of the rule's
children in the stack locations from
@code{marpa_v_arg_0(v)}
to @code{marpa_v_arg_n(v)}.
The semantics for the rule whose ID is
@code{marpa_v_rule(v)} should be executed
on these child values,
and the result placed in
@code{marpa_v_result(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_TOKEN
The semantics of a non-null token should be performed.
The value of the token whose ID is
@code{marpa_v_token(v)} should be
placed in
stack location @code{marpa_v_result(v)}.
The token is non-nulling.
Its value
will not be the ``whatever''
value and will be in
@code{marpa_v_token_value(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_NULLING_SYMBOL
The semantics for a nulling symbol should be performed.
The ID of the symbol is
@code{marpa_v_symbol(v)} and its value should
be placed in
stack location @code{marpa_v_result(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_INACTIVE
The valuator has gone through all of its steps
and is now inactive.
The value of the parse will be in stack location 0.

Because of ``whatever'' semantics and nulling
parses, it is quite possible for valuator to immediately
became inactive -- @code{MARPA_STEP_INACTIVE} could
be the first and last step.
For similar reasons, the application
may need, on its own initiative,
to initialize the stack
to ensure there is a stack with a location 0 --
there will not necessarily be a valuator step that
prompts to do so.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_INTERNAL1
@deftypevrx Macro Marpa_Step_Type MARPA_STEP_INTERNAL2
@deftypevrx Macro Marpa_Step_Type MARPA_STEP_TRACE
These step types are reserved for internal purposes.
@end deftypevr

@node Step accessors,  , Valuator stepping, Value
@section Step accessors

Step accessors are implemented as macros.  They always succeed.

@deftypefn {Macro} Marpa_Symbol_ID marpa_v_token (Marpa_Value @var{v})
Return value: Returns the ID of the token
for the @code{MARPA_STEP_TOKEN} step.
@end deftypefn

@deftypefn {Macro} Marpa_Symbol_ID marpa_v_symbol (Marpa_Value @var{v})
Return value: Returns the ID of the symbol
for the @code{MARPA_STEP_NULLING_SYMBOL} step.
The value is always the same as that for the @code{marpa_v_token}
macro.
@end deftypefn

@deftypefn {Macro} void* marpa_v_token_value (Marpa_Value @var{v})
Return value: Returns the integer which is (or represents)
the value of the token for the
@code{MARPA_STEP_TOKEN} step.
@end deftypefn

@deftypefn {Macro} Marpa_Rule_ID marpa_v_rule (Marpa_Value @var{v})
Return value: Returns the ID of the rule
token for the
@code{MARPA_STEP_RULE} step.
@end deftypefn

@deftypefn {Macro} int marpa_v_result (Marpa_Value @var{v})
Return the stack location where the result of the semantics
should be placed.
@end deftypefn

@deftypefn {Macro} int marpa_v_arg_0 (Marpa_Value @var{v})
For a @code{MARPA_STEP_RULE} step,
returns the stack location where the value of first child
can be found.
The value is always the same as that for the @code{marpa_v_result}
macro.
@end deftypefn

@deftypefn {Macro} int marpa_v_arg_n (Marpa_Value @var{v})
For a @code{MARPA_STEP_RULE} step,
returns the stack location where the value of the last child
can be found.
@end deftypefn

@node Events, Error macros and code, Value, Top
@chapter Events

@menu
* Event codes::                 Event codes.
@end menu

@node Event codes,  , Events, Events
@section Event codes

@deftypevr Macro int MARPA_EVENT_NONE
Applications should never see this event.
Suggested message: "No event."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EXHAUSTED
The event value is undefined.
Suggested message: "Recognizer is exhausted."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EARLEY_ITEM_THRESHOLD
The event value is undefined.
Suggested message: "Too many Earley items."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_LOOP_RULES
A rule is part of a cycle.
Cycles are pathological cases of recursion,
in which the same symbol string derives itself
a potentially infinite number of times.
Nonetheless, Marpa parses in the presence of these,
and it is up to the application to treat these
as fatal errors,
something most of them will wish to do.
The value of the event is the count of loop rules.
Suggested message: "A rule is part of a infinite loop."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_COUNTED_NULLABLE
A nullable is either the separator
for, or the right hand side of a sequence.
The value of the event is the ID of the symbol.
Suggested message: "Grammar has a counted nullable."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NULLING_TERMINAL
A nulling symbol is also a terminal.
The value of the event is the ID of the symbol.
Suggested message: "Grammar has a nulling terminal."
@end deftypevr

@node Error macros and code, Design considerations, Events, Top
@chapter Error macros and code

@menu
* Methods::                     
* Error Macros::                
* Error Codes::                 
@end menu

@node Methods, Error Macros, Error macros and code, Error macros and code
@section Methods

@deftypefun Marpa_Error_Code marpa_g_error @
    ( Marpa_Grammar @var{g}, @
    const char** @var{p_error_string})
When a method fails,
this method allows the application to read
the error code.
@var{p_error_string} is reserved for use by
the internals.
Applications should set it to @code{NULL}.

Return value: The last error code from a Libmarpa method.
Always succeeds.
@end deftypefun

@deftypefun Marpa_Error_Code marpa_r_error @
    (Marpa_Recognizer @var{r}, @
    const char** @var{p_error_string})
All errors are tracked in the grammar object.
This method is a convenience wrapper for @code{marpa_g_error}.
@var{p_error_string} is reserved for use by
the internals.
Applications should set it to @code{NULL}.

Return value: The last error code from a Libmarpa method.
Always succeeds.
@end deftypefun

@node Error Macros, Error Codes, Methods, Error macros and code
@section Error Macros

@deftypevr Macro int MARPA_ERRCODE_COUNT
The number of error codes.
@end deftypevr

@node Error Codes,  , Error Macros, Error macros and code
@section Error Codes

@deftypevr Macro int MARPA_ERR_NONE
No error condition since the last time the
error code was reset or,
if there was no reset,
since grammar initialization.
Suggested message: "No error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_AHFA_IX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_AHFA_IX_OOB
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NOT_IN_OR
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDIX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_BAD_SEPARATOR
@end deftypevr
@deftypevr Macro int MARPA_ERR_BOCAGE_ITERATION_EXHAUSTED
@end deftypevr

@deftypevr Macro int MARPA_ERR_COUNTED_NULLABLE
A "counted" symbol is also a nullable symbol.
A "counted" symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting occurrences of it,
which is what sequence rules do for their RHS
symbols,
becomes very difficult.
All sorts of questions of definition and
problems of implementation arise.
At a minimum, such a sequence would be wildly
ambigious.

Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in Libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
Suggested message: "Nullable symbol on RHS of a sequence rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DEVELOPMENT
The "development" errors is for use during
Libmarpa's development,
while it is not yet clear how precisely
to classify every error condition.
The error string is a
short 7-bit ASCII error string
which describes the error.
Classifying an error as "development"
is a temporary measure,
taken until the error can be more
precisely defined and classed.
Suggested message: "Development error, see string."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_AND_NODE
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_RULE
This error indicates an attempt to add a rule which
is a duplicate of a rule already in the grammar.
Two rules are considered duplicates if

@itemize @bullet
@item
Both rules have the same left hand symbol.
@item
Both rules have the same right hand symbols in the same order.
@end itemize

This definition applies to sequence rules, as well as to ordinary rules. As a consequence, sequence rules can be considered duplicates even when they have different separators and/or different minimum counts.
Suggested message: "Duplicate rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_COUNT
Libmarpa allows a maximum number of earley
items per Earley set.
This error code indicates that limit was
exceeded.
Note that this limit is different from
the optional earley item
warning threshold, which can be set
by the application.
Exceeding the warning threshold causes
a Libmarpa event, which the application
is free to treat as a hard or soft error.
Suggested message: "Maximum number of earley items exceeded."

Most likely, memory will run out for
other reasons long before this error can
occur.
The maximum earley item count for the
purposes of this error code
is over a billion.
As a contrast, a reasonable setting for the
warning threshold,
even when exceeding the threshold is
treated as a fatal error,
will usually be well under 1000.
If this error code ever does occur,
it is almost certainly both a hard and a
fatal error.
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_ID_INVALID
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL
Internal errors are errors which
"should not happen".
They could result when the calling program
overwrites Libmarpa's internal data.
They may also indicate a bug in Libmarpa.
An internal error will usually be a hard error.
Suggested message: "Internal error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL_SYM
In a context
in which an internal symbol is disallowed,
@var{symid} is for an internal symbol.
Suggested message: "Symbol is internal."
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_AHFA_ID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_AIMID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_BOOLEAN
A function was called which takes a boolean argument,
one which must be either 0 or 1,
and that argument has some other value.
Suggested message: "Argument is not boolean."
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_ES_ORDINAL
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_IRLID
A method was called with an invalid internal rule ID.
Suggested message: "No IRL with that ID exists."
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_ISYID
A method was called with an invalid internal symbol ID.
Suggested message: "No ISY with that ID exists."
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_START_SYM
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_SYMID
After development, this error code should no longer
be used and should be deleted.
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_XRLID
A method was called with an invalid external rule ID.
Suggested message: "No rule with that ID exists."
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_XSYID
A method was called with an invalid external symbol ID.
Suggested message: "No symbol with that ID exists."
@end deftypevr

@deftypevr Macro int MARPA_ERR_MAJOR_VERSION_MISMATCH
There was a mismatch in the major version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr
@deftypevr Macro int MARPA_ERR_MICRO_VERSION_MISMATCH
There was a mismatch in the micro version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr
@deftypevr Macro int MARPA_ERR_MINOR_VERSION_MISMATCH
There was a mismatch in the minor version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr

@deftypevr Macro int MARPA_ERR_NOOKID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_PRECOMPUTED
@end deftypevr

@deftypevr Macro int MARPA_ERR_NOT_TRACING_COMPLETION_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_LEO_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_TOKEN_LINKS
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_ALIAS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_AND_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_OR_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_PARSE
The application attempted to create a bocage
from a recognizer without a parse.
The application will often treat this as
a soft error.
Suggested message: "No parse."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_RULES
A grammar which has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
The precomputations are not defined
for grammar without rules,
in large part because it would be useless to do so.
Suggested message: "This grammar does not have any rules."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_START_SYM
The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one.
For example, no grammar without a start
symbol can be precomputed.
Suggested message: "This grammar has no start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_TRACE_ES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_PIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_EIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_SRCL
@end deftypevr

@deftypevr Macro int MARPA_ERR_NULLING_TERMINAL
Marpa does not allow a symbol to be both nulling
and a terminal.
Suggested message: "A symbol is both terminal and nulling."
@end deftypevr

@deftypevr Macro int MARPA_ERR_ORID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_OR_ALREADY_ORDERED
@end deftypevr
@deftypevr Macro int MARPA_ERR_ORDER_FROZEN
The Marpa order object has been frozen.
Multiple trees can share a Marpa order object,
but that order object is @dfn{frozen} after the first tree
is created from it.
If a Marpa order object is @dfn{frozen}, it cannot be
changed.
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.
@end deftypevr

@deftypevr Macro int MARPA_ERR_PARSE_EXHAUSTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_PARSE_TOO_LONG
@end deftypevr
@deftypevr Macro int MARPA_ERR_PIM_IS_NOT_LIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_PRECOMPUTED
An attempt was made to use a precomputed grammar
in a way that is not allowed.
After a grammar is precomputed,
any changes to it that would invalidate
the precomputation
is not allowed.
Almost all changes to a grammar invalidate
the precomputations.
Suggested message: "This grammar is precomputed."
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_NOT_ACCEPTING_INPUT
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_NOT_STARTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_STARTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_RHS_TOO_LONG
@end deftypevr

@deftypevr Macro int MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE
The LHS of a
sequence rule cannot be the LHS of any other rule,
whether a sequence rule or a BNF rule.
An attempt was made to violate this restriction.
Suggested message: "LHS of sequence rule would not be unique."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_NONE
The link source type is 'none'
in a context where that is not allowed.
Suggested message: "A source type of 'none' is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_TOKEN
The link source type is 'token'
in a context where that is not allowed.
Suggested message: "Token source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_COMPLETION
The link source type is 'completion'
in a context where that is not allowed.
Suggested message: "Completion source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_LEO
The link source type is 'Leo'
in a context where that is not allowed.
Suggested message: "Leo source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_AMBIGUOUS
The link source type is ambiguous
in a context where that is not allowed.
Suggested message: "Ambiguous source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_UNKNOWN
The link source type is not known.
Suggested message: "The source type is unknown."
@end deftypevr

@deftypevr Macro int MARPA_ERR_START_NOT_LHS
The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Start symbol not on LHS of any rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SYMIX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_SYMIX_OOB
@end deftypevr

@deftypevr Macro int MARPA_ERR_SYM_NOT_NULLABLE
In circumstances where a symbol is required to be a nullable
symbol,
it is not.
One such circumstance when the symbol is the
argument of a
@code{marpa_v_symbol_ask_me_when_null_set}
call.
Suggested message: "Symbol not nullable."
@end deftypevr

@deftypevr Macro int MARPA_ERR_TOKEN_IS_NOT_TERMINAL
@end deftypevr
@deftypevr Macro int MARPA_ERR_TOKEN_LENGTH_LE_ZERO
@end deftypevr
@deftypevr Macro int MARPA_ERR_TOKEN_TOO_LONG
@end deftypevr
@deftypevr Macro int MARPA_ERR_TREE_EXHAUSTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_TREE_PAUSED
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNKNOWN
The cause of the error could not be determined.
This usually indicates a problem in the error handling
logic itself.
This will usually be a hard error.
Suggested message: "Unknown error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNPRODUCTIVE_START
The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Unproductive start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_VALUATOR_INACTIVE
The valuator is inactive in a context where that
should not be the case.
Suggested message: "Valuator inactive."
@end deftypevr

@node Design considerations, Things To Do, Error macros and code, Top
@chapter Design considerations

This section details some of the design choices
in Libmarpa.

@menu
* Why so many time objects::    
* Design of numbered objects::  
@end menu

@node Why so many time objects, Design of numbered objects, Design considerations, Design considerations
@section Why so many time objects?

Readers accustomed to other appraoches to parsing,
particular those in fashion at this writing,
may wonder on the number of time objects
in the Marpa architecture.
Several of Marpa's time objects (bocages,
orderings and trees) are required
because Marpa allows,
and offers powerful tools for dealing with,
ambigious grammars.

It may seem, then, that users of unambiguous grammars,
are paying a considerable price in time effiency
for the ability to parse
ambiguous ones.
This is not the case.
In the trivial case, the cost of the orderings
object is a single, very brief, subroutine call.

Bocage objects come at minimal cost,
because the same pass which creates the bocage
also deals with other issues which are of major
significance even for unambiguous parses.
The same pass which creates the bocage
enables Marpa to do both left-
and right-recursion in linear time.

Tree objects come at mininal cost to unambiguous grammars,
because the same pass that allows iteration through multiple
parse trees does the tree traversal, so that the valuation time object
has very litle to do -- it just steps through the sequence.

But what about the many passes over the data this requires?
Marpa is an aggressively multi-pass algorithm.
Marpa achieves its efficiency,
not in spite of making multiple
passes over the data, but because of it.
Marpa is @math{O(n)} for LR-regular grammars,
both in theory and in implementation,
because Marpa regularly substitutes
two fast @math{O(n)} passes for a single
@math{O(n log n)} pass.

@node Design of numbered objects,  , Why so many time objects, Design considerations
@section Numbered objects

As the name suggests,
the choice was made to implement
numbered objects and not as
pointers.
Integers can be easily and safely checked for validity,
while pointer cannot.

There are efficiency tradeoffs between pointers and
integers but they are complications and go both ways.
Pointers can be faster, but integers can be used
as indexes into more than one data structure.
Which is actually faster depends on the design.
Integers allow for a more flexible design,
so that once the choice is settled on,
careful programming can make them a win,
possibly a very big one.

The approach taken in Libmarpa was to settle
from the outset,
on integers as the implementation for numbered
objects and optimize on that basis.
In any case, the difference is speed on
modern architectures is
a small price to pay for
safe, portable validity checking.

@node Things To Do, Internal Interface, Design considerations, Top
@chapter Things to do

@itemize
@item
There should be an interface in the valuator that allows the user to
determine the start and end earlemes of a token.
@end itemize

@node Internal Interface,  , Things To Do, Top
@chapter Internal Interface

@menu
* Symbol internal methods::     
* Rule internals::              
* Grammar internals::           
* Recognizer internals::        
* Bocage internals::            
* Ordering internals::          
* Tree internals::              
* Valuator internals::          
@end menu

@node Symbol internal methods, Rule internals, Internal Interface, Internal Interface
@section Symbol internal methods

Internal methods are only for testing and development of libmarpa.
They are listed here (and sometimes described) for the convenience
of those working on libmarpa's internals.

Internal methods are subject to change.
Applications should not use internal methods.
Where a description exists and may be helpful,
it may be included below,
but all applications
should treat these methods as ``undocumented''.

@deftypefun int _marpa_g_isy_is_start ( Marpa_Grammar @var{g}, @
    Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_is_nulling ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_is_lhs ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun Marpa_ISY_ID _marpa_g_xsy_nulling_isy ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_ISY_ID _marpa_g_xsy_isy ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_symbol_proper_alias ( @
  Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_symbol_null_alias ( @
  Marpa_Grammar @var{g}, @
  Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun int _marpa_g_symbol_is_semantic ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_source_xsy ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_isy_lhs_xrl ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_xrl_offset ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id} )
@end deftypefun

@node Rule internals, Grammar internals, Symbol internal methods, Internal Interface
@section Rule internals

@deftypefun int marpa_g_rule_is_keep_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
This function does nothing but return an undocumented flag.
At some point,
I may optimize cases where separators are discarded,
in which case this flag will be used.
I may also remove this call entirely.
Return value:
Returns 1 if
the keep separation flag is set,
0 if not.
Returns 0 if
@var{rule_id} is not a sequence rule.
On hard failure, returns -2.
@end deftypefun

@deftypefun int _marpa_g_isy_count ( @
  Marpa_Grammar @var{g})
@end deftypefun
@deftypefun int _marpa_g_irl_count ( @
  Marpa_Grammar @var{g})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
Return value: On success, the LHS symbol of the IRL.
On failure, -2.
@end deftypefun

@deftypefun int _marpa_g_irl_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
The length of a IRL is the number of symbols on its RHS.

Return value: On success, the IRL length.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id}, @
    int @var{ix})
The position in the IRL, @var{ix}, is zero-based.
If @var{ix} is greater than or equal the length of the
IRL, it is a soft failure.
This can be used in loops, to avoid having to determine
the IRL's length explicitly.

Return value: On success, the symbol in position @var{ix}
on the IRL's RHS.
If @var{ix} is greater than or equal to the length of
the IRL, -1.
On other failures, -2.
@end deftypefun
@deftypefun int _marpa_g_rule_is_used (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_lhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_rhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun @code{unsigned int} _marpa_g_virtual_start (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun @code{unsigned int} _marpa_g_virtual_end (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_source_xrl (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_real_symbol_count (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_irl_semantic_equivalent (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun

@node Grammar internals, Recognizer internals, Rule internals, Internal Interface
@section Grammar internal methods

The methods in this section are accessors for Libmarpa's
AHFA items and states.
Their use requires familiarity with
Marpa's internals, as described in
@cite{Marpa: The Program}.

@deftypefun int _marpa_g_AHFA_item_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_AHFA_item_irl (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_position (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_item_postdot (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_sort_key (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_item_count (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_AHFA_Item_ID _marpa_g_AHFA_state_item (Marpa_Grammar @var{g}, @
     Marpa_AHFA_State_ID @var{AHFA_state_id}, @
 int @var{item_ix})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_is_predict (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_state_leo_lhs_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_transitions ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id}, @
    int *@var{buffer}, @
    int @var{buffer_size} @
    )
@end deftypefun
@deftypefun Marpa_AHFA_State_ID _marpa_g_AHFA_state_empty_transition ( @
    Marpa_Grammar @var{g}, @
     Marpa_AHFA_Item_ID @var{AHFA_item_id})
@end deftypefun

@node Recognizer internals, Bocage internals, Grammar internals, Internal Interface
@section Recognizer internals


@deftypefun int _marpa_r_is_use_leo (Marpa_Recognizer @var{r})
@deftypefunx int _marpa_r_is_use_leo_set ( Marpa_Recognizer @var{r}, @
    int @var{value})
Reports and sets, respectively, the ``use Leo'' flag.
This flag controls whether Joop Leo's method for fast parsing
of right recursion is used.
By default, this value is 1 and Leo parsing is in use.
This default should be used except for testing, debugging
and development.
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_trace_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_latest_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int _marpa_r_earley_set_size (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_Earleme _marpa_r_earley_set_trace (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_earley_item_trace (Marpa_Recognizer r, Marpa_Earley_Item_ID @var{item_id})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_earley_item_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_leo_predecessor_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_leo_base_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_leo_base_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_leo_expansion_ahfa (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_postdot_symbol_trace (Marpa_Recognizer r, Marpa_Symbol_ID @var{symid})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_postdot_item_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_source_predecessor_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_source_token (Marpa_Recognizer r, int *@var{value_p})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_source_leo_transition_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_source_middle (Marpa_Recognizer @var{r})
@end deftypefun

@node Bocage internals, Ordering internals, Recognizer internals, Internal Interface
@section Bocage internals

@deftypefun int _marpa_b_and_node_count ( @
    Marpa_Bocage @var{b})
@end deftypefun
@deftypefun int _marpa_b_and_node_parent ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_predecessor ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_cause ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_symbol ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_b_and_node_token ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id}, @
    int* @var{value_p})

Returns the data for the token of the and-node.
The symbol id is the return value,
and the token value is placed
in the location pointed
to by @var{value_p}, if that is non-null.
If @var{and_node_id} is not the ID of an and-node
whose cause is a token,
returns -1,
without changing @var{value_p}.
On hard failure, returns -2 without changing
@var{value_p}.

There is no function to simply return the token value --
because of the need to indicate errors, it is just as
easy to return the symbol ID as well.
@end deftypefun
@deftypefun Marpa_Or_Node_ID _marpa_b_top_or_node ( @
    Marpa_Bocage @var{b})

Return the ID of the top or-node.
@end deftypefun
@deftypefun int _marpa_b_or_node_set ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})

Return the ordinal of the current (final) Earley set of
the or-node.
@end deftypefun
@deftypefun int _marpa_b_or_node_origin ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun Marpa_IRL_ID _marpa_b_or_node_irl ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_position ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_first_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_last_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_and_count ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@node Ordering internals, Tree internals, Bocage internals, Internal Interface
@section Ordering internals

@deftypefun int _marpa_o_and_order_set ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    Marpa_And_Node_ID* @var{and_node_ids}, @
    int @var{length})
@end deftypefun

@deftypefun Marpa_And_Node_ID _marpa_o_and_order_get ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    int @var{ix})
@end deftypefun

@node Tree internals, Valuator internals, Ordering internals, Internal Interface
@section Tree internals

In Marpa, a nook is any node of a parse tree.
The usual term is "node",
but within Marpa,
the word "node" is already heavily overloaded.
So what most texts call "tree nodes" are here
called "nooks".
"Nook" can be thought of as a pun on both
"node" and "fork".

@deftypefun int _marpa_t_size ( @
	Marpa_Tree @var{t})
Return the size of the parse tree.
This is the number of nooks in its stack.
If there is a serioius error,
or if the tree is uninitialized, return -2.
If the tree is exhausted, return -1.
@end deftypefun

@deftypefun Marpa_Or_Node_ID _marpa_t_nook_or_node ( @
    Marpa_Tree @var{t}, @
    Marpa_Nook_ID @var{nook_id})

Return the ID of the or-node for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_choice ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the current choice for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_parent ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the parent nook's ID for @var{nook_id}.
As with the other nook trace functions,
-1 is returned if @var{nook_id} is not the ID of
a nook on the stack,
but -1 can also be a valid value.
If that's an issue, the @var{nook_id} needs
to be checked with one of the trace functions
where -1 is never a valid value ---
for example, @code{_marpa_t_nook_or_node}.
@end deftypefun

@deftypefun int _marpa_t_nook_cause_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the cause-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_predecessor_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the predecessor-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_cause ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-cause bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_predecessor ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-predecessor bit for @var{nook_id}.
@end deftypefun

@node Valuator internals,  , Tree internals, Internal Interface
@section Valuator internals

@deftypefun int _marpa_v_trace ( @
    Marpa_Value @var{v}, @
    int @var{flag})
@end deftypefun

@deftypefun Marpa_Nook_ID _marpa_v_nook ( @
    Marpa_Value @var{v})
@end deftypefun

@bye
