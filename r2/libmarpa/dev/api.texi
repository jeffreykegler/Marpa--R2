\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename api.info
@settitle Libmarpa @value{VERSION}
@c %**end of header
@include version.texi
@copying
This manual is for Libmarpa @value{VERSION}.
Copyright @copyright{} 2012 Jeffrey Kegler.
@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation;
@end quotation
@end copying
@finalout
@titlepage
@title Libmarpa
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Jeffrey Kegler
@c The following two commands
@c start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying

Published @value{UPDATED} by Jeffrey Kegler
@end titlepage
@c So the toc is printed at the start.
@contents
@ifnottex
@node Top, About this document, (dir), (dir)
@top Libmarpa: The Marpa low-level library

This manual is for Libmarpa, version @value{VERSION}.

@end ifnottex
@menu
* About this document::         
* About Libmarpa::              What is Libmarpa?
* Architecture::                
* Input::                       
* Semantics::                   
* Threads::                     
* Error handling concepts::     
* Introduction to the external interface::  
* Static method::               
* Configuration methods::       
* Grammar methods::             
* Recognizer methods::          
* Progress reports::            
* Bocage methods::              
* Ordering methods::            
* Tree methods::                
* Value methods::               
* Events::                      Libmarpa Events
* Error macros and code::       
* Design considerations::       
* Things To Do::                
* Internal Interface::          

@detailmenu
 --- The Detailed Node Listing ---

About this document

* How to read this document::   
* Prerequisites::               Prerequisites.
* Parsing theory::              Parsing theory.

Architecture

* Time objects::                
* The lifetime of time objects::  
* Parent and child time objects::  
* Numbered objects::            

Input

* Earlemes::                    
* Terminals::                   
* LHS Terminals::               
* Token values::                

Earlemes

* The traditional model::       
* The earleme variables::       
* The significances of the earleme variables::  
* The initial earleme settings::  
* The standard model of input::  
* Ambiguous input::             
* Variable length tokens::      
* The generalized model::       
* General rules for the earleme variables::  

Terminals

* LHS Terminals::               
* Token values::                

Semantics

* How Libmarpa semantics work::  
* Universe of values::          
* Valued and unvalued symbols::  

Error handling

* Memory allocation failures::  

Introduction to the external interface

* About the overviews::         
* Return values::               
* Naming conventions::          

Grammar methods

* Grammar overview::            
* Grammar constructor::         
* Grammar reference counting::  
* Symbols::                     
* Rules::                       
* Sequences::                   
* Grammar precomputation::      
* Grammar events::              

Recognizer methods

* Recognizer overview::         
* Recognizer constructor::
* Recognizer reference counting::
* Recognizer life cycle mutators::  
* Location accessors::          
* Other parse status methods::  

Bocage methods

* Bocage overview::             
* Bocage reference counting::   

Ordering methods

* Ordering overview::           
* Ordering constructor::        
* Ordering reference counting::  

Tree methods

* Tree overview::               
* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              

Value methods

* Value overview::              
* How to use the valuator::     
* Advantages of Libmarpa's valuator::  
* Details of stack manipulation::  
* Valuator constructor::        
* Valuator reference counting::  
* Registering semantics::       
* Stepping through the valuator::  
* Valuator steps by type::      
* Step accessors::              

Details of stack manipulation

* Implications for literal stack manipulation::  
* Implications for non-literal implementations::  

Events

* Event codes::                 Event codes.

Error macros and code

* Methods::                     
* Error Macros::                
* External error codes::        
* Internal error codes::        

Design considerations

* Why so many time objects::    
* Design of numbered objects::  

Why so many time objects?

* Why ordering objects?::       

Internal Interface

* Symbol internal methods::     
* Rule internals::              
* Grammar internals::           
* Recognizer internals::        
* Bocage internals::            
* Ordering internals::          
* Tree internals::              
* Valuator internals::          

@end detailmenu
@end menu

@node About this document, About Libmarpa, Top, Top
@chapter About this document

@menu
* How to read this document::   
* Prerequisites::               Prerequisites.
* Parsing theory::              Parsing theory.
@end menu

@node How to read this document, Prerequisites, About this document, About this document
@section How to read this document

This is essentially a reference document,
but its early chapters lay out concepts
essential to the others.
Readers will usually want to read the
chapters up and including
@ref{Introduction to the external interface}
in order.
Otherwise, they may follow their interests.

@node Prerequisites, Parsing theory, How to read this document, About this document
@section Prerequisites

This document is very far from self-contained.
It assumes the following:
@itemize
@item
The reader knows the C programming language
at least well
enough to understand function prototypes.
@item
The reader
has read the documents for one of Libmarpa's upper layers.
@item
The reader knows some parsing theory.
@xref{Parsing theory}.
@end itemize

@node Parsing theory,  , Prerequisites, About this document
@section Parsing theory

This document assumes an acquaintance
with parsing theory.
As a test of whether he needs to refresh
his knowledge before tackling
this document,
I hope the reader will find it helpful to
ask himself the
following list of questions.
@itemize @bullet
@item
What is a BNF rule?
@item
What is a Marpa sequence rule?
@item
As a reminder,
Marpa's sequence rules are implemented
as left recursions.
What does that mean?
@item
Take a Marpa sequence rule at random.
What does it look like when rewritten in BNF?
@item
What does the sequence look like when rewritten
in BNF as a right-recursion?
@end itemize
For a reader to be satisfied with the level of detail
in the following pages,
he probably should be able to answer all the questions
in the above list after a moment of thought.

On the encouraging side,
while BNF has been overshadowed
by regular expressions, and is now considered
an advanced skill,
BNF is in fact as easy (or easier) to learn
and manipulation than regular expressions.
If a reader has learned how to use
one of the packages that extend
regular expressions,
he should have no trouble with BNF.

@node About Libmarpa, Architecture, About this document, Top
@chapter About Libmarpa
Libmarpa implements the Marpa parsing algorithm.
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

Libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees.
It also supports the ordering, iteration
and evaluation of the parse
trees.

Libmarpa is very low-level.
For example, it has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for most applications.
A user will almost always want,
at a minimum,
names for the symbols and non-integer values for
tokens.
Typically, an application will use arrays to
translate Libmarpa's integer ID's to strings or other
values as required.

Libmarpa also does @strong{not} implement most of the semantics.
Libmarpa does have an evaluator (called a ``valuator''),
but it does @strong{not}
manipulate the stack directly.
Instead, Libmarpa,
based on its traversal of the parse tree,
passes optimized step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.

Marpa requires most semantics to be
implemented in the application.
This allows the application total flexibility.
It also puts
the application is in a much better position to prevent errors,
to catch errors at runtime or,
failing all else,
to successfully debug the logic.

@node Architecture, Input, About Libmarpa, Top
@chapter Architecture

@menu
* Time objects::                
* The lifetime of time objects::  
* Parent and child time objects::  
* Numbered objects::            
@end menu

@node Time objects, The lifetime of time objects, Architecture, Architecture
@section Time objects

Marpa divides parsing into phases,
which in this document are more often called ``times''.
The term ``time'' is more accurate,
beacuse the time objects are typically in use simultaneously.
The term ``phase'' suggest a time which is
exclusive and non-simultaneous
-- when one phase ends, another begins.
In our lives, work and play are times.
Infancy, adolescent and adulthood are phases.

Although times can be simulataneous,
they do have a sequence.
The times are, in sequence order:

@itemize
@item
Grammar:  At grammar time, the rules and symbols
are defined, with their properties.
A grammar must be precomputed before a recognizer can
be created from it.
@item
Recognizer: At recognizer time, input is read.
@item
Bocage: At bocage time, a data structure called a
bocage is created from the information captured
during recognition.
The bocage stores a collection of parse trees,
similar to a parse forest.
@item
Ordering: At ordering time, a order is defined
for the bocage.
@item
Tree: At tree time,
an iterator of the parse bocage
is created, and traversed.
@item
Value: At value time,
the current parse tree of a tree iterator
is traversed for its ``steps''.
``Steps'' are instructions that tell
the application how to maintain
a stack and to evaluate the
semantics.
@end itemize

The time objects classes have one letter abbreviations,
which are used frequently.
These are, in the standard sequence,

@itemize
@item
Grammar:  G
@item
Recognizer: R
@item
Bocage: B
@item
Ordering: O
@item
Tree: T
@item
Value: V
@end itemize

@node The lifetime of time objects, Parent and child time objects, Time objects, Architecture
@section The lifetime of time objects

One of reasons Libmarpa's major objects
are called ``time objects''
is that each of them has a distinct lifetime.
Time objects are reference counted.
Every time object is created with a reference count of 1.
Whenever one time object is created from another,
the parent time object has its reference count incremented
by 1.

Time objects do not have explicit destructors.
When the reference count of a time object reaches
0, that time object is destroyed.
When a child object is destroyed, it
decrements the reference count of its parent.
Also, each time class has a method that decrements 
the reference count of an object in that class by 1.

In ordinary circumstances, all an application has to
do is keep in mind that it ``owns'' the time objects
it has created,
and that it must call a method
to ``unreference'' that object when it is finished.

More complex applications may find it convenient
to have multiple parts, or even new objects,
that share ownership of a Libmarpa time object.
For such situations,
every class of time object has a method to increment
the reference count for objects in that class.

@node Parent and child time objects, Numbered objects, The lifetime of time objects, Architecture
@section Parent and child time objects

Except for grammars,
all time objects are created from another time
object.
Each time object is created from a time object
of the class before it in the sequence.
A recognizer cannot be created without a precomputed grammar;
a bocage cannot be created without a recognizer;
and so on.

When one time object is used to create a second
time object,
the first time object is the @dfn{parent object}
and the second time object is the @dfn{child object}.
For example, when a bocage is created from a
recognizer,
the recognizer is the parent object,
and the bocage is the child object.

Grammars have no parent object.
Every other time object has exactly one parent object.
Value objects have no child objects.
All other time objects can have any number of children,
from zero up to a number determined by memory or
some other machine-determined limit.

Every time object has a @dfn{base grammar}.
A grammar object is its own base grammar.
The base grammar of a recognizer is the grammar
that it was created with.
Similarly,
the base grammar of any other time object is the base
grammar of its parent object.
For example,
the base grammar of a bocage is the base
grammar of the recognizer that it was created
with.

@node Numbered objects,  , Parent and child time objects, Architecture
@section Numbered objects

In addition to its major, ``time'' objects, Libmarpa also has
numbered objects.
Numbered objects do not have lifetimes of their own.
Every numbered object belongs to a timed object,
and is destroyed with it.
Rules and symbols are numbered objects.
Tokens values are another class of numbered
objects.

@node Input, Semantics, Architecture, Top
@chapter Input

@menu
* Earlemes::                    
* Terminals::                   
* LHS Terminals::               
* Token values::                
@end menu

@node Earlemes, Terminals, Input, Input
@section Earlemes

@menu
* The traditional model::       
* The earleme variables::       
* The significances of the earleme variables::  
* The initial earleme settings::  
* The standard model of input::  
* Ambiguous input::             
* Variable length tokens::      
* The generalized model::       
* General rules for the earleme variables::  
@end menu

@node The traditional model, The earleme variables, Earlemes, Earlemes
@subsection The traditional model

In traditional Earley parsers, the concept of location is very simple.
Locations are numbered from 0 to @math{n}, where @math{n} is the length of
the input.
Every location has an Earley set, and vice versa.
Location 0 is the start location.
Every location after the start location has exactly one input token
associated with it.

Already some applications
do not fit this traditional input model -- 
natural language processing requires ambiguous tokens,
for example.
Libmarpa's allows a wide variety of alternative input models.

This document assumes that the reader knows the concepts
behind Libmarpa's
alternative input models, either from the documentation
of a higher level interface, such as
@code{Marpa::XS} or
@code{Marpa::R2},
or from Marpa's
@uref{https://github.com/downloads/jeffreykegler/Marpa-theory/recce.pdf, theory document}.

As a reminder,
in Libmarpa a location is called a @dfn{earleme}.
The number of an Earley set is the @dfn{ID of the Earley set},
or its @dfn{ordinal}.
In the traditional model, the ordinal of an Earley set and
its earleme are always exactly the same, but in Libmarpa
they will be different.

@node The earleme variables, The significances of the earleme variables, The traditional model, Earlemes
@subsection The earleme variables

The important earleme variables are the current, the furthest and
the latest earleme.
The @dfn{current earleme} is the earleme that Libmarpa is currently working on.
More specifically, it is the one at which new tokens will @strong{start}.
Since tokens are never zero length, a new token will always end after the
current earleme.
The current earleme is initially earleme 0.
Every call to @code{marpa_r_earleme_complete()} advances the
current earleme by 1.

The @dfn{furthest earleme} is the highest numbered (and therefore ``furthest'')
earleme at which a token ends.
The furthest earleme is initially earleme 0.
With every call to @code{marpa_r_alternative()}, the end of the token
it adds is calculated.
A token ends at earleme @var{end_earleme} = @var{current}+@var{length},
where @var{current} is the current earleme,
and @var{length} is the length of the newly added token.
After a call to @code{marpa_r_alternative()},
the furthest earleme is its value before the call,
or @var{end_earleme}, whichever is greater.

The @dfn{latest earleme} is the earleme of the latest
Earley set.
The @dfn{latest Earley set} is the last Earley set completed.
This is always the highest numbered Earley set.
If there is an Earley set at the current earleme,
it is the latest Earley set and the latest earleme
is equal to the current earleme.
There is never an Earley set after the current earleme.
If there is no Earley set at the current earleme,
the latest Earley set,
which is also the highest numbered Earley set,
is the last one completed.

After every call to the @code{marpa_r_earleme_complete()} method
that adds a token,
the value of the latest earleme is 
same as the value of the current earleme.
After every call to the @code{marpa_r_earleme_complete()} method
that does @strong{not} add a token,
the value of the lastest earleme is unchanged
from its value before the call.

@node The significances of the earleme variables, The initial earleme settings, The earleme variables, Earlemes
@subsection The significances of the earleme variables

The current earleme tracks the advance of the recognizer through the input.
Input tokens always start at the current earleme.
An application can advance past the current earleme,
by calling @code{marpa_r_earleme_complete()}, which
increments the current earleme by 1.
After initialization,
@code{marpa_r_earleme_complete()} is
the only way to manipulate the value of the current earleme.

The furthest earleme tracks how ``far out'' tokens can be found.
In the standard input model, calling 
@code{marpa_r_earleme_complete()} after each
@code{marpa_r_alternative()} call is sufficient to process
all inputs,
and the furthest earleme's value
can be typically be ignored.
In alternative input models, if tokens have lengths greater than
1, calling
@code{marpa_r_earleme_complete()} once after the last token
is read may not be enough to ensure that all tokens have been processed.
To ensure that all tokens have been processed,
an application must advance the current earleme
by calling @code{marpa_r_earleme_complete()},
until the current earleme is equal to the furthest earleme.

The lastest earleme is the earleme of the last Earley set.
The latest earleme is different from the current earleme if and only if
there is no Earley set at the current earleme.
Once recognition is complete, parsing must take place over
a range of Earley sets.
A different end of parsing can be specified,
but by default, parsing is of the input
from earleme 0 to the latest earleme.

@node The initial earleme settings, The standard model of input, The significances of the earleme variables, Earlemes
@subsection The initial earleme settings

Understanding the
settings of current, latest and furthest earleme is
crucial to working with advanced input models,
and for this reason the next sections will go
through the possibilities carefully.
The presentation will start with the most traditional
and restrictive models.
It will proceed to less restrictive models.

All input models have the same initial values.
Initially the current, latest and furthest earleme
are always earleme 0.

@node The standard model of input, Ambiguous input, The initial earleme settings, Earlemes
@subsection The standard model of input

In the standard model of input,
Calls to @code{marpa_r_alternative()}
and @code{marpa_r_earleme_complete()} are
made in pairs.
There is first exactly one call 
to @code{marpa_r_alternative()}
for a token with length 1.
Following it must be a call
to @code{marpa_r_earleme_complete()}.
For an input of length @var{n}, there will be
exactly @var{n} such paired calls.

In the standard model,
for each call to 
@code{marpa_r_alternative()}
if the current earleme before the call was @var{i},
then after the call
the latest earleme will also be @var{i},
and the furthest earleme will be @var{i}+1.
For each call to
@code{marpa_r_earleme_complete()},
if the current earleme before the call was @var{i},
then after the call
the latest earleme,
the furthest earleme,
and the current earleme
will all be @var{i}+1.

@node Ambiguous input, Variable length tokens, The standard model of input, Earlemes
@subsection Ambiguous input

As a first loosening of the standard model,
we no longer require calls to @code{marpa_r_alternative()}
to be paired with calls to
@code{marpa_r_earleme_complete()}.
Instead,
we allow multiple calls
to @code{marpa_r_alternative()}
before each call to
@code{marpa_r_earleme_complete()}.
We still require that there be at least one call
to @code{marpa_r_alternative()}
before each call to
@code{marpa_r_earleme_complete()},
and we still require that all tokens have 
a length of 1.
In this model, the behavior of the current,
latest and furthest earlemes are exactly
as described for the standard model.

@node Variable length tokens, The generalized model, Ambiguous input, Earlemes
@subsection Variable length tokens

Our next loosening of the restrictions is to allow
variable length tokens.
That is, instead of requiring that all tokens
be of length 1,
we allow tokens to be of length 1 or longer.
This does change the behavior of the earleme variables.

In this new model,
for each call to 
@code{marpa_r_alternative()}
if the current earleme before the call was @var{i},
then after the call
the latest earleme will also be @var{i},
but the furthest earleme will be MAX(@var{f'}, @var{i}+@var{length}),
where @var{f'} is the value of the furthest earleme before the call,
and @var{length} is the length of the token.
That is, the new value of the furthest earleme will
be its previous value,
or the end earleme of the newly added token,
whichever is greater.

For each call to 
@code{marpa_r_earleme_complete()}
if the current earleme before the call was @var{i},
then after the call
the current earleme and latest earleme will both be @var{i+1}.
The furthest earleme is never changed by a call
to @code{marpa_r_earleme_complete()} --
it will have the same value it had before the call.

@node The generalized model, General rules for the earleme variables, Variable length tokens, Earlemes
@subsection The generalized model

To fully generalize the input model,
we now need to remove only one restriction.
We now allow empty earlemes -- earlemes with
no tokens and no Earley set.

A call
to @code{marpa_r_earleme_complete()},
creates an empty earleme if and only if
it falls into one of these two cases:
@itemize
@item
There has been no call
to @code{marpa_r_alternative()} since
recognizer initialization.
@item
There has been no call
to @code{marpa_r_alternative()} since
the previous call
to @code{marpa_r_earleme_complete()}.
@end itemize

If a call to @code{marpa_r_earleme_complete()} creates
an empty earleme,
the latest earleme remains unchanged from its
prior value.
This means that, since the current earleme will
change, the latest earleme will be less
than the current earleme.
As always the furthest earleme is unchanged by
the call to @code{marpa_r_earleme_complete()}.

@node General rules for the earleme variables,  , The generalized model, Earlemes
@subsection General rules for the earleme variables

At this point, the most generalized input model has been
introduced.
Next we state some facts that will always be the case,
no matter what input model is in use.

@itemize
@item The current earleme is greater than
or equal to the latest earleme.
@item The furthest earleme is greater than
or equal to the latest earleme.
@item If the parser is not exhausted,
the furthest earleme is always greater than
or equal to the current earleme.
@item In an exhausted parser,
the furthest earleme is always less than
or equal to the current earleme.
@item If the furthest earleme is greater than the current earleme,
the parser is not exhausted.
@item For the furthest earleme to be less than the current earleme,
the parser must be exhausted.
@end itemize

@node Terminals, LHS Terminals, Earlemes, Input
@section Terminals

A terminal symbol is a symbol which
may appear in the input.
Traditionally,
all LHS symbols, as well as
the start symbol, must be non-terminals.
Marpa's grammars differ from the traditional ones
in that there is no necessary distinction between
terminals and non-terminals.
In Marpa,
a terminal may be the start symbol,
and may appear on the LHS of a rule.
However,
since terminals can never be zero length,
it is a logical contradiction for a nulling
symbol to also be a terminal
and Marpa does not allow it.

@menu
* LHS Terminals::               
* Token values::                
@end menu

@node LHS Terminals, Token values, Terminals, Input
@section Uses for LHS terminals

Marpa's idea
in losing the sharp division between terminals
and non-terminals is that the distinction,
while helpful for proving theorems,
is not essential in practice.
If LHS symbols
appear in the input they, in effect,
``short circuiting'' the rules in which they occur.
This may
be helpful in debugging, or have other applications.

However,
it also can be useful,
for checking input validity as well as for efficiency,
to follow tradition and distingush
non-terminals from terminals.
For this reason,
the traditional behavior is the default
in Marpa.

@node Token values,  , LHS Terminals, Input
@section Token values

Token values are @code{int}'s.
Libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.
Integers are used as token values instead of
pointers because their validity can be safely checked.
It is hard or impossible
to check the validity of pointers
without risking an abend.
Integers can be used to access any kind of data
using an array,
so that the higher levels can translate integers back
and forth into whatever the application requires.

@node Semantics, Threads, Input, Top
@chapter Semantics

@menu
* How Libmarpa semantics work::  
* Universe of values::          
* Valued and unvalued symbols::  
@end menu

@node How Libmarpa semantics work, Universe of values, Semantics, Semantics
@section How the Libmarpa semantics work

Libmarpa handling of semantics is unusual.
Most semantics are left up to the application,
but Libmarpa guides them.
Specifically, the application is expected to maintain the evaluation
stack.
Libmarpa's valuator provides instructions on how to handle the stack.
Libmarpa's stack handling instructions
are called ``steps''.
For example, a Libmarpa step might tell the application that the value
of a token needs to go into a certain stack position.
Or a Libmarpa step might tell the application that a rule is to be evaluation.
For rule evalution, Libmarpa will tell the application where the operands
are to be found,
and where the result must go.

@node Universe of values, Valued and unvalued symbols, How Libmarpa semantics work, Semantics
@section The universe of values

The application can react to Libmarpa's stack handling instructions
in any way it sees fit,
but it is expected that it will maintain a physical stack which
can be addressed as an array.

An advantage of leaving the application in control of the stack
is that the applicaion has total control over what the stack values
are.
The set of all possible stack values is the application's
@dfn{universe of values}.
For example, as implemented in Perl,
the universe of values is the Perl scalar-assignables.
In C, they could be integers, @code{void *} pointers,
or pointers to some sort of polymorphic object.

It is up to the application to make sure the stack positions
in Libmarpa's steps exist and are initialized as desired
by the application.
This means extending the stack as needed for writes,
but also for reads.
Because of optimizations, it is quite possible for a
Libmarpa step to identify a stack position which has
never been written to as the operand of a rule.
This can happen, for example, if the rule's
operand is an unvalued or ``whatever''
value.
(It is expected that in such a case that the rule's value
does not depend on that operand, though it is up to the
application to ensure this.)

C programmers should be aware of a pitfalls specific to C.
Both C90 and C99 allow unitialized values to be ``trap'' values --
values which cause a trap (possibly an abend) when read.
A C application must take steps to ensure either that
the universe of values does not include trap values,
or that these trap values are never read.
Excluding trap values from a C program's universe of
values may require the application to make
sure that stack positions are properly initialized.
This is discussed in detail in the section
on value objects.
@xref{Value methods}.

@node Valued and unvalued symbols,  , Universe of values, Semantics
@section Valued and unvalued symbols

Libmarpa symbols can have values,
which is the traditional way of doing semantics.
Libmarpa also allows symbols to be unvalued.
An @dfn{unvalued} symbol is one whose value
is unpredictable from instance to instance.
If a symbol is unvalued, we sometimes say that it
has ``whatever'' semantics.

Situations where the semantics can tolerate unvalued symbols
are surprisingly frequent.
For example, the top-level of many languages is a series
of major units, all of whose semantics are typically accomplished
via side effects.
The compiler is typically indifferent to the actual value produced
by these major units, and tracking them is a waste of time.
Similarly, the value of the separators in a list is typically
ignored.

Rules are unvalued if and only if their LHS symbols
are unvalued.
When rules and symbols are unvalued,
Libmarpa optimizes their evaluation.

It is in principle unsafe to check the value 
of a symbol if it can be unvalued.
For this reason,
once a symbol has been treated as valued,
Libmarpa marks it as valued.
Similarly,
once a symbol has been treated as unvalued,
Libmarpa marks it as unvalued.
Once marked, a symbol's valued status is
@dfn{locked} and cannot be changed later.

The valued status of terminals is marked the first
time they are read.
The valued status of LHS symbols must be explicitly
marked by the application when initializing the
valuator -- this is Libmarpa's equivalent of
registering a callback.

LHS terminals are disabled by default.
If allowed, the user should be aware that the valued
status of a LHS terminal
will be locked in the recognizer
if it is used as a terminal,
and the symbol's use as a rule LHS
in the valuator must be
consistent with the recognizer's marking.

Marpa reports an error when a symbol's use
conflicts with its locked valued status.
Doing so usually saves the programmer
some tricky debugging further down the road.
But it is possible that an application might deliberately
want to mix
valued and unvalued uses of a symbol -- an application
might be able to differentiate them using the larger
context, or might be tolerant of the uncertainty.
If there is interest,
a future Libmarpa extension might allow a locked
valued status to be overriden.

@node Threads, Error handling concepts, Semantics, Top
@chapter Threads

Libmarpa is thread-safe,
given circumstances as described below.
The Libmarpa methods are not reentrant.

Libmarpa is C89-compliant.
It uses no global data,
and calls only the routines
that are defined in the C89 standard
and that can be made thread-safe.
In most modern implementations,
the default C89 implementation is thread-safe
to the extent possible.
But the C89 standard does not require thread-safety,
and even most modern environments allow the user
to turn thread safety off.
To be thread-safe, Libmarpa must be compiled
and linked in an environment that provides
thread-safety.

While Libmarpa can be used safely across
multiple threads,
a Libmarpa grammar cannot be.
Further, a Libmarpa time object can
only be used safely in the same thread
as its base grammar.
This is because all
time objects with the same base grammar share data
from that base grammar.

To work around this limitation,
the same grammar definition can be
used to a create a new
Libmarpa grammar
time object in each thread.
If there is sufficient interest, future versions of
Libmarpa could allow thread-safe
cloning of grammars and other
time objects.

@node Error handling concepts, Introduction to the external interface, Threads, Top
@chapter Error handling

@menu
* Memory allocation failures::  
@end menu

@node Memory allocation failures,  , Error handling concepts, Error handling concepts
@section Memory allocation failures

Libmarpa leaves the decision of what is a fatal
error up to the application,
with one exception.
Currently, if @code{malloc} fails to allocate memory,
Libmarpa terminates the program with a fatal error.

While this is in keeping with current practice,
future versions of Libmarpa are likely to both allow
an alternative memory allocator to be specificied,
and to allow the user to specifier a handler to
be called when an out-of-memory condition occurs.

@node Introduction to the external interface, Static method, Error handling concepts, Top
@chapter Introduction to the external interface

The following chapters describe Libmarpa's external
interface in detail.

@menu
* About the overviews::         
* Return values::               
* Naming conventions::          
@end menu

@node About the overviews, Return values, Introduction to the external interface, Introduction to the external interface
@section  About the overviews

The reference method sections usually begin with an overview
describing the important methods.
These sections can be describe the
most important Libmarpa methods,
in the order in which they are typically used,
and can be used as ``cheat sheet''.

The overview sections limit themselves to
the most important methods.
To guide the reader to those methods
that he is most likely to find essential
for his application,
the overview sections often speak of
an ``archetypal'' application.
The archetypal Libmarpa application
implements the complete logic flow,
from the creation of a grammar to a final result
from its valuation.
In the archetypal Libmarpa application,
the grammar, input and semantics are small but non-trivial.

@node Return values, Naming conventions, About the overviews, Introduction to the external interface
@section Return values

Return values are discussed method by method,
but some general practices are worth
mentioning.
For methods that return an integer,
Libmarpa usually reserves -1 for special purposes,
such as indicating loop termination in an iterator.
In Libmarpa, methods typically indicate failure
by returning -2.
If a function returns an pointer value,
@code{NULL} typically indicates failure.
and any other result indicates success.

A method can have many reasons for
failing, and many of the reasons
for failure are common to
large number of methods.
The method descriptions contain details
of possible failures when they are significant
for using that method.
Full descriptions of the error codes
returned by the external methods
are given in their own section.
@xref{External error codes}.

@node Naming conventions,  , Return values, Introduction to the external interface
@section Naming conventions

Methods in Libmarpa follow a strict naming convention.
All methods have a name beginning with @code{marpa_},
if they are part of the
external interface.
If an external method is not a static method,
its name is prefixed with one of 
@code{marpa_g_},
@code{marpa_r_},
@code{marpa_b_},
@code{marpa_o_},
@code{marpa_t_} or
@code{marpa_v_},
where the single letter between underscores
is one of the time class abbreviations.
The letter indicates which class
the method belongs to.

Methods which are exported,
but which are part of
the internal interface begin with @code{_marpa_}.
Methods which are part of the internal interface
(hereafter ``internal methods'')
are subject to change and are intended for use
only by Libmarpa's developers.

Libmarpa reserves the @code{marpa_}
and @code{_marpa_} prefixes for itself,
with all their capitalization variants.
All Libmarpa names visible outside the package
will begin with a capitalization variant
of one of these two prefixes.

@node Static method, Configuration methods, Introduction to the external interface, Top
@chapter Static method

@deftypefun Marpa_Error_Code marpa_check_version @
    (unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro} @
    )

Checks that the Marpa library in use is compatible with the
given version. Generally you would pass in the constants
@code{MARPA_MAJOR_VERSION},
@code{MARPA_MINOR_VERSION},
@code{MARPA_MICRO_VERSION}
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of Libmarpa the application or module was compiled
against.

Currently Libmarpa is undergoing rapid development,
and backward compatibility is not maintained.
This will be the case as long as Libmarpa stays
alpha.
While Libmarpa is alpha
the major, minor and micro numbers must match exactly.

Once Libmarpa is beyond alpha releases,
compatibility will be defined by two things:
first the version
of the running library is newer than the version
@var{required_major}.@var{required_minor}.@var{required_micro}.
Second
the running library must be binary compatible with the
version
@var{required_major}.@var{required_minor}.@var{required_micro}
(same major version.)

Return value: @code{MARPA_ERR_NONE} if the Marpa library is compatible with the
requested version.  If the library is not compatible,
one of the following is returned, indicating the nature of the mismatch:
@itemize
@item @code{MARPA_ERR_MAJOR_VERSION_MISMATCH},
@item @code{MARPA_ERR_MINOR_VERSION_MISMATCH}
@item @code{MARPA_ERR_MICRO_VERSION_MISMATCH}
@end itemize

@end deftypefun

@node Configuration methods, Grammar methods, Static method, Top
@chapter Configuration methods

The configuration object is intended for future extensions.
These may
allow the application to override Libmarpa's memory allocation
and fatal error handling without resorting to global
variables, and therefore in a thread-safe way.
Currently, the only function of the @code{Marpa_Config}
class is to give @code{marpa_g_new()}
a place to put its error code.

@code{Marpa_Config} is Libmarpa's only ``major''
class which is not a time class.
There is no constructor or destructor, although
@code{Marpa_Config} objects @strong{do} need to be initialized
before use.
Aside from its own accessor,
@code{Marpa_Config} objects are only used by @code{marpa_g_new}
and no reference to their location is not kept
in any of Libmarpa's time objects.
The intent is to that it be convenient
to have them in memory that might be deallocated
soon after @code{marpa_g_new} returns.
For example, they could be put on the stack.

@deftypefun int marpa_c_init ( @
  Marpa_Config* @var{config})

Initialize the @var{config} information to ``safe'' default
values.
Unspecified behavior will result
if an initialized
configuration is used to create a grammar.

Return value: A non-negative value.  Always succeeds.
@end deftypefun

@deftypefun Marpa_Error_Code marpa_c_error ( @
  Marpa_Config* @var{config}, const char** @var{p_error_string} )

Error codes are usually kept in the base grammar,
which leaves @code{marpa_g_new()} no place to put
its error code on failure.
Objects of
the @code{Marpa_Config} class provide such a place.

Return value:
The error code in @var{config}.
Always succeeds.
@end deftypefun

@node Grammar methods, Recognizer methods, Configuration methods, Top
@chapter Grammar methods
@cindex grammars

@menu
* Grammar overview::            
* Grammar constructor::         
* Grammar reference counting::  
* Symbols::                     
* Rules::                       
* Sequences::                   
* Grammar precomputation::      
* Grammar events::              
@end menu

@node Grammar overview, Grammar constructor, Grammar methods, Grammar methods
@section Overview

An archtypal application has a grammar.
To create a grammar, use the @code{marpa_g_new()} method.
When a grammar is no longer in use, its memory can be freed
using the 
@code{marpa_g_unref()} method.

To be precomputed,
a grammar must have one or more symbol.
To create symbols, use the
@code{marpa_g_symbol_new()} method.

To be precomputed,
a grammar must have one or more rules.
To create rules, use the
@code{marpa_g_rule_new()} and
@code{marpa_g_sequence_new()} methods.

For non-trivial parsing,
one or more of the symbols must be terminals.
To mark a symbol as a terminal,
use the
@code{marpa_g_symbol_is_terminal_set()} method.

To be precomputed,
a grammar must have exactly one start symbol.
To mark a symbol as the start symbol,
use the
@code{marpa_g_start_symbol_set()} method.

Before parsing with a grammar, it must be precomputed.
To precompute a grammar,
use the
@code{marpa_g_precompute()} method.

@node Grammar constructor, Grammar reference counting, Grammar overview, Grammar methods
@section Creating a new grammar
@cindex grammar constructor

@deftypefun Marpa_Grammar marpa_g_new ( @
    Marpa_Config* configuration )

Creates a new grammar time object.
The returned grammar object is not yet precomputed,
and will have no symbols and rules.
Its reference count will be 1.

Unless the application calls @code{marpa_c_error},
Libmarpa will not reference the location
pointed to by the @var{configuration}
argument after @code{marpa_g_new} returns.
The @var{configuration} argument may be @code{NULL},
but if it is,
there will be no way to determine
the error code on failure.

Return value: On success, the grammar object.
On failure, @code{NULL},
and the error code is set in @var{configuration}.

@end deftypefun

@node Grammar reference counting, Symbols, Grammar constructor, Grammar methods
@section Tracking the reference count of the grammar
@cindex grammar destructor
@cindex grammar reference
@cindex grammar reference count

@deftypefun Marpa_Grammar marpa_g_ref (Marpa_Grammar @var{g})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, the grammar object it was called with;
@code{NULL} on failure.

@end deftypefun

@deftypefun void marpa_g_unref (Marpa_Grammar @var{g})
Decreases the reference count by 1,
destroying @var{g} once the reference count reaches
zero.

@end deftypefun

@node Symbols, Rules, Grammar reference counting, Grammar methods
@section Symbols

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol (Marpa_Grammar @var{g})

Returns current value of the start symbol of grammar @var{g}.
The value is that
specified in the @code{marpa_g_start_symbol_set()} call,
if there has been one.

Return value:
On failure, -2;
-1 if there is no start symbol yet;
otherwise the ID of the new start symbol.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{id})

Sets the start symbol of grammar @var{g} to symbol @var{id}.

Return value: On success, the ID of the new start symbol.
On failure, -2.

@end deftypefun

@deftypefun int marpa_g_symbol_count (Marpa_Grammar @var{g})
Return value:
On success, the symbol count of the grammar.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{accessible} if it can be reached from the start symbol.

Return value: On success, 1 if symbol @var{symid} is accessible, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_nullable ( @
  Marpa_Grammar g, Marpa_Symbol_ID symid)
A symbol is @dfn{nullable} if it sometimes produces the empty string.
A @strong{nulling} symbol is always a @strong{nullable} symbol,
but not all @strong{nullable} symbols are @strong{nulling} symbols.

Return value: On success, 1 if symbol @var{symid} is nullable, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{nulling} if it always produces the empty string.

Return value: On success, 1 if symbol @var{symid} is nulling, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{productive} if it can produce a string of terminals.
All nullable symbols are considered productive.

Return value: On success, 1 if symbol @var{symid} is productive, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_start ( Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})

This return value of this call indicates whether @var{symid}
is the start symbol.

Return value: -2 if @var{symid} is not valid;
    1 if @var{symid} is the start symbol;
    0 otherwise.

@end deftypefun

@deftypefun int marpa_g_symbol_is_terminal ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@deftypefunx int marpa_g_symbol_is_terminal_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 int @var{value})

These methods, respectively, set
and query the ``terminal status'' of a symbol.
To be used as an input symbol
in the @code{marpa_r_alternative()} method,
a symbol must be a terminal.
This function flags symbol @var{symid} as a terminal if
@var{value} is 1,
or flags it as a non-terminal if @var{value} is 0.

Once set to a value with the
@code{marpa_g_symbol_is_terminal_set()} method,
the terminal status of a symbol is ``locked'' at that value.
A subsequent call to 
@code{marpa_g_symbol_is_terminal_set()} that attempts
to change the terminal tstatus
of @var{symid} to a value different from its current
will fail.
The error code will be @code{MARPA_ERR_TERMINAL_IS_LOCKED}.

By default, a symbol is a terminal if and only if it
does not appear on the LHS of any rule.
An attempt to flag a nulling symbol
as a terminal will cause a failure,
but this is not necesssarily detected before precomputation.

Return value: On success, 1 if symbol @var{symid}
is a terminal symbol after the
call, 0 otherwise.
If the terminal status would be changed but is locked;
If @var{value} is not 0 or 1;
if the grammar @var{g} is precomputed;
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_valued ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id})
@deftypefunx int marpa_g_symbol_is_valued_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id}, @
    int value)

These methods, respectively, set
and query the ``valued status'' of a symbol.
If a symbol is ``valued'',
the semantics require that it have a defined value.
If a symbol is not valued,
it is an unvalued, or a ``whatever'' symbol.

Once set to a value with the
@code{marpa_g_symbol_is_valued_set()} method,
the valued status of a symbol is ``locked'' at that value.
It cannot thereafter be changed.
Subsequents call to 
@code{marpa_g_symbol_is_valued_set()} can be made
for the same @var{symid}
will succeed only if
@var{value} is the same as the locked-in value.
Attempts to change a locked value
will return failure,
and leave the @var{symid}'s valued status unchanged.

Return value: On success, 1 if the symbol @var{symbol_id}
is valued after the call, 0 if not.
If the valued status is locked and @var{value}
is different from the current status, -2.
If @var{value} is not 0 or 1;
or on other failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_symbol_new (Marpa_Grammar @var{g})

Creates a new symbol.

Return value: On success, the ID of a new symbol;
On failure, -2.

@end deftypefun

@node Rules, Sequences, Symbols, Grammar methods
@section Rules

@deftypefun int marpa_g_rule_count (Marpa_Grammar @var{g})
Return value: On success, the current number of rules in grammar @var{g}.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{accessible} if it can be reached from the start symbol.
A rule is accessible if and only if its LHS symbol is accessible.
The start rule is always an accessible rule.

Return value: On success, 1 if rule @var{rule_id}
is accessible, 0 if not.
If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_nullable ( @
  Marpa_Grammar g, Marpa_Rule_ID ruleid)
A rule is @dfn{nullable} if it sometimes produces the empty string.
A @strong{nulling} rule is always a @strong{nullable} rule,
but not all @strong{nullable} rules are @strong{nulling} rules.

Return value: On success,
1 if rule @var{ruleid} is nullable, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{ruleid})
A rule is @dfn{nulling} if it always produces the empty string.

Return value: On success,
1 if rule @var{ruleid} is nulling, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
A rule is a loop rule if it non-trivially
produces the string of length one
which consists only of its LHS symbol.
Such a derivation takes the parse back to where
it started, hence the term ``loop''.
``Non-trivially'' means the zero-step derivation does not count -- the
derivation must have at least one step.

The presence of a loop rule makes a grammar infinitely ambiguous,
and applications will typically want to treat them as fatal errors.
But nothing forces an application to do this,
and Marpa will successfully parse and evaluate grammars with
loop rules.

Return value: On success,
1 if rule @var{rule_id} is a loop rule, 0 if not.
If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{productive} if it can produce a string of terminals.
An rule is productive if and only if all the symbols on
its RHS are productive.
The empty string counts as a string of terminals,
so that a nullable rule is always a productive rule.
For that same reason,
an empty rule is considered productive.

Return value: On success,
1 if rule @var{rule_id} is productive, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
The length of a rule is the number of symbols on its RHS.

Return value: On success, the length of rule @var{rule_id}.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value: On success, the LHS symbol of rule @var{rule_id}.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Rule_ID marpa_g_rule_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs_id}, @
 Marpa_Symbol_ID *@var{rhs_ids}, @
     int @var{length})
Creates a new external rule in grammar @var{g}.
The LHS symbol is @var{lhs_id},
and there are @var{length} symbols on the RHS.
The RHS symbols are in an array
pointed to by @var{rhs_ids}.

Possible failures, with their error codes, include:
@itemize
@item @code{MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE}: The LHS symbol is the same
as that of a sequence rule.
@item @code{MARPA_ERR_DUPLICATE_RULE}: The new rule would duplicate another BNF
rule.
Another BNF rule is considered the duplicate of the new one,
if its LHS symbol is the same as symbol @var{lhs_id},
if its length is the same as @var{length},
and if its RHS symbols match one for one those
in the array of symbols @var{rhs_ids}.
@end itemize

Return value:  On success, the ID of new external rule.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_rhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id}, @
    int @var{ix})
Returns the ID of the symbol in position @var{ix}
in the RHS of rule @var{rule_id}.
The RHS position, @var{ix}, is zero-based.

Return value: On success, the symbol in position @var{ix}
on the rules RHS.
If @var{ix} is greater than or equal to the length of
the rule,
or on other failure, -2.
@end deftypefun

@node Sequences, Grammar precomputation, Rules, Grammar methods
@section Sequences

@deftypefun int marpa_g_rule_is_proper_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})

Note that this method will succeed even if rule @var{rule_id}
is not a sequence rule.
Since only sequence rules can have the proper separation flag set,
the @code{marpa_g_rule_is_proper_separation()}
method returns 0
whenever rule @var{rule_is} is a BNF rule.

Return value:
On success,
1 if rule @var{rule_id} has
the proper separation flag set,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_sequence ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value:  On success,
1 if rule @var{rule_id} is a sequence rule,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Rule_ID marpa_g_sequence_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs_id}, @
 Marpa_Symbol_ID @var{rhs_id}, @
     Marpa_Symbol_ID @var{separator_id}, @
    int @var{min}, @
 int @var{flags} )
Adds a new sequence rule to grammar @var{g}.
Sequence rules do not extend the kinds of grammar that
Libmarpa parses -- a sequence can always be written
as BNF rules.
(In fact this is how Libmarpa
implements them.)
But when Libmarpa knows that a rule is a sequence,
it can optimize it.
This speedup is often considerable.

The sequence is @var{lhs_id},
and the item to be repeated in the sequence is @var{rhs_id}.
The sequence must be repeated at least @var{min} times,
where @var{min} is 0 or 1.
If @var{separator_id} is non-negative,
it is a separator symbol.

If @code{flags & MARPA_PROPER_SEPARATION} is non-zero,
separation is ``proper'', that is,
a trailing separator is not allowed.
The term @dfn{proper} is based on the idea that
properly-speaking, separators should actually separate items.

The sequence RHS, or item,
is restricted to a single symbol,
and that symbol cannot be nullable.
If @var{separator_id} is a symbol, it also cannot
be a nullable symbol.
Nullables on the RHS of sequences are restricted
because they lead to highly ambiguous grammars.
Grammars of this kind are allowed by Libmarpa, but
they must be expressed using BNF rules, not sequence rules.
This is for two reasons:
First, sequence optimizations would not work
in the presence of nullables.
Second, since it is not completely clear what
an application intends
when it asks for a sequence of identical items,
some of which are nullable,
the user's intent can be more clearly expressed
directly in BNF.

The LHS symbol cannot be the LHS of any other rule,
whether a BNF rule or a sequence rule.
On an attempt to create an sequence rule with a duplicate
LHS,
@code{marpa_g_sequence_new()} fails,
setting the error code to
@code{MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE}.

Return value:  On success, the ID of the external rule.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_counted (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{counted}
if it appears on the RHS of a sequence rule,
or if it is used as
the separator symbol of a sequence rule.

Return value: On success,
1 if symbol @var{symid} is counted, 0 if not.
On failure, -2.
@end deftypefun

@node Grammar precomputation, Grammar events, Sequences, Grammar methods
@section Precomputing the Grammar

@deftypefun int marpa_g_precompute (Marpa_Grammar @var{g})

@anchor{marpa_g_precompute}
Precomputation is necessary for a recognizer to be generated
from a grammar.
On success, @code{marpa_g_precompute} returns a non-negative
number to indicate that it precomputed the grammar without
issues.
On failure, @code{marpa_g_precompute} returns -2
to indicate that it encountered issues.
Usually this issues will have prevented precomputation,
making it impossible
to go on to create
a recognizer and continue with the parse.

When 
@code{marpa_g_precompute()} fails with an error code
of @code{MARPA_ERR_GRAMMAR_HAS_CYCLE},
the grammar will have been precomputed.
If the @code{marpa_g_is_precomputed()} method
is called, it will confirm this.
This means an application is free to ignore the presence
of cycles,
create a recognizer from the precomputed grammar,
and continue parsing all the way to evaluation.

Most applications, however,
will want to simply treat cycles as a problem,
and fix them before parsing.
Cycles make a grammar infinitely ambiguous,
and are considered useless in current
practice.
Cycles make processing the grammar less
efficient, sometimes considerably so.

To query events,
the application must call @code{marpa_g_event()}.
At this point events only occur when failure is reported,
and events always report issues.
But application writers should expect future versions
to have events which are reported on success,
as well as events which do not represent issues.

A @code{MARPA_EVENT_LOOP_RULES} event occurs
when there are infinite loop rules (cycles)
in the grammar.
The presence of one or more of these will cause failure
to be reported,
but will not prevent the grammar from being precomputed.

Each @code{MARPA_EVENT_COUNTED_NULLABLE} event is a symbol
which is a nullable on the right hand side of a sequence
rule -- a ``counted'' symbol.
The presence of one or more of these will cause failure
to be reported,
and will prevent the grammar from being precomputed.
So that the programmer can fix several at once,
these failures are delayed until events are created
for all of the counted nullables.

Each @code{MARPA_EVENT_NULLING_TERMINAL} event is a nulling
symbol which is also flagged as a terminal.
Since terminals cannot be of zero length, this is a logical
impossibility.
The presence of one or more of these will cause failure
to be reported,
and will prevent the grammar from being precomputed.
So that the programmer can fix several at once,
the failure is delayed until events are created
for all of the counted nullables.

Precomputation involves freezing
and then thoroughly checking the grammar.
Among the reasons for precomputation to fail
are the following:

@itemize
@item @code{MARPA_ERR_NO_RULES}: The grammar has no rules.
@item @code{MARPA_ERR_NO_START_SYMBOL}: No start symbol was specified.
@item @code{MARPA_ERR_INVALID_START_SYMBOL}: A start symbol ID was specified, but it
is not the ID of a valid symbol.
@item @code{MARPA_ERR_START_NOT_LHS}: The start symbol is not on the LHS of any rule.
@item @code{MARPA_ERR_UNPRODUCTIVE_START}: The start symbol is not productive.
@item @code{MARPA_ERR_COUNTED_NULLABLE}: A symbol on the RHS of a sequence rule is
nullable.
Libmarpa does not allow this.
@item @code{MARPA_ERR_NULLING_TERMINAL}: A terminal is also a nulling symbol.
Libmarpa does not allow this.
@end itemize

More details of these can be found under the
description of the appropriate code.
@xref{External error codes}.

Return value: On success, a non-negative number.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_is_precomputed (Marpa_Grammar @var{g})
Return value: On success, 1
if grammar @var{g} is already precomputed,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_has_cycle (Marpa_Grammar @var{g})
This function allows the application to determine if grammar
@var{g} has a cycle.
As mentioned, most applications will want to treat these
as fatal errors.
To determine which rules are in the cycle,
@var{marpa_g_rule_is_loop()} can be used.

Return value: On success, 1 if the grammar has a cycle,
0 otherwise.
On failure, -2.
@end deftypefun

@node Grammar events,  , Grammar precomputation, Grammar methods
@section Events

@deftypefun Marpa_Event_Type marpa_g_event (Marpa_Grammar @var{g}, @
    Marpa_Event* @var{event}, @
	       int @var{ix})
This method provides access to the events generated
by the @code{marpa_g_precompute()} method.
On success,
the data for the @var{ix}'th event (numbered from 0) is placed
in the location pointed to by @var{event}.
On failure,
the locations pointed to by @var{event}
are not changed.

Event indexes are in sequence, starting with 0.
Valid events will be in the range from 0 to @var{n}.
where @var{n} is one less than the event count.
The event count
can be queried using the @code{marpa_g_event_count()}
method.

Return value:  On success, the type of event @var{ix}.
If there is no @var{ix}'th event,
fi @var{ix} is negative,
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_event_count ( Marpa_Grammar g )
Return value:  On success, the number of events.
On failure, -2.
@end deftypefun

@deftypefn {Macro} int marpa_g_event_value (Marpa_Event* @var{event})
This macro provides access to the ``value'' of the event.
The semantics of the value varies according to the type
of the event, and is described in the section on event
codes.
@xref{Events}.
@end deftypefn

@node Recognizer methods, Progress reports, Grammar methods, Top
@chapter Recognizer methods

@menu
* Recognizer overview::         
* Recognizer constructor::
* Recognizer reference counting::
* Recognizer life cycle mutators::  
* Location accessors::          
* Other parse status methods::  
@end menu

@node Recognizer overview, Recognizer constructor, Recognizer methods, Recognizer methods
@section Overview

An archtypal application uses a recognizer to read input.
To create a recognizer, use the @code{marpa_r_new()} method.
When a recognizer is no longer in use, its memory can be freed
using the 
@code{marpa_r_unref()} method.

In order to allow future extensions that change settings
before the recognizer is set up for input,
when the recognizer is created,
it is @strong{not} created ready for input.
To make a recognizer ready for input,
Use the @code{marpa_r_start_input()} method.

The recognizer starts with its current earleme
at location 0.
To read a token at the current earleme,
use the @code{marpa_r_alternative()} call.

To complete the processing of the current earleme,
and move forward to a new one,
use the @code{marpa_r_earleme_complete()} call.

@node Recognizer constructor, Recognizer reference counting, Recognizer overview, Recognizer methods
@section Creating a new recognizer

@deftypefun Marpa_Recognizer marpa_r_new ( Marpa_Grammar @var{g} )
Creates a new recognizer.
The reference count of the recognizer will be 1.
The reference count of @var{g},
the base grammar,
will be incremented by one.

Return value:  On success, the newly created recognizer.
If @var{g} is not precomputed, or on other failure, @code{NULL}.
@end deftypefun

@node Recognizer reference counting, Recognizer life cycle mutators, Recognizer constructor, Recognizer methods
@section Keeping the reference count of a recognizer

@deftypefun Marpa_Recognizer marpa_r_ref (Marpa_Recognizer @var{r})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, the recognizer object, @var{r}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_r_unref (Marpa_Recognizer @var{r})
Decreases the reference count by 1,
destroying @var{r} once the reference count reaches
zero.
When @var{r} is destroyed, the reference count
of its base grammar is decreased by one.
It this takes the reference count of the base grammar
to zero, it too is destroyed.

@end deftypefun

@node Recognizer life cycle mutators, Location accessors, Recognizer reference counting, Recognizer methods
@section Life cycle mutators

@deftypefun int marpa_r_start_input (Marpa_Recognizer @var{r})
Makes @var{r} ready to accept input.

Return value:  On success, a non-negative value.
On failure, -2.
@end deftypefun

@deftypefun int marpa_r_alternative (Marpa_Recognizer @var{r}, @
    Marpa_Symbol_ID @var{token_id}, @
    int @var{value}, @
    int @var{length})
Reads a token into @var{r}.
The token will start at the current earleme.
Libmarpa allows tokens to be ambiguous, to be of
variable length and to overlap.
@var{token_id} is the symbol of the token,
which must be a terminal.
@var{length} is the length of the token.

@var{value} is an
integer which represents the value of the
token.
In applications where the token's value is not an integer, it is
expected that the application will use this value to
find the application's value, perhaps by using @var{value}
to index an array.
@var{value} is not used inside Libmarpa -- it is simply
stored to be returned by the valuator
as a convenience for the application.
Some applications will not want to use Libmarpa's token
values, instead tracking their own, perhaps based on
the earleme location, and @var{token_id}.

A @var{value} of 0 has special significance -- it indicates
that the token is unvalued -- that its value is allowed
to be unpredictable.
Note that if a token is unvalued,
it must be the case,
not just that Libmarpa need not care about its value,
but also that @strong{the application}
does not care about the value of the token.
When a token has a ``whatever'' value, Libmarpa 
optimizes away the valuator steps which
give the application an opportunity to provide
a value for that token.
Applications which do not use Libmarpa's token values,
but which @strong{do} care about the token's value,
must tell Libmarpa not to optimize away the
relevant valuator steps.
An application can do this by
letting @var{value} be any non-zero integer.

If, on the first read by
@code{marpa_r_alternative()},
symbol @var{token_id} is not already locked,
the valued status
of symbol @var{token_id}
will be set according to its
use in that call
to @code{marpa_r_alternative()},
and symbol @var{token_id}
will be locked in that valued status.
Once symbol
@var{token_id} is locked in valued status,
it must be used as a valued symbol.
Similarly, once symbol
@var{token_id} is locked in unvalued status,
it must be used as a unvalued symbol.

When @code{marpa_r_alternative()}
is successful,
the value of furthest earleme is set to
the greater of its value before the call,
and @var{current}+@var{length},
where @var{current} is the value of the current earleme.
The values of the current and latest earlemes
are unchanged by
calls to @code{marpa_r_alternative()}.

Several error codes leave the recognizer in a fully
recoverable state, allowing the application to
retry the @code{marpa_r_alternative} method.
Retry is efficient, and quite useable as a parsing
technique.
The error code
of primary interest from this point of view
is @code{MARPA_ERR_UNEXPECTED_TOKEN_ID},
which indicates that the token was not accepted
because of its token ID.
Retry after this condition is used in several
applications,
and is called ``the Ruby Slippers technique''.

The error codes
@code{MARPA_ERR_DUPLICATE_TOKEN},
@code{MARPA_ERR_NO_TOKEN_EXPECTED_HERE}
and @code{MARPA_ERR_INACCESSIBLE_TOKEN}
also leave the recognizer in a fully recoverable
state, and may also be useable for the
Ruby Slippers or similar technique.
At this writing,
the author knows of no applications which
attempt to recover from these errors.

Return value:  On success, @code{MARPA_ERR_NONE}.
On failure, some other error code.

@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme_complete (Marpa_Recognizer @var{r})
This method does the final processing for the current earleme.
It then advances the current earleme by one.
Note that @code{marpa_r_earleme_complete()} may be called
even when no tokens have been read at the current earleme --
in the character-per-earleme input model, for example, tokens
can span many characters and, if the input is unambiguous over that
span, there will be no other tokens that start inside it.

As mentioned,
@code{marpa_r_earleme_complete()} always advances the current earleme,
incrementing its value by 1.
This means that value of the current earleme after the call
will be the one plus the value of the earleme processed by the call
to @code{marpa_r_earleme_complete()}.
If any token was accepted at the earleme being processed,
@code{marpa_r_earleme_complete()} creates a new Earley set
which will be the latest Earley set,
and, after the call, the latest
earleme will be equal to the new current earleme.
If no token was accepted at the
earleme being processed,
no Earley set is created,
and the value of the latest earleme remains unchanged.
The value of the furthest earleme is never changed by
a call to @code{marpa_r_earleme_complete()}.

During this method, one or more events may occur.
On success, this function returns the number of events
generated,
but it is important to note that events may be
created whether earleme completion fails or succeeds.
When this method fails,
the application must call @code{marpa_g_event()}
if it wants to determine if any events occurred.
Since the reason for failure to complete an earleme is often
detailed in the events, applications that fail will often
be at least as interested in the events as those
that succeed.

@code{MARPA_EVENT_EXHAUSTED} indicates that the parse is
exhausted -- that no input will be accepted at later earlemes.
Note that an exhausted parse can be a successful one -- it
just cannot succeed at a later earleme than the current one.

The @code{MARPA_EVENT_EARLEY_ITEM_THRESHOLD} event
indicates that an application-settable threshold
on the number of Earley items has been reached or exceeded.
What this means depends on the application,
but when the default threshold is exceeded,
it means that it is very likely
that the time and space resources consumed by
the parse will prove excessive.

Return value:  On success, the number of events generated.
On failure, -2.
@end deftypefun

@node Location accessors, Other parse status methods, Recognizer life cycle mutators, Recognizer methods
@section Location accessors

@deftypefun Marpa_Earleme marpa_r_earleme ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{set_id})

In the default, token-stream model, Earley set ID and earleme
are always equal, but this is not the case in other input
models.
(The ID of an Earley set ID is also called its ordinal.)
If there is no Earley set whose ID is
@var{set_id},
@code{marpa_r_earleme()} fails.
If @var{set_id} was negative,
the error code is set to
@code{MARPA_ERR_INVALID_LOCATION}.
If @var{set_id} is greater than the ordinal
of the latest Earley set,
the error code is set to
@code{MARPA_ERR_NO_EARLEY_SET_AT_LOCATION}.

At this writing, there is no method for
the inverse operation (conversion of an earleme to an Earley set
ID).
One consideration in writing
such a method is that not all earlemes correspond to Earley sets.
Applications using the standard input model
can take advantage of the exact equivalence of Earley set
ID's and earlemes in that model.
Other applications may need to create an ID-to-earleme
array using the @code{marpa_r_earleme()} method,
and invert it themselves.

Return value:
On success,
the earleme corresponding to Earley
set @var{set_id}.
On failure, -2.
@end deftypefun

@deftypefun @code{unsigned int} marpa_r_current_earleme (Marpa_Recognizer @var{r})
Return value: If input has started, the current earleme.
If input has not started, -1.
Always succeeds.
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_latest_earley_set (Marpa_Recognizer @var{r})
The value of the latest earleme can be found by converting ID using
the @code{marpa_r_earleme()} method.

Return value: On success, the ID of the latest earley set.
Always succeeds.
@end deftypefun

@deftypefun @code{unsigned int} marpa_r_furthest_earleme (Marpa_Recognizer @var{r})
Return value: On success, the furthest earleme.
Always succeeds.
@end deftypefun

@node Other parse status methods,  , Location accessors, Recognizer methods
@section Other parse status methods

@deftypefun int marpa_r_earley_item_warning_threshold (Marpa_Recognizer @var{r})
@deftypefunx int marpa_r_earley_item_warning_threshold_set (Marpa_Recognizer @var{r}, @
    int @var{threshold})
These methods, respectively, report and set the earley item warning threshold.
The @dfn{Earley item warning threshold}
is a number that is compared with
the count of Earley items in each Earley set.
When it is matched or exceeded,
a @code{MARPA_EVENT_EARLEY_ITEM_THRESHOLD} event is created.

If @var{threshold} is zero or less,
an unlimited number of Earley items
will be allowed without warning.
This will rarely be what the user wants.
By default, Libmarpa calculates a value based on the grammar.
The formula Libmarpa uses is the result of some experience,
and most applications will
be happy with it.

Return value:
The value that the Earley item warning threshold has
after the method call is finished.
Always succeeds.
@end deftypefun

@deftypefun int marpa_r_terminals_expected ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Symbol_ID* @var{buffer})
Returns a list of the ID's of the symbols
which are acceptable as tokens
at the current earleme.
@var{buffer} is expected to be large enough to hold
the result.
This is guaranteed to be the case if the buffer
is large enough to hold a number of
@code{Marpa_Symbol_ID}'s that
is greater than or equal to the number of symbols
in the grammar.

Return value:  On success, the number of @code{Marpa_Symbol_ID}'s
in @var{buffer}.
On failure, -2.
@end deftypefun

@deftypefun int marpa_r_is_exhausted (Marpa_Recognizer @var{r})
A parser is ``exhausted'' if it cannot accept any more input.
Both successful and failed parses can be exhausted.
In many grammars,
the parse is always exhausted as soon as it succeeds.
And even if the parse is exhausted at a point
where there is no good parse,
there may be good parses at earlemes prior to the
earleme at which the parse became exhausted.

Return value:
1 if the parser is exhausted, 0 otherwise.
Always succeeds.
@end deftypefun

@node Progress reports, Bocage methods, Recognizer methods, Top
@chapter Progress reports

An important advantage of the Marpa algorithm is the ability
to easily get full information about the state of the parse
so far.
Only one progress report can be in use at any one time.
To start a progress report,
use the @code{marpa_r_progress_report_start()} command.

To get the information in a progress report,
step through its items with
the @code{marpa_r_progress_item()} method.

To destroy a progress report,
freeing the memory it uses,
call the @code{marpa_r_progress_report_finish()} method.

@deftypefun int marpa_r_progress_report_start ( @
  Marpa_Recognizer @var{r}, @
  Marpa_Earley_Set_ID @var{set_id})
Initializes a report of the progress at Earley set @var{set_id}
for recognizer @var{r}.
If a progress report already exists, it is destroyed and its
memory is freed.
Initially,
the progress report is positioned before its first item.

If no Earley set with
@var{set_id} as its ID,
@code{marpa_r_progress_report_start} fails.
The error code is @code{MARPA_ERR_INVALID_LOCATION} if @var{set_id}
is negative.
The error code is @code{MARPA_ERR_NO_EARLEY_SET_AT_LOCATION}
if @var{set_id} is greater than the ID of the 
the latest Earley set.

Return value: On success, the number of report items available.
If the recognizer has not been started,
if @var{set_id} does not exist
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_r_progress_report_finish ( @
  Marpa_Recognizer @var{r} )
Destroys the report of the progress at Earley set @var{set_id}
for recognizer @var{r},
freeing the memory and other resources.
It is often not necessary to call this method.
Any previously existing progress report
is destroyed automatically
whenever a new progress report is started,
and when the recognizer is destroyed.

Return value: -2 if no progress report has been started,
or on other failure.
On success, a non-negative value.
@end deftypefun

@deftypefun Marpa_Rule_ID marpa_r_progress_item ( @
  Marpa_Recognizer @var{r}, @
  int* @var{position}, @
  Marpa_Earley_Set_ID* @var{origin} )
This method allows access to the data
for the next item of a
progress report.
If there are no more progress report items,
it returns -1 as a termination indicator
and sets the error code to @code{MARPA_ERR_PROGRESS_REPORT_EXHAUSTED}.
Either the termination indicator,
or the item count returned by
@code{marpa_r_progress_report_start()},
can be used to determine when the last
item has been seen.

On success,
the dot position is returned in the location
pointed to by @var{position},
and the origin is returned in the location
pointed to by @var{origin}.
On failure, the locations pointed to by
@var{position} and @var{origin}
are unchanged.

Return value: On success, the rule ID of
the next progress report item.
If there are no more progress report items, -1.
If either @var{position} or @var{origin} is @code{NULL},
or on other failure, @code{-2}.
@end deftypefun

@node Bocage methods, Ordering methods, Progress reports, Top
@chapter Bocage methods

@menu
* Bocage overview::             
* Bocage reference counting::   
@end menu

@node Bocage overview, Bocage reference counting, Bocage methods, Bocage methods
@section Overview

As a byproduct of recognition,
the recognizer has tables.
Before parsing, an archtypal application must create
a bocage.
A bocage is structure containing all the parses found
for the input.

Because Libmarpa parses ambiguous grammars, the bocage may
contain many parses.
(For those familiar with them, a bocage is
a specialized and extended parse forest.)

To create a bocage, use the @code{marpa_b_new()} method.
When a recognizer is no longer in use, its memory can be freed
using the 
@code{marpa_b_unref()} method.

@deftypefun Marpa_Bocage marpa_b_new (Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{earley_set_ID})

Creates a new bocage object, with a reference count of 1.
The reference count of its parent recognizer object, @var{r},
is increased by 1.
If there is no parse ending at Earley set @var{earley_set_ID},
@code{marpa_b_new} fails.
The error code is set to
@code{MARPA_ERR_NO_PARSE}.

Return value: On success, the new bocage object.
On failure, returns @code{NULL}.
@end deftypefun

@deftypefun Marpa_Grammar marpa_b_g (Marpa_Bocage @var{b})
Return value: The base grammar of @var{b}.
Always succeeds.
@end deftypefun

@node Bocage reference counting,  , Bocage overview, Bocage methods
@section  Reference counting
@deftypefun Marpa_Bocage marpa_b_ref (Marpa_Bocage @var{b})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{b}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_b_unref (Marpa_Bocage @var{b})
Decreases the reference count by 1,
destroying @var{b} once the reference count reaches
zero.
When @var{b} is destroyed, the reference count
of its parent recognizer is decreased by 1.
It this takes the reference count of the parent recognizer
to zero, it too is destroyed.
If the parent recognizer is destroyed, the reference count
of its base grammar is decreased by 1.
It this takes the reference count of the base grammar
to zero, it too is destroyed.

@end deftypefun

@node Ordering methods, Tree methods, Bocage methods, Top
@chapter Ordering methods

@menu
* Ordering overview::           
* Ordering constructor::        
* Ordering reference counting::  
@end menu

@node Ordering overview, Ordering constructor, Ordering methods, Ordering methods
@section Overview

Before iterating the parses in the bocage,
they must be ordered.
To create an ordering, use the @code{marpa_o_new()} method.
When an ordering is no longer in use, its memory can be freed
using the 
@code{marpa_o_unref()} method.

An ordering is @dfn{frozen} once the first
tree iterator is created
using it.
A frozen ordering cannot be changed.

As of this writing, the only methods to order parses
are internal and undocumented.
This is expected to change in the near future.

@node Ordering constructor, Ordering reference counting, Ordering overview, Ordering methods
@section Creating an ordering

@deftypefun Marpa_Order marpa_o_new ( @
    Marpa_Bocage @var{b})
Creates a new ordering object, with a reference count of 1.
The reference count of its parent bocage object, @var{b},
is increased by 1.

Return value: On success, the new ordering object.
On failure, @code{NULL}.
@end deftypefun

@deftypefun Marpa_Grammar marpa_o_g ( @
    Marpa_Order @var{o})
Return value: The base grammar of @var{o}.
Always succeeds.
@end deftypefun

@node Ordering reference counting,  , Ordering constructor, Ordering methods
@section Reference counting

@deftypefun Marpa_Order marpa_o_ref ( @
    Marpa_Order @var{o})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{o}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_o_unref ( @
    Marpa_Order @var{o})
Decreases the reference count by 1,
destroying @var{o} once the reference count reaches
zero.
Beginning with @var{o}'s parent bocage,
Libmarpa then proceeds up the chain of parent objects.
Every time a child is destroyed, the
reference count of its parent is decreased by 1.
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed.
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

@end deftypefun

@node Tree methods, Value methods, Ordering methods, Top
@chapter Tree methods

@menu
* Tree overview::               
* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              
@end menu

@node Tree overview, Tree constructor, Tree methods, Tree methods
@section Overview

Once the bocage has an ordering, the parses trees can be iterated.
Marpa's @dfn{parse tree iterators} iterate the parse trees contained
in a bocage object.
In Libmarpa,
``parse tree iterators'' are usually just called @dfn{trees}.

To create a tree, use the @code{marpa_t_new()} method.
When a tree is no longer in use, its memory can be freed
using the 
@code{marpa_t_unref()} method.

To position a new tree iterator to the first parse tree,
use the @code{marpa_t_next()} method.
To step through subsequent parse trees,
use the @code{marpa_t_next()} method.

@node Tree constructor, Tree reference counting, Tree overview, Tree methods
@section Creating a new tree iterator

@deftypefun Marpa_Tree marpa_t_new (Marpa_Order @var{o})
Creates a new tree iterator, with a reference count of 1.
The reference count of its parent ordering object, @var{o},
is increased by 1.

When initialized, a tree iterator is positioned
before the first parse tree.
To position the tree iterator to the first parse,
the application must call @code{marpa_t_next()}.

Return value:  On success, a newly created tree.
On failure, returns @code{NULL} and sets the error code.
@end deftypefun

@deftypefun Marpa_Grammar marpa_t_g (Marpa_Tree @var{t})
Return value: The base grammar of @var{t}.
Always succeeds.
@end deftypefun

@node Tree reference counting, Tree iteration, Tree constructor, Tree methods
@section Reference counting

@deftypefun Marpa_Tree marpa_t_ref (Marpa_Tree @var{t})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{t}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_t_unref (Marpa_Tree @var{t})
Decreases the reference count by 1,
destroying @var{t} once the reference count reaches
zero.
Beginning with @var{t}'s parent ordering,
Libmarpa then proceeds up the chain of parent objects.
Every time a child is destroyed, the
reference count of its parent is decreased by 1.
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed.
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

@end deftypefun

@node Tree iteration,  , Tree reference counting, Tree methods
@section Iterating through the trees

@deftypefun int marpa_t_next ( @
	Marpa_Tree @var{t})
Positions @var{t} at the next parse tree
in the iteration.
Tree iterators are initialized to the position
before the first parse,
so this method must be called before creating a valuator
from a tree.

If a tree iterator is positioned after the last parse,
the tree is said to be ``exhausted''.
A tree iterator for a bocage with no parse trees
is considered to be ``exhausted'' when initialized.
If the tree is exhausted, @code{marpa_t_next}
return -1 as a termination indicator,
and sets the error code to 
@code{MARPA_ERR_TREE_EXHAUSTED}.

Return value: On success, a non-negative value.
If the tree is exhausted, returns -1
On failure, -2.
@end deftypefun

@deftypefun int marpa_t_parse_count ( @
	Marpa_Tree @var{t})
The parse counter counts the number of parse trees
traversed so far.
The count includes the current iteration of the
tree, so that a value of 0 indicates that the tree iterator
is initialized to the position before the first parse tree.

Return value: The number of parses traversed so far.
Always succeeds.
@end deftypefun

@node Value methods, Events, Tree methods, Top
@chapter Value methods

@menu
* Value overview::              
* How to use the valuator::     
* Advantages of Libmarpa's valuator::  
* Details of stack manipulation::  
* Valuator constructor::        
* Valuator reference counting::  
* Registering semantics::       
* Stepping through the valuator::  
* Valuator steps by type::      
* Step accessors::              
@end menu

@node Value overview, How to use the valuator, Value methods, Value methods
@section Overview

The archetypal application needs
a value object (or @dfn{valuator}) to produce
the value of the parse.
To create a valuator, use the @code{marpa_v_new()} method.
When a valuator is no longer in use, its memory can be freed
using the 
@code{marpa_v_unref()} method.

By default, Libmarpa assumes that
non-terminal symbols have
no semantics.
The archetypal application will need to register
symbols that contain semantics.
The primary method for doing this is
@code{marpa_v_symbol_is_valued()}.
Applications registering semantics may find
it convenient to do so directly using
the @code{marpa_v_rule_is_valued()} method,
which will save them the trouble
of looking up the rule's LHS symbol.

The application is required to maintain the stack,
and the application is also required to implement
most of the semantics, including the evaluation
of rules.
Libmarpa's valuator provides instructions to
the application on how to manipulate the stack.
To iterate through this series of instructions,
use the @code{marpa_v_step()} method.

@code{marpa_v_step()} returns the type
of step.
Most step types has values associated with them.
To access these values use the methods
described in @ref{Step accessors}.
How to perform the steps is described in
@ref{How to use the valuator}
and @ref{Stepping through the valuator}.

@node How to use the valuator, Advantages of Libmarpa's valuator, Value overview, Value methods
@section How to use the valuator
Libmarpa's valuator provides the application with
``steps'', which are
instructions for stack manipulation.
Libmarpa itself does not maintain a stack.
This leaves the upper layer in total control of the
stack and the values which are placed on it.

As example may make this clearer.
Suppose the evalution is at a place in the parse tree
where an addition is being performed.
Libmarpa does not know that the operation
is an addition.
It will tell the application that rule number @math{R}
is to be applied to the arguments at stack locations
@math{N} and @math{N+1}, and that the result is to placed in
stack location @math{N}.

In this system
the application keeps track of the semantics for all
rules, so it looks up rule @math{R} and determines that it
is an addition.
The application can do this by using @math{R} as an index
into an array of callbacks, or by any other method
it chooses.
Let's assume a callback implements the semantics
for rule @math{R}.
Libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations @math{N} and @math{N+1} in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let's say, 753.
Libmarpa has told the application that the result
belongs at location @math{N} in the stack,
so the application writes 753 to location @math{N}.

Since Libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers, or polymorphic objects which are
capable of being any of these things and more.

@node Advantages of Libmarpa's valuator, Details of stack manipulation, How to use the valuator, Value methods
@section Advantages of Libmarpa's valuator

This technique
hides Libmarpa's grammar rewrites from the application,
and is actually quite efficient.
Libmarpa knows which rules are sequences
and optimizes stack manipulations based on this knowledge.
Many practical grammars use long sequences heavily
and, for these,
the series of steps
suggest by Libmarpa will be significantly faster than the standard
stack evaluation algorithm in the textbooks.

To make it clear,
we are under no illusion
that direct use of Libmarpa's valuator will be found
satisfactory by most application programmers,
even in the C language.
The author certainly avoids using it directly.
Libmarpa's valuator is intended
to be used via an upper layer,
one which @strong{does} know about semantics.

To see the advantage
of isolating Libmarpa from semantics,
suppose
that Libmarpa is used as the basis
for a higher-level language which needs callbacks in that higher level language.
For generality, Libmarpa would have to deal in C callbacks,
and a middle layer would have to create C language wrappers
for the callbacks in the higher level language.
This intermixture of languages is very hard to handle,
especially when debugging.
Programmers typically react to these difficulties by
doing the minimum possible in the callbacks themselves,
and as much as possible in pre- and post-processing.
But this division of the work is usually undesirable
from other points of view,
sometimes highly so.
But the ability to debug can make the difference between
code that does work and code that does not,
and that consideration will typically trump others.

Libmarpa valuator's method of handling semantics
does well in terms of those other considerations.
Step-driven valuation may seem complex and indirect
at first, but the programmer will find that the
pushing the semantics up to a layer which knows more
about it simplifies many things.
Step-driven valuation also makes it unnecessary
to divide the logic 
between pre-processing, main processing,
and post-processing, unless the semantics
themselves suggest such an approach.
Finally, step-driven valuation
is usually slightly more efficient
when the callbacks are in C,
and is almost always significantly more efficient
when the callbacks would have to be
to a higher-level language.

@node Details of stack manipulation, Valuator constructor, Advantages of Libmarpa's valuator, Value methods
@section Details of stack manipulation

In manipulating the stack, if the application
is mantaining a conventional physical stack,
it is up
the application to ensure that all locations
that it writes to or reads from actually
exist.
In the form we have stated it,
this requirement sounds obvious,
However, the existence of unvalued symbols,
and the optimization of stack manipulations
involving them,
offers some room for surprise.
This section discusses the requirements for
safe stack manipulation in detail.

@menu
* Implications for literal stack manipulation::  
* Implications for non-literal implementations::  
@end menu

@node Implications for literal stack manipulation, Implications for non-literal implementations, Details of stack manipulation, Details of stack manipulation
@subsection Implications for literal stack manipulation

In this section,
we assume that
the application is keeping a physical stack,
and that the application is following the valuator's stack
manipulation instructions strictly and literally.
That is, when the application is told a rule's
arguments are in the locations from X to Y,
it reads locations from X to Y of a physical stack.
And when the application is told that the result
goes into stack location Z,
the application writes to location Z of a physical stack.
Many, if not most,
applications will implement their semantics
in exactly this way.

The application needs to be aware that the
valuator may ask it to read from an stack location
N, even though it was never instructed to write
to location N.
This will not be an issue if the stack is implemented as,
say, a Perl array, because Perl extends and initializes
arrays as necessary, on both read and write.
From the point of view of the programmer of a language
like Perl, therefore, the discussion
of this section will be a non-issue.

The situation for the C programmer is more complicated,
to put it mildly.
We assume the C programmer is using a dynamic array as
a stack.
Under these circumstances, a read from an never-written
location beyond the end of the array,
may cause a memory fault.
In fact, if the C programmer is following the standards,
she has to allow for ``trap values''.
That is, she must assume that uninitialized locations,
even within the
array bounds, may contain values which will cause an
abend on read.

The C programmer implementing Libmarpa semantics literally
and using a dynamic array as a stack, must ensure that
the stack is extended
@strong{and initialized to non-trap values}
before each write
and @strong{before each read}.
When implementing a rule's semantics,
it is sufficient to ensure that the rule's arguments
exist and are initialized on the stack.
The programmer is allowed to assume that stack location
for a rule's result will be at or before
the stack location of the rule's last argument.

This ``read with no previous write'' behavior occurs
because of unvalued symbols.
If a symbol is unvalued, the write to it may be
optimized away, but often the read from that location
may not be.
If the application has registered its valued symbols
properly, 
it will be indifferent to whatever value is
in the stack at the location
for the unvalued symbol.

@node Implications for non-literal implementations,  , Implications for literal stack manipulation, Details of stack manipulation
@subsection Implications for non-literal implementations

It is tempting to think there may be ways to
avoid reading never-written values
when using less-than-literal implementations.
The programmer needs to be aware that reads
beyond the end of stack are only part of the problem.
Specifically,
@itemize
@item Many of the locations of never-written values
will be within the stack.
@item Many of within-the-stack locations never written for a particular
value may have been used
for other values, and therefore will still have one
of those previous values.
@item Other never-written within-the-stack locations will never have
been written to for any value,
and therefore must be assumed by standard-conformant C code
potentially to contain trap values.
@end itemize

@node Valuator constructor, Valuator reference counting, Details of stack manipulation, Value methods
@section Creating a new valuator

@deftypefun Marpa_Value marpa_v_new ( @
    Marpa_Tree @var{t} @
)
Creates a new valuator.
The parent object of the new valuator
will be the tree iterator @var{t},
and the reference count of the new valuator will be 1.
The reference count of @var{t} is increased by 1.

The parent tree iterator is ``paused'',
so that the tree iterator
cannot move on to a new parse tree
until the valuator is destroyed.
Many valuators of the same parse tree
can exist at once.
A tree iterator is ``unpaused'' when
all of the valuators of a parse tree are destroyed.

Return value:  On success, the newly created valuator.
On failure, returns @code{NULL} and sets the error code.
@end deftypefun

@deftypefun Marpa_Grammar marpa_v_g ( @
    Marpa_Value @var{v} @
    )
Return value: The base grammar of @var{v}.
Always succeeds.
@end deftypefun

@node Valuator reference counting, Registering semantics, Valuator constructor, Value methods
@section Reference counting

@deftypefun Marpa_Value marpa_v_ref (Marpa_Value @var{v})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{v}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_v_unref ( @
    Marpa_Value @var{v})
Decreases the reference count by 1,
destroying @var{v} once the reference count reaches
zero.
Beginning with @var{v}'s parent tree,
Libmarpa then proceeds up the chain of parent objects.
Every time a child is destroyed, the
reference count of its parent is decreased by 1.
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed.
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

@end deftypefun

@node Registering semantics, Stepping through the valuator, Valuator reference counting, Value methods
@section Registering semantics

@deftypefun int marpa_v_symbol_is_valued ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid} )
@deftypefunx int marpa_v_symbol_is_valued_set ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid}, @
    int @var{value} )
These methods, respectively, report and set to @var{value}
the valued status for symbol @var{symid}.
A valued status is either 1 or 0.
A valued status of 1 indicates that the symbol is valued.
A valued status of 0 indicates that the symbol is unvalued.

If the valued status is locked,
an attempt to change to a status different from the
current one will fail.
The error code will be @code{MARPA_ERR_VALUED_IS_LOCKED}.

Return value:  On success, the valued status @strong{after}
the call.
On failure, -2.
@end deftypefun

@deftypefun int marpa_v_rule_is_valued ( @
    Marpa_Value @var{v}, @
    Marpa_Rule_ID @var{rule_id} )
@deftypefunx int marpa_v_rule_is_valued_set ( @
    Marpa_Value @var{v}, @
    Marpa_Rule_ID @var{rule_id}, @
    int @var{value} )
These methods, respectively, report and set to @var{value}
the valued status
for the LHS symbol of rule @var{rule_id}.
A valued status is either 1 or 0.
A valued status of 1 indicates that the symbol is valued.
A valued status of 0 indicates that the symbol is unvalued.

Rules have no valued status of their own.
The valued status of a rule
is always that of its LHS symbol.
These methods are conveniences -- they
save the application the trouble of looking
up the rule's LHS.

@code{marpa_v_rule_is_valued_set} fails if
@var{value} is not either 0 or 1.
It also fails if the valued status of
the LHS symbol of @var{rule_id} is locked
and @var{value} is different from its locked-in value.

Return value:  On success, the valued status of the
rule @var{rule_id}'s LHS symbol @strong{after}
the call.
On failure, -2.
@end deftypefun

@node Stepping through the valuator, Valuator steps by type, Registering semantics, Value methods
@section Stepping through the valuator

@deftypefun Marpa_Step_Type marpa_v_step ( @
    Marpa_Value @var{v})
This method ``steps through'' the valuator.
The return value is a @code{Marpa_Step_Type},
a integer which indicates the type of step.
How the application is expected to act on
each step is described below.
When the iteration through the steps is finished,
@code{marpa_v_step} returns @code{MARPA_STEP_INACTIVE}.

Return value:  On success, the type of the step
to be performed.
This will always be a non-negative number.
On failure, -2.
@end deftypefun

@node Valuator steps by type, Step accessors, Stepping through the valuator, Value methods
@section Valuator steps by type

Stack locations are non-negative integers
The bottom of the stack is location 0.
In moving from the bottom of the stack to the top,
the numbers increase.
Stack location @var{X} is said to be ``greater'' 
than stack location @var{Y} if stack location
@var{X} is closer to the top of stack than location @var{Y},
and therefore stack locations are considered greater or
lesser if the integers that represent them are
greater or lesser.

@deftypevr Macro Marpa_Step_Type MARPA_STEP_RULE
The semantics of a rule should be performed.
The application can find the value of the rule's
children in the stack locations from
@code{marpa_v_arg_0(v)}
to @code{marpa_v_arg_n(v)}.
The semantics for the rule whose ID is
@code{marpa_v_rule(v)} should be executed
on these child values,
and the result placed in
@code{marpa_v_result(v)}.
The stack location of
@code{marpa_v_result(v)} is guaranteed to
be equal to 
to @code{marpa_v_arg_n(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_TOKEN
The semantics of a non-null token should be performed.
The value of the token whose ID is
@code{marpa_v_token(v)} should be
placed in
stack location @code{marpa_v_result(v)}.
Its value will be in
@code{marpa_v_token_value(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_NULLING_SYMBOL
The semantics for a nulling symbol should be performed.
The ID of the symbol is
@code{marpa_v_symbol(v)} and its value should
be placed in
stack location @code{marpa_v_result(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_INACTIVE
The valuator has gone through all of its steps
and is now inactive.
The value of the parse will be in stack location 0.

Because of unvalued symbols,
it is quite possible for valuator to immediately
became inactive -- @code{MARPA_STEP_INACTIVE} could
be the first and last step.
For similar reasons, the application
may need, on its own initiative,
to initialize the stack
to ensure there is a stack with a location 0 --
there will not necessarily be a valuator step that
prompts to do so.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_INTERNAL1
@deftypevrx Macro Marpa_Step_Type MARPA_STEP_INTERNAL2
@deftypevrx Macro Marpa_Step_Type MARPA_STEP_TRACE
These step types are reserved for internal purposes.
@end deftypevr

@node Step accessors,  , Valuator steps by type, Value methods
@section Step accessors

Step accessors are implemented as macros.  They always succeed.

@deftypefn {Macro} Marpa_Symbol_ID marpa_v_token (Marpa_Value @var{v})
Return value: Returns the ID of the token
for the @code{MARPA_STEP_TOKEN} step.
@end deftypefn

@deftypefn {Macro} Marpa_Symbol_ID marpa_v_symbol (Marpa_Value @var{v})
Return value: Returns the ID of the symbol
for the @code{MARPA_STEP_NULLING_SYMBOL} step.
The value is always the same as that for the @code{marpa_v_token()}
macro.
@end deftypefn

@deftypefn {Macro} void* marpa_v_token_value (Marpa_Value @var{v})
Return value: Returns the integer which is (or represents)
the value of the token for the
@code{MARPA_STEP_TOKEN} step.
@end deftypefn

@deftypefn {Macro} Marpa_Rule_ID marpa_v_rule (Marpa_Value @var{v})
Return value: Returns the ID of the rule
token for the
@code{MARPA_STEP_RULE} step.
@end deftypefn

@deftypefn {Macro} int marpa_v_result (Marpa_Value @var{v})
Return the stack location where the result of the semantics
should be placed.
@end deftypefn

@deftypefn {Macro} int marpa_v_arg_0 (Marpa_Value @var{v})
For a @code{MARPA_STEP_RULE} step,
returns the stack location where the value of first child
can be found.
The value is always the same as that for the @code{marpa_v_result()}
macro.
@end deftypefn

@deftypefn {Macro} int marpa_v_arg_n (Marpa_Value @var{v})
For a @code{MARPA_STEP_RULE} step,
returns the stack location where the value of the last child
can be found.
@end deftypefn

@node Events, Error macros and code, Value methods, Top
@chapter Events

@menu
* Event codes::                 Event codes.
@end menu

@node Event codes,  , Events, Events
@section Event codes

@deftypevr Macro int MARPA_EVENT_NONE
Applications should never see this event.
Suggested message: "No event"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EXHAUSTED
The event value is undefined.
Suggested message: "Recognizer is exhausted"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EARLEY_ITEM_THRESHOLD
The event value is undefined.
Suggested message: "Too many Earley items"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_LOOP_RULES
A rule is part of a cycle.
Cycles are pathological cases of recursion,
in which the same symbol string derives itself
a potentially infinite number of times.
Nonetheless, Marpa parses in the presence of these,
and it is up to the application to treat these
as fatal errors,
something most of them will wish to do.
The value of the event is the count of loop rules.
Suggested message: "Grammar contains a infinite loop"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_COUNTED_NULLABLE
A nullable is either the separator
for, or the right hand side of a sequence.
The value of the event is the ID of the symbol.
Suggested message: "This symbol is a counted nullable"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NULLING_TERMINAL
A nulling symbol is also a terminal.
The value of the event is the ID of the symbol.
Suggested message: "This symbol is a nulling terminal"
@end deftypevr

@node Error macros and code, Design considerations, Events, Top
@chapter Error macros and code

@menu
* Methods::                     
* Error Macros::                
* External error codes::        
* Internal error codes::        
@end menu

@node Methods, Error Macros, Error macros and code, Error macros and code
@section Methods

@deftypefun Marpa_Error_Code marpa_g_error @
    ( Marpa_Grammar @var{g}, @
    const char** @var{p_error_string})
When a method fails,
this method allows the application to read
the error code.
@var{p_error_string} is reserved for use by
the internals.
Applications should set it to @code{NULL}.

Return value: The last error code from a Libmarpa method.
Always succeeds.
@end deftypefun

@deftypefun Marpa_Error_Code marpa_g_error_clear @
    ( Marpa_Grammar @var{g} )

Sets the error code
to @code{MARPA_ERR_NONE}.
Not often used,
but it now and then it can be useful
to force the error code to a known state.

Return value: @code{MARPA_ERR_NONE}.
Always succeeds.
@end deftypefun

@node Error Macros, External error codes, Methods, Error macros and code
@section Error Macros

@deftypevr Macro int MARPA_ERRCODE_COUNT
The number of error codes.
@end deftypevr

@node External error codes, Internal error codes, Error Macros, Error macros and code
@section External error codes

This section lists the external error codes.
These are the only error codes that users
of the Libmarpa external interface should ever see.
Internal error codes are in their own section.
@xref{Internal error codes}.

@deftypevr Macro int MARPA_ERR_NONE
No error condition.
The error code is initialized to this value.
Methods which do not result in failure
sometimes reset the error code to @code{MARPA_ERR_NONE}
and sometimes leave it at its current value.
Which of the two a method does is unspecified
unless explicitly stated in that method's description.
The current implementation,
for efficiency and simplicity,
will usually leave the error code as it
found it.
On the other, as stated in its description,
@code{marpa_r_alternative()}
sets the error code to @code{MARPA_ERR_NONE}
on success.
Suggested message: "No error"
@end deftypevr

@deftypevr Macro int MARPA_ERR_BAD_SEPARATOR
A separator was specified for a sequence rule,
but its ID was not that
of a valid symbol.
Suggested message: "Separator has invalid symbol ID"
@end deftypevr

@deftypevr Macro int MARPA_ERR_COUNTED_NULLABLE
A "counted" symbol was found,
that is also a nullable symbol.
A "counted" symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting occurrences of it,
which is what sequence rules do for their RHS
symbols,
becomes very difficult.
Questions of definition and
problems of implementation arise.
At a minimum, such a sequence would be wildly
ambigious.

Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in Libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
Suggested message: "Nullable symbol on RHS of a sequence rule"
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_RULE
This error indicates an attempt to add a rule which
is a duplicate of a rule already in the grammar.
Two rules are considered duplicates if

@itemize @bullet
@item
Both rules have the same left hand symbol.
@item
Both rules have the same right hand symbols in the same order.
@end itemize

This definition applies to sequence rules, as well as to ordinary rules. As a consequence, sequence rules can be considered duplicates even when they have different separators and/or different minimum counts.
Suggested message: "Duplicate rule"
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_TOKEN
This error indicates an attempt to add a duplicate token.
A token is a duplicate if one already read at the same
earleme has the same symbol ID and the same length.
Suggested message: "Duplicate token"
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_COUNT
This error code indicates that
an implementation-defined limit on the
number of earley items per Earley set
was exceedeed.
This limit is different from
the earley item warning threshold,
an optional limit on the number
of Earley items in an Earley set,
which can be set by the application.

The implementation defined-limit is very large,
at least 500,000,000 earlemes.
An application is unlikely ever to see this
error for two reasons.
First, Libmarpa's use of memory
would almost certainly exceed the implementation's
limits before it occurred.
Second, applications will almost always want
to use the earley item warning threshold to implement
a much smaller limit.
Typically, this will be under 1,000 Earley items
per Earley set.
Suggested message: "Maximum number of earley items exceeded"
@end deftypevr

@deftypevr Macro int MARPA_ERR_EVENT_IX_NEGATIVE
A negative event index was specified.
That is not allowed.
Suggested message: "Negative event index"
@end deftypevr

@deftypevr Macro int MARPA_ERR_EVENT_IX_OOB
An non-negative event index was specified,
but there is no event at that index.
Since the events are in sequence, this means it
was too large.
Suggested message: "No event at that index"
@end deftypevr

@deftypevr Macro int MARPA_ERR_I_AM_NOT_OK
The Libmarpa base grammar is in a "not ok"
state.
Currently, the only way this can happen
is if Libmarpa memory is being overwritten.
Suggested message: "Marpa is in a not OK state"
@end deftypevr

@deftypevr Macro int MARPA_ERR_GRAMMAR_HAS_CYCLE
The grammar has a cycle -- one or more loop
rules.
This is a recoverable error,
although most applications will want to treat
it as fatal.
For more see the description of @ref{marpa_g_precompute}.
Suggested message: "Grammar has cycle"
@end deftypevr

@deftypevr Macro int MARPA_ERR_INACCESSIBLE_TOKEN
This error code indicates that
indicates that
the token symbol is an inaccessible symbol -- one which
cannot be reached from the start symbol.
Since the inaccessibility of a symbol is a property of the grammar,
this error code typically indicates an application error.
A retry at this location, using another token ID,
may succeed.
At this writing,
the author knows of no uses of this technique.
Suggested message: "Token symbol is inaccessible"
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_BOOLEAN
A function was called which takes a boolean argument,
one which must be either 0 or 1,
and that argument has some other value.
Suggested message: "Argument is not boolean"
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_LOCATION
The location (Earley set ID) is not valid.
It may be invalid because it is negative,
and is not being used as an argument where
a negative Earley set ID has a special meaning.
It may be invalid because it is after the latest Earley set.

For users of input models other than the standard one,
the term ``location'', as used in association
with this error code,
means Earley set ID or Earley set ordinal.
In the standard input model, this will always
be identical with Libmarpa's other idea of
location, the earleme.
Suggested message: "Location is not valid"
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_START_SYMBOL
A start symbol was specified,
but its symbol ID is not that of a valid symbol.
Suggested message: "Specified start symbol is not valid"
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_RULE_ID
A method was called with an invalid external rule ID.
Suggested message: "No rule with that ID exists"
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_SYMBOL_ID
A method was called with an invalid external symbol ID.
Suggested message: "No symbol with that ID exists"
@end deftypevr

@deftypevr Macro int MARPA_ERR_MAJOR_VERSION_MISMATCH
There was a mismatch in the major version number
between the requested version
of libmarpa, and the actual one.
Suggested message: "Libmarpa major version number is a mismatch"

@end deftypevr
@deftypevr Macro int MARPA_ERR_MICRO_VERSION_MISMATCH
There was a mismatch in the micro version number
between the requested version
of libmarpa, and the actual one.
Suggested message: "Libmarpa micro version number is a mismatch"
@end deftypevr

@deftypevr Macro int MARPA_ERR_MINOR_VERSION_MISMATCH
There was a mismatch in the minor version number
between the requested version
of libmarpa, and the actual one.
Suggested message: "Libmarpa minor version number is a mismatch"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_EARLEY_SET_AT_LOCATION
A non-negative Earley set ID (also called an Earley set ordinal)
was specified,
but there is no corresponding Earley set.
Since the Earley set ordinals are in sequence,
this means that the specified ID is greater
than that of the latest Earley set.
Suggested message: "Earley set ID is after latest Earley set"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NOT_PRECOMPUTED
An attempt was made to use a grammar
that is not precomputed
in a way that is not allowed.
For example, a recognizer cannot be
created from a grammar until it is precomputed.
Suggested message: "This grammar is not precomputed"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_PARSE
The application attempted to create a bocage
from a recognizer without a parse.
The application will often treat this as
a soft error.
Suggested message: "No parse"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_RULES
A grammar which has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
The precomputations are not defined
for grammar without rules,
in large part because it would be useless to do so.
Suggested message: "This grammar does not have any rules"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_START_SYMBOL
The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one.
For example, no grammar without a start
symbol can be precomputed.
Suggested message: "This grammar has no start symbol"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_TOKEN_EXPECTED_HERE
This error code indicates that
in this case no tokens at all were expected at this earleme
location.
This can only happen in alternative input models.
Typically, this indicates an application programming
error.
Retrying input at this location will always fail.
But if the application is able to leave this
earleme empty, a retry at a later location,
using this or another token,
may succeed.
At this writing,
the author knows of no uses of this technique.
Suggested message: "No token is expected at this earleme location"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NULLING_TERMINAL
Marpa does not allow a symbol to be both nulling
and a terminal.
Suggested message: "A symbol is both terminal and nulling"
@end deftypevr

@deftypevr Macro int MARPA_ERR_ORDER_FROZEN
The Marpa order object has been frozen.
Multiple tree iterators can share a Marpa order object,
but that order object is @dfn{frozen} after the first tree
iterator is created from it.
If a Marpa order object is @dfn{frozen}, it cannot be
changed.
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.
Suggested message: "The ordering is frozen"
@end deftypevr

@deftypevr Macro int MARPA_ERR_PARSE_EXHAUSTED
The parse is exhausted.
Suggested message: "The parse is exhausted"
@end deftypevr

@deftypevr Macro int MARPA_ERR_PARSE_TOO_LONG
The parse is too long.
The limit on the length of a parse is implementation
dependent, but it is very large,
is at least 500,000,000 earlemes.
If an application sees this error,
it almost certainly using one of the non-standard
input models.
Most often this messsage will occur because
of a request to add a single extremely long token,
perhaps as a result of an application error.
But it is also possible this error condition will 
occur after the input of a large number
of long tokens.

This error code is unlikely in the standard input model.
Almost certainly memory would be exceeded
before it could occur.
Suggested message: "This input would make the parse too long"
@end deftypevr

@deftypevr Macro int MARPA_ERR_POINTER_ARG_NULL
In a method which takes pointers as arguments,
one of the pointer arguments is @code{NULL},
in a case where that is not allowed.
One such method is@ @code{marpa_r_progress_item()}.
Suggested message: "An argument is null when it should not be"
@end deftypevr

@deftypevr Macro int MARPA_ERR_PRECOMPUTED
An attempt was made to use a precomputed grammar
in a way that is not allowed.
After a grammar is precomputed,
any changes to it that would invalidate
the precomputation
is not allowed.
Almost all changes to a grammar invalidate
the precomputations.
Suggested message: "This grammar is precomputed"
@end deftypevr

@deftypevr Macro int MARPA_ERR_PROGRESS_REPORT_NOT_STARTED
No recognizer progress report is currently active,
and an action has been attempted which
is inconsistent with that.
One such action would be a
@code{marpa_r_progress_item()} call.
Suggested message: "No progress report has been started"
@end deftypevr

@deftypevr Macro int MARPA_ERR_PROGRESS_REPORT_EXHAUSTED
The progress report is ``exhausted'' -- all its
items have been iterated through.
Suggested message: "The progress report is exhausted"
@end deftypevr

@deftypevr Macro int MARPA_ERR_RECCE_NOT_ACCEPTING_INPUT
The recognizer is not accepting input,
and the application has attempted something that
is inconsistent with that fact.
Suggested message: "The recognizer is not accepting input"
@end deftypevr

@deftypevr Macro int MARPA_ERR_RECCE_NOT_STARTED
The recognizer has not been started.
and the application has attempted something that
is inconsistent with that fact.
Suggested message: "The recognizer has not been started"
@end deftypevr

@deftypevr Macro int MARPA_ERR_RECCE_STARTED
The recognizer has been started.
and the application has attempted something that
is inconsistent with that fact.
Suggested message: "The recognizer has been started"
@end deftypevr

@deftypevr Macro int MARPA_ERR_RHS_IX_NEGATIVE
The index of RHS symbol was specified,
but it was negative.
That is not allowed.
Suggested message: "RHS index cannot be negative"
@end deftypevr

@deftypevr Macro int MARPA_ERR_RHS_IX_OOB
A non-negative index of RHS symbol was specified,
but there is no symbol at that index.
Since the indexes are in sequence, this means the
index was greater than or equal to the rule length.
Suggested message: "RHS index must be less than rule length"
@end deftypevr

@deftypevr Macro int MARPA_ERR_RHS_TOO_LONG
An attempt was made to add a rule with too many
right hand side symbols.
The limit on the RHS symbol count is implementation
dependent, but it is very large,
is at least 500,000,000.
This is
far beyond that required in any current practical grammar.
An application with rules of this length is almost
certain to run into memory and other limits.
Suggested message: "The RHS is too long"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE
The LHS of a
sequence rule cannot be the LHS of any other rule,
whether a sequence rule or a BNF rule.
An attempt was made to violate this restriction.
Suggested message: "LHS of sequence rule would not be unique"
@end deftypevr

@deftypevr Macro int MARPA_ERR_START_NOT_LHS
The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Start symbol not on LHS of any rule"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SYMBOL_VALUED_CONFLICT
An unvalued symbol may take on any value,
and therefore a symbol which is unvalued at some points
cannot safely to be used to contain a value at
others.
This error indicates that such an unsafe use is
being attempted.
Suggested message: "Symbol is treated both as valued and unvalued"
@end deftypevr

@deftypevr Macro int MARPA_ERR_TERMINAL_IS_LOCKED
An attempt was made to change the terminal status
of a symbol to a different value
after it was locked.
Suggested message: "The terminal status of the symbol is locked"
@end deftypevr

@deftypevr Macro int MARPA_ERR_TOKEN_IS_NOT_TERMINAL
A token was specified whose symbol ID is not
a terminal.
Suggested message: "Token symbol must be a terminal"
@end deftypevr

@deftypevr Macro int MARPA_ERR_TOKEN_LENGTH_LE_ZERO
A token length was specified which is less than
or equal to zero.
Zero-length tokens are not allowed in Libmarpa.
Suggested message: "Token length must greater than zero"
@end deftypevr

@deftypevr Macro int MARPA_ERR_TOKEN_TOO_LONG
The token length is too long.
The limit on the length of a token
is implementation dependent, but it
is at least 500,000,000.
An application using a token that long
is almost certain to run into some other
limit.
Suggested message: "Token is too long"
@end deftypevr

@deftypevr Macro int MARPA_ERR_TREE_EXHAUSTED
A Libmarpa parse tree iterator
is ``exhausted'', that is,
it has no more parses.
Suggested message: "Tree iterator is exhausted"
@end deftypevr

@deftypevr Macro int MARPA_ERR_TREE_PAUSED
A Libmarpa tree is ``paused''
and an operation was attempted which
is inconsistent with that face.
Typically, this operation will be
a call of the @code{marpa_t_next()} method.
Suggested message: "Tree iterator is paused"
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNEXPECTED_TOKEN_ID
An attempt was made to read a token
where a token with that symbol ID is not
expected.
This message will also occur when an
attempt is made to read a token
at a location where no token is expected.
Suggested message: "Unexpected token"
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNPRODUCTIVE_START
The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Unproductive start symbol"
@end deftypevr

@deftypevr Macro int MARPA_ERR_VALUATOR_INACTIVE
The valuator is inactive in a context where that
should not be the case.
Suggested message: "Valuator inactive"
@end deftypevr

@deftypevr Macro int MARPA_ERR_VALUED_IS_LOCKED
The valued status of a symbol is locked,
and an attempt was made 
to change it to a status different from the
current one.
Suggested message: "The valued status of the symbol is locked"
@end deftypevr

@node Internal error codes,  , External error codes, Error macros and code
@section Internal error codes

An internal error code may be one of two things:
First,
it can be an error code which
arises from an internal Libmarpa programming issue
(in other words, something happening in the code
that was not supposed to be able to happen.)
Second, it can be an error code which only occurs
when a method from Libmarpa's internal interface
is used.
Both kinds of internal error message share one common
trait -- users of the Libmarpa's external interface
should never see them.

Internal error messages
require someone with knowledge of the Libmarpa internals
to follow up on them.
They usually do not have descriptions or suggested messages.

@deftypevr Macro int MARPA_ERR_AHFA_IX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_AHFA_IX_OOB
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NOT_IN_OR
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDIX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_BOCAGE_ITERATION_EXHAUSTED
@end deftypevr

@deftypevr Macro int MARPA_ERR_DEVELOPMENT
"Development" errors were used heavily during
Libmarpa's development,
when it is not yet clear how precisely
to classify every error condition.
Users of the external interface in released
non-developer's versions should never
see development errors.

Development errors has an error string
associated with them.
The error string is a
short 7-bit ASCII error string
which describes the error.
Suggested message: "Development error, see string"
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_AND_NODE
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_ID_INVALID
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL
A ``catchall'' internal error.
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_AHFA_ID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_AIMID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_IRLID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_ISYID
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOOKID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_COMPLETION_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_LEO_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_TOKEN_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_AND_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_OR_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_ES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_PIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_EIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_SRCL
@end deftypevr

@deftypevr Macro int MARPA_ERR_ORID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_OR_ALREADY_ORDERED
@end deftypevr

@deftypevr Macro int MARPA_ERR_PIM_IS_NOT_LIM
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_NONE
@end deftypevr
@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_TOKEN
@end deftypevr
@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_COMPLETION
@end deftypevr
@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_LEO
@end deftypevr
@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_AMBIGUOUS
@end deftypevr
@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_UNKNOWN
@end deftypevr
@node Design considerations, Things To Do, Error macros and code, Top
@chapter Design considerations

This section details some of the design choices
in Libmarpa.

@menu
* Why so many time objects::    
* Design of numbered objects::  
@end menu

@node Why so many time objects, Design of numbered objects, Design considerations, Design considerations
@section Why so many time objects?

Readers accustomed to other appraoches to parsing,
particular those in fashion at this writing,
may wonder on the number of time objects
in the Marpa architecture.
Several of Marpa's time objects (bocages,
orderings and trees) are required
because Marpa allows,
and offers powerful tools for dealing with,
ambigious grammars.

It may seem, then, that users of unambiguous grammars,
are paying a considerable price in time effiency
for the ability to parse
ambiguous ones.
This is not the case.
In the trivial case, the cost of the orderings
object is a single, very brief, subroutine call.

Bocage objects come at minimal cost,
because the same pass which creates the bocage
also deals with other issues which are of major
significance even for unambiguous parses.
The same pass which creates the bocage
enables Marpa to do both left-
and right-recursion in linear time.

Tree objects come at mininal cost to unambiguous grammars,
because the same pass that allows iteration through multiple
parse trees does the tree traversal, so that the valuation time object
has very litle to do -- it just steps through the sequence.

But what about the many passes over the data this requires?
Marpa is an aggressively multi-pass algorithm.
Marpa achieves its efficiency,
not in spite of making multiple
passes over the data, but because of it.
Marpa is @math{O(n)} for LR-regular grammars,
both in theory and in implementation,
because Marpa regularly substitutes
two fast @math{O(n)} passes for a single
@math{O(n log n)} pass.

@menu
* Why ordering objects?::       
@end menu

@node Why ordering objects?,  , Why so many time objects, Why so many time objects
@subsection Why ordering objects?

Of the various objects, the best
case for elimination is of the
ordering object.
In many cases, the ordering is trivial.
Either the parse is unambiguous, or the
application does not care about the order in
which parses are returned.

But while it would be easy to add an option
to bypass creation of an ordering object,
there is little to be gained from it.
When the ordering is trivial,
its overhead is very small --
essentially a handful of subroutine calls.
Many orderings accomplish nothing,
but these cost next to nothing.

@node Design of numbered objects,  , Why so many time objects, Design considerations
@section Numbered objects

As the name suggests,
the choice was made to implement
numbered objects and not as
pointers.
Integers can be easily and safely checked for validity,
while pointer cannot.

There are efficiency tradeoffs between pointers and
integers but they are complications and go both ways.
Pointers can be faster, but integers can be used
as indexes into more than one data structure.
Which is actually faster depends on the design.
Integers allow for a more flexible design,
so that once the choice is settled on,
careful programming can make them a win,
possibly a very big one.

The approach taken in Libmarpa was to settle
from the outset,
on integers as the implementation for numbered
objects and optimize on that basis.
In any case, the difference is speed on
modern architectures is
a small price to pay for
safe, portable validity checking.

@node Things To Do, Internal Interface, Design considerations, Top
@chapter Things to do

@itemize
@item
There should be an interface in the valuator that allows the user to
determine the start and end earlemes of a token.
@end itemize

@node Internal Interface,  , Things To Do, Top
@chapter Internal Interface

Internal methods are only for testing and development of libmarpa.
They are listed here (and sometimes described) for the convenience
of those working on libmarpa's internals.

Internal methods are subject to change.
Applications should not use internal methods.
If a description exists and might be helpful,
it may be included below,
but all applications
should treat these methods as ``undocumented''.

@menu
* Symbol internal methods::     
* Rule internals::              
* Grammar internals::           
* Recognizer internals::        
* Bocage internals::            
* Ordering internals::          
* Tree internals::              
* Valuator internals::          
@end menu

@node Symbol internal methods, Rule internals, Internal Interface, Internal Interface
@section Symbol internal methods

@deftypefun int _marpa_g_rule_first_child_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
If the desired semantics is simply
to return the first child as the value
(not an uncommon case)
Marpa could implement that as a stack no-op.
This stub may become part of the external interface
at some point,
once I fully work out the implications
of "first child" semantics.
@end deftypefun

@deftypefun int _marpa_g_isy_is_start ( Marpa_Grammar @var{g}, @
    Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_is_nulling ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_is_lhs ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun Marpa_ISY_ID _marpa_g_xsy_nulling_isy ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_ISY_ID _marpa_g_xsy_isy ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_symbol_proper_alias ( @
  Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_symbol_null_alias ( @
  Marpa_Grammar @var{g}, @
  Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun int _marpa_g_symbol_is_semantic ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_source_xsy ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_isy_lhs_xrl ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_xrl_offset ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id} )
@end deftypefun

@node Rule internals, Grammar internals, Symbol internal methods, Internal Interface
@section Rule internals

@deftypefun int marpa_g_rule_is_keep_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
This function does nothing but return an undocumented flag.
At some point,
I may optimize cases where separators are discarded,
in which case this flag will be used.
I may also remove this call entirely.
Return value:
Returns 1 if
the keep separation flag is set,
0 if not.
Returns 0 if
@var{rule_id} is not a sequence rule.
On failure, returns -2.
@end deftypefun

@deftypefun int _marpa_g_isy_count ( @
  Marpa_Grammar @var{g})
@end deftypefun
@deftypefun int _marpa_g_irl_count ( @
  Marpa_Grammar @var{g})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
Return value: On success, the LHS symbol of the IRL.
On failure, -2.
@end deftypefun

@deftypefun int _marpa_g_irl_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
The length of a IRL is the number of symbols on its RHS.

Return value: On success, the IRL length.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_rhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id}, @
    int @var{ix})
The position in the IRL, @var{ix}, is zero-based.
If @var{ix} is greater than or equal the length of the
IRL, it is a soft failure.
This can be used in loops, to avoid having to determine
the IRL's length explicitly.

Return value: On success, the symbol in position @var{ix}
on the IRL's RHS.
If @var{ix} is greater than or equal to the length of
the IRL, -1.
On other failures, -2.
@end deftypefun
@deftypefun int _marpa_g_rule_is_used (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_lhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_rhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun @code{unsigned int} _marpa_g_virtual_start (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun @code{unsigned int} _marpa_g_virtual_end (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_source_xrl (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_real_symbol_count (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_irl_semantic_equivalent (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun

@node Grammar internals, Recognizer internals, Rule internals, Internal Interface
@section Grammar internal methods

The methods in this section are accessors for Libmarpa's
AHFA items and states.
Their use requires familiarity with
Marpa's internals, as described in
@cite{Marpa: The Program}.

@deftypefun int _marpa_g_AHFA_item_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_AHFA_item_irl (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_position (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_item_postdot (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_sort_key (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_item_count (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_AHFA_Item_ID _marpa_g_AHFA_state_item (Marpa_Grammar @var{g}, @
     Marpa_AHFA_State_ID @var{AHFA_state_id}, @
 int @var{item_ix})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_is_predict (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_state_leo_lhs_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_transitions ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id}, @
    int *@var{buffer}, @
    int @var{buffer_size} @
    )
@end deftypefun
@deftypefun Marpa_AHFA_State_ID _marpa_g_AHFA_state_empty_transition ( @
    Marpa_Grammar @var{g}, @
     Marpa_AHFA_Item_ID @var{AHFA_item_id})
@end deftypefun

@node Recognizer internals, Bocage internals, Grammar internals, Internal Interface
@section Recognizer internals


@deftypefun int _marpa_r_is_use_leo (Marpa_Recognizer @var{r})
@deftypefunx int _marpa_r_is_use_leo_set ( Marpa_Recognizer @var{r}, @
    int @var{value})
Reports and sets, respectively, the ``use Leo'' flag.
This flag controls whether Joop Leo's method for fast parsing
of right recursion is used.
By default, this value is 1 and Leo parsing is in use.
This default should be used except for testing, debugging
and development.
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_trace_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int _marpa_r_earley_set_size (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_Earleme _marpa_r_earley_set_trace (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_earley_item_trace (Marpa_Recognizer r, Marpa_Earley_Item_ID @var{item_id})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_earley_item_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_leo_predecessor_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_leo_base_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_leo_base_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_leo_expansion_ahfa (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_postdot_symbol_trace (Marpa_Recognizer r, Marpa_Symbol_ID @var{symid})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_postdot_item_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_source_predecessor_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_source_token (Marpa_Recognizer r, int *@var{value_p})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_source_leo_transition_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_source_middle (Marpa_Recognizer @var{r})
@end deftypefun

@node Bocage internals, Ordering internals, Recognizer internals, Internal Interface
@section Bocage internals

@deftypefun int _marpa_b_and_node_count ( @
    Marpa_Bocage @var{b})
@end deftypefun
@deftypefun int _marpa_b_and_node_parent ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_predecessor ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_cause ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_symbol ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_b_and_node_token ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id}, @
    int* @var{value_p})

Returns the data for the token of the and-node.
The symbol id is the return value,
and the token value is placed
in the location pointed
to by @var{value_p}, if that is non-null.
If @var{and_node_id} is not the ID of an and-node
whose cause is a token,
returns -1,
without changing @var{value_p}.
On failure, returns -2 without changing
@var{value_p}.

There is no function to simply return the token value --
because of the need to indicate errors, it is just as
easy to return the symbol ID as well.
@end deftypefun
@deftypefun Marpa_Or_Node_ID _marpa_b_top_or_node ( @
    Marpa_Bocage @var{b})

Return the ID of the top or-node.
@end deftypefun
@deftypefun int _marpa_b_or_node_set ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})

Return the ordinal of the current (final) Earley set of
the or-node.
@end deftypefun
@deftypefun int _marpa_b_or_node_origin ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun Marpa_IRL_ID _marpa_b_or_node_irl ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_position ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_first_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_last_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_and_count ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@node Ordering internals, Tree internals, Bocage internals, Internal Interface
@section Ordering internals

@deftypefun int _marpa_o_and_order_set ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    Marpa_And_Node_ID* @var{and_node_ids}, @
    int @var{length})
@end deftypefun

@deftypefun Marpa_And_Node_ID _marpa_o_and_order_get ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    int @var{ix})
@end deftypefun

@node Tree internals, Valuator internals, Ordering internals, Internal Interface
@section Tree internals

In Marpa, a nook is any node of a parse tree.
The usual term is "node",
but within Marpa,
the word "node" is already heavily overloaded.
So what most texts call "tree nodes" are here
called "nooks".
"Nook" can be thought of as a pun on both
"node" and "fork".

@deftypefun int _marpa_t_size ( @
	Marpa_Tree @var{t})
Return the size of the parse tree.
This is the number of nooks in its stack.
If there is a serious error,
or if the tree is uninitialized, return -2.
If the tree is exhausted, return -1.
@end deftypefun

@deftypefun Marpa_Or_Node_ID _marpa_t_nook_or_node ( @
    Marpa_Tree @var{t}, @
    Marpa_Nook_ID @var{nook_id})

Return the ID of the or-node for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_choice ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the current choice for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_parent ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the parent nook's ID for @var{nook_id}.
As with the other nook trace functions,
-1 is returned if @var{nook_id} is not the ID of
a nook on the stack,
but -1 can also be a valid value.
If that's an issue, the @var{nook_id} needs
to be checked with one of the trace functions
where -1 is never a valid value ---
for example, @code{_marpa_t_nook_or_node}.
@end deftypefun

@deftypefun int _marpa_t_nook_cause_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the cause-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_predecessor_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the predecessor-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_cause ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-cause bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_predecessor ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-predecessor bit for @var{nook_id}.
@end deftypefun

@node Valuator internals,  , Tree internals, Internal Interface
@section Valuator internals

@deftypefun int _marpa_v_trace ( @
    Marpa_Value @var{v}, @
    int @var{flag})
@end deftypefun

@deftypefun Marpa_Nook_ID _marpa_v_nook ( @
    Marpa_Value @var{v})
@end deftypefun

@bye
