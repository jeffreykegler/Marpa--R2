#!/usr/bin/perl
# Copyright 2012 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

use 5.010;
use strict;
use warnings;
use English qw( -no_match_vars );
use Marpa::R2::HTML;
use HTML::Tagset;
use Fatal qw(open close);
use Getopt::Long;

sub usage 
{
    say STDERR "$PROGRAM_NAME html_fmt [uri|file]";
    exit 1;
}

my $data = "file.dat";
my $length = 24;
my $help_flag = 0;
usage() if not GetOptions ( "help" => \$help_flag);
usage() if $help_flag or scalar @ARGV > 1;

my %inline_tag = map { $_, 1 } qw(
    A ABBR ACRONYM B BASEFONT BDO BIG BR CITE CODE DFN EM FONT I IMG
    INPUT KBD LABEL Q S SAMP SELECT SMALL SPAN STRIKE STRONG SUB SUP
    TEXTAREA TT U VAR);

my $locator = shift;
my $document;
GET_DOCUMENT: {
    if ( not defined $locator ) {
        local $RS = undef;
        $document = <STDIN>;
        last GET_DOCUMENT;
    }
    if ( $locator =~ /^[a-zA-Z0-9]+[:]/ ) {
        require WWW::Mechanize;
        my $mech = WWW::Mechanize->new( autocheck => 1 );
        $mech->get($locator);
        $document = $mech->content;
        undef $mech;
        last GET_DOCUMENT;
    } ## end if ( $locator =~ /^[a-zA-Z0-9]+[:]/ )
    {
        local $RS = undef;
        open my $fh, q{<}, $locator;
        $document = <$fh>;
        close $fh;
    }
} ## end GET_DOCUMENT:

sub output_messages {
    my $result = q{};
    my ( $indent, $messages ) = @_;
    if ( $indent > 0 ) {
        my $indentation .= q{  } x $indent;
        while ( my $message = shift @{$messages} ) {
            $result .= $indentation . '<!-- ' . $message . " -->\n";
        }
    } ## end if ( $indent > 0 )
    return $result;
} ## end sub output_messages

sub post_process {
    my ($value) = @_;
    my @text_pieces = ();
    DATUM: for my $line_data ( @{ $value->[0] } ) {
        my ( $type, $indent ) = @{$line_data};
        if ( $type eq 'text' ) {
            my $text = $line_data->[2];
            my $has_trailing_ws = $text =~ s/ \s+ \z//xms;
            if ( $text =~ s/ \A \s+ //xms ) {
                push @text_pieces, [ 'whitespace', $indent ];
            }
            my @lines = grep { $_ =~ /\S/xms } split /\n/xms, $text;
            for my $line_no ( 0 .. $#lines ) {
                my $line = $lines[$line_no];
                $line =~ s/\A[ \t]+//xms;
                $line =~ s/[ \t]+\z//xms;
                $line =~ s/[ \t]+/ /xms;
                push @text_pieces, [ 'whitespace', $indent ] if $line_no;
                push @text_pieces, [ 'text', $indent, $line ];
            } ## end for my $line_no ( 0 .. $#lines )
            push @text_pieces, [ 'whitespace', $indent ] if $has_trailing_ws;
            next DATUM;
        } ## end if ( $type eq 'text' )
        if ( $type eq 'msg: missing start tag' ) {
            my $location = $line_data->[2];
            my $tagname  = $line_data->[3];
            given ($location) {
                when ('preceeding') {
                    push @text_pieces,
                        [
                        'comment',
                        $indent + 1,
                        'Preceeding start tag is replacement for a missing one'
                        ];
                } ## end when ('preceeding')
                when ('following pre') {
                    push @text_pieces,
                        [
                        'comment', $indent,
                        "Inside following <pre>, a start tag is missing: <$tagname>"
                        ];
                } ## end when ('following pre')
                default {
                    Carp::croak(
                        "Internal error: unprovided-for missing start tag location: $_"
                    );
                }
            } ## end given
            next DATUM;
        } ## end if ( $type eq 'msg: missing start tag' )
        if ( $type eq 'msg: missing end tag' ) {
            my $location = $line_data->[2];
            my $tagname  = $line_data->[3];
            given ($location) {
                when ('following') {
                    push @text_pieces,
                        [
                        'comment',
                        $indent + 1,
                        'Following end tag is replacement for a missing one'
                        ];
                } ## end when ('following')
                when ('following pre') {
                    push @text_pieces,
                        [
                        'comment', $indent,
                        "Inside following <pre>, an end tag is missing: <$tagname>"
                        ];
                } ## end when ('following pre')
                default {
                    Carp::croak(
                        "Internal error: unprovided-for missing end tag location: $_"
                    );
                }
            } ## end given
            next DATUM;
        } ## end if ( $type eq 'msg: missing end tag' )
        if ( $type eq 'msg: cruft' ) {
            my $location = $line_data->[2];
            my $cruft    = $line_data->[3];
            given ($location) {
                when ('following') {
                    push @text_pieces,
                        [ 'comment', $indent, 'Next line is cruft' ];
                }
                when ('following pre') {

                    # Make sure the cruft quoted inside
                    # the HTML comment does not
                    # disrupt the comment.
                    ( my $safe_cruft = $cruft ) =~ s/--/- -/xms;
                    push @text_pieces,
                        [
                        'comment', $indent,
                        qq{Inside the following <pre>, there is this cruft:\n$safe_cruft}
                        ];
                } ## end when ('following pre')
                default {
                    Carp::croak(
                        "Internal error: unprovided-for cruft location: $_");
                }
            } ## end given
            next DATUM;
        } ## end if ( $type eq 'msg: cruft' )
        push @text_pieces, [ $type, $indent, $line_data->[2] ];
    } ## end DATUM: for my $line_data ( @{ $value->[0] } )
    my @ws_unsafe;
    $ws_unsafe[scalar @text_pieces] = 0; # size the array
    my $last_non_comment_ix = scalar @text_pieces;
    my $safe_after_piece = 0;
    TEXT_PIECE: for my $text_piece_ix ( 0 .. $#text_pieces ) {
        my ( $type, $indent, $text ) = @{ $text_pieces[$text_piece_ix] };
        my $safe_before_piece = 0;
        WHITESPACE_BY_TYPE: {

            # If a comment, after-piece is whatever current value
            # of $safe_after_piece,
            # leave before as-is
            last WHITESPACE_BY_TYPE if $type eq 'comment';
            if ( $type eq 'whitespace' ) {

                # Safe before and after other whitespace
                $safe_before_piece = $safe_after_piece = 1;
                last WHITESPACE_BY_TYPE;
            } ## end if ( $type eq 'whitespace' )
            if ( $type eq 'end tag' ) {

                # Unsafe after an end tag, but safe before it
                $safe_before_piece = 1;
                $safe_after_piece  = 0;
                last WHITESPACE_BY_TYPE;
            } ## end if ( $type eq 'end tag' )
            if ( $type eq 'start tag' ) {

                # Leave safe status as-is before start tag
                # Whitespace safe after a start tag
                $safe_after_piece = 1;
                last WHITESPACE_BY_TYPE;
            } ## end if ( $type eq 'start tag' )
            if ( $type eq 'text' ) {

                # Leave safe status as-is before text
                # Whitespace not safe after a start tag
                $safe_after_piece = 0;
                last WHITESPACE_BY_TYPE;
            } ## end if ( $type eq 'text' )
                # Blocks can occur inline, etc.
                # So with everything else, be conservative.
                # Whitespace is unsafe after, and left as-is before.
            $safe_after_piece = 0;
        } ## end WHITESPACE_BY_TYPE:
        $ws_unsafe[ $text_piece_ix + 1 ] = !$safe_after_piece;
        if ($safe_before_piece) {
            for my $ix ( $last_non_comment_ix + 1 .. $text_piece_ix ) {
                $ws_unsafe[$ix] = 0;
            }
        }
        $last_non_comment_ix = $text_piece_ix if $type ne 'comment';
    } ## end TEXT_PIECE: for my $text_piece_ix ( 0 .. $#text_pieces )
    $ws_unsafe[scalar @text_pieces] = 0; # EOF is whitespace safe
    my @output = ();
    TEXT_PIECE: for my $text_piece_ix ( 0 .. $#text_pieces ) {
        my ( $type, $indent, $text ) = @{ $text_pieces[$text_piece_ix] };
        next TEXT_PIECE if $type eq 'whitespace';
	my $suffix = $ws_unsafe[$text_piece_ix+1] ? '<!--' : '';
	my $indentation = q{  } x $indent;
	if ( $ws_unsafe[$text_piece_ix] ) {
	    $indentation =
		  $indentation
		. '  html_fmt: this comment is to avoid introducing whitespace'
		. "\n" . $indentation . '-->';
	} ## end if ( $ws_unsafe[$text_piece_ix] )
        if ( $type eq 'text' and $text =~ /\S/ ) {
            push @output, $indentation . $text . $suffix;
            next TEXT_PIECE;
        }
        if ( $type eq 'comment' ) {
            push @output, $indentation . '<!-- html_fmt: ' . $text . ' -->' . $suffix;
            next TEXT_PIECE;
        }
        push @output, $indentation . $text . $suffix;
    } ## end TEXT_PIECE: for my $text_piece_ix ( 0 .. $#text_pieces )
    return join "\n", @output, q{};
} ## end sub post_process

sub do_pre {
    my @new_line_data      = ();
    my @following_comments = ();
    CHILD:
    for my $value ( @{ Marpa::R2::HTML::values() } ) {
        for my $line_data ( @{$value} ) {
            if ( $line_data->[0] =~ /^msg:/ ) {
                push @new_line_data,
                    [
                    $_, 0,
                    'following pre',
                    @{$line_data}[ 3 .. $#{$line_data} ]
                    ];
            } ## end if ( $line_data->[0] =~ /^msg:/ )
        } ## end for my $line_data ( @{$value} )
    } ## end CHILD: for my $value ( @{ Marpa::R2::HTML::values() } )
    my $original = Marpa::R2::HTML::original();
    push @new_line_data, [ 'pre', 0, $original ];
    push @new_line_data, @following_comments;
    return \@new_line_data;
} ## end sub do_pre

sub do_cruft {
    my $literal = Marpa::R2::HTML::literal();
    my @new_line_data = ( [ 'msg: cruft', 0, 'following', $literal ] );
    push @new_line_data, [ 'cruft', 0, $literal ];
    return \@new_line_data;
} ## end sub do_cruft

sub do_default {
    my $tagname       = Marpa::R2::HTML::tagname();
    my @new_line_data = ();
    my @descendant_data =
        @{ Marpa::R2::HTML::descendants('token_type,value,original') };
    my $first_child         = $descendant_data[0];
    my $first_content_child = 0;

    my $tag_is_line = $inline_tag{ uc $tagname };
    my $tag_type = 'start tag';
    if ( defined $first_child->[0] and $first_child->[0] eq 'S' ) {
        push @new_line_data, [ $tag_type, 0, $first_child->[2] ];
        $first_content_child = 1;
    }
    else {
        push @new_line_data, [ $tag_type, 0, '<' . $tagname . '>' ];
        push @new_line_data,
            [ 'msg: missing start tag', 0, 'preceeding', $tagname ];
    }

    my $last_child         = $descendant_data[-1];
    my $last_content_child = $#descendant_data;
    my $end_tag_child;
    if ( defined $last_child->[0] and $last_child->[0] eq 'E' ) {
        $end_tag_child = $last_child;
        $last_content_child -= 1;
    }

    CHILD:
    for my $descendant_data_ix ( $first_content_child .. $last_content_child )
    {
        my ( $token_type, $value, $original ) =
            @{ $descendant_data[$descendant_data_ix] };
        if ( defined $value ) {
            for my $line_data ( @{$value} ) {
                my ( $type, $indent, @data ) = @{$line_data};
                push @new_line_data, [ $type, $indent + 1, @data ];
            }
            next CHILD;
        } ## end if ( defined $value )
        push @new_line_data, [ 'text', 1, $original ];
    } ## end CHILD: for my $descendant_data_ix ( $first_content_child .. ...)

    END_TAG_PROCESSING: {
        my $tag_type = 'end tag';
        if ( defined $end_tag_child ) {
            push @new_line_data, [ $tag_type, 0, $end_tag_child->[2] ];
            last END_TAG_PROCESSING;
        }
        last END_TAG_PROCESSING if $HTML::Tagset::emptyElement{$tagname};
        push @new_line_data,
            [ 'msg: missing end tag', 0, 'following', $tagname ];
        push @new_line_data, [ $tag_type, 0, '</' . $tagname . '>' ];
    } ## end END_TAG_PROCESSING:

    return \@new_line_data;
} ## end sub do_default

my $html_args = {
    'script' => sub {
        return [ [ 'script', 0, Marpa::R2::HTML::original() ] ];
    },
    ':CRUFT' => \&do_cruft,
    'pre'    => \&do_pre,
    q{*}     => \&do_default,
    ':TOP'   => sub { return Marpa::R2::HTML::values(); }
};

my $value_ref = Marpa::R2::HTML::html( \$document, $html_args );
die "Internal error: no parse" if not defined $value_ref;
require Data::Dumper;
print post_process($value_ref);

exit 0;

__END__

=head1 NAME

C<html_fmt> - Reformat HTML, indented according to structure

=head1 SYNOPSIS

    html_fmt [uri|file]

=head1 EXAMPLE

    html_fmt http://perl.org

=head1 DESCRIPTION

Given the URI or the name of a file,
writes it to C<STDOUT>
reformatted and
indented according to the HTML structure.
Missing start and end tags are supplied and
comments added to indicate this.
Text inside
C<< <pre> >> elements 
is not altered.

L<html_fmt> tries to parse everything that is actually out there on the Web.
In fact,
L<html_fmt> will assume any file fed to it was intended as HTML,
and will produce its best guess of the author's intent.

L<html_fmt> supplies missing start and end tags.
L<html_fmt>'s parser is extremely liberal in what it accepts.
When its liberalization of the standards is not sufficient to make
a document into valid HTML,
L<html_fmt>
will pick characters to treat as noise or "cruft".
The parser ignores cruft in determining
the structure of the document.

When
L<html_fmt> adds
a missing start tag,
it precedes the new start tag with a comment.
When
L<html_fmt> adds
a missing end tag,
it follows the new end tag with a comment.
When L<html_fmt> classifies characters
as "cruft",
it adds a comment to that effect before the "cruft".

C<pre> elements receive special treatment.
The contents of 
C<pre> elements are not reformatted.
When missing tags or cruft occur inside a C<pre> element,
the comments to that effect are placed 
before the C<< <pre> >> start tag.

The argument to L<html_fmt> can be either as a URI or a file
name.  If it starts with alphanumerics followed by a colon, it is treated
as a URI.  Otherwise it is treated as file name.

=head1 SAMPLE OUTPUT

Given this input:

    <title>Test page<tr>x<head attr="I am cruft"><p>Final graf

L<html_fmt> returns

    <!-- Following start tag is replacement for a missing one -->
    <html>
      <!-- Following start tag is replacement for a missing one -->
      <head>
        <title>
          Test page
        </title>
        <!-- Preceding end tag is replacement for a missing one -->
      </head>
      <!-- Preceding end tag is replacement for a missing one -->
      <!-- Following start tag is replacement for a missing one -->
      <body>
        <!-- Following start tag is replacement for a missing one -->
        <table>
          <!-- Following start tag is replacement for a missing one -->
          <tbody>
            <tr>
              <!-- Following start tag is replacement for a missing one -->
              <td>
                x
                <!-- Next line is cruft -->
                <head attr="I am cruft">
                <p>
                  Final graf
                </p>
                <!-- Preceding end tag is replacement for a missing one -->
              </td>
              <!-- Preceding end tag is replacement for a missing one -->
            </tr>
            <!-- Preceding end tag is replacement for a missing one -->
          </tbody>
          <!-- Preceding end tag is replacement for a missing one -->
        </table>
        <!-- Preceding end tag is replacement for a missing one -->
      </body>
      <!-- Preceding end tag is replacement for a missing one -->
    </html>
    <!-- Preceding end tag is replacement for a missing one -->

=head1 PURPOSE

This program is a demo of a demo.
It purpose is to show how easy it is to write applications which look
at the structure of web pages using L<Marpa::R2::HTML>.
And the purpose of L<Marpa::R2::HTML>
is to demonstrate the power of its parse engine,
L<Marpa>.
L<Marpa::R2::HTML> was written in a few days,
and its logic 
is a straightforward,
natural expression of the structure of HTML.

=head1 ACKNOWLEDGEMENTS

The starting template for this code was
L<HTML::TokeParser>, by Gisle Aas.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut
