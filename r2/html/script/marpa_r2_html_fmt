#!/usr/bin/perl
# Copyright 2012 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

use 5.010;
use strict;
use warnings;
use English qw( -no_match_vars );
use Marpa::R2::HTML;
use HTML::Tagset;
use Fatal qw(open close);
use Getopt::Long;

sub usage 
{
    say STDERR "$PROGRAM_NAME html_fmt [uri|file]";
    exit 1;
}

my $data = "file.dat";
my $length = 24;
my $help_flag = 0;
usage() if not GetOptions ( "help" => \$help_flag);
usage() if $help_flag or scalar @ARGV > 1;

my $locator = shift;
my $document;
GET_DOCUMENT: {
    if ( not defined $locator ) {
        local $RS = undef;
        $document = <STDIN>;
        last GET_DOCUMENT;
    }
    if ( $locator =~ /^[a-zA-Z0-9]+[:]/ ) {
        require WWW::Mechanize;
        my $mech = WWW::Mechanize->new( autocheck => 1 );
        $mech->get($locator);
        $document = $mech->content;
        undef $mech;
        last GET_DOCUMENT;
    } ## end if ( $locator =~ /^[a-zA-Z0-9]+[:]/ )
    {
        local $RS = undef;
        open my $fh, q{<}, $locator;
        $document = <$fh>;
        close $fh;
    }
} ## end GET_DOCUMENT:

sub output_messages {
    my $result = q{};
    my ( $indent, $messages ) = @_;
    if ( $indent > 0 ) {
        my $indentation .= q{  } x $indent;
        while ( my $message = shift @{$messages} ) {
            $result .= $indentation . '<!-- ' . $message . " -->\n";
        }
    } ## end if ( $indent > 0 )
    return $result;
} ## end sub output_messages

sub post_process {
    my ($value)          = @_;
    my $result           = q{};
    my @pending_messages = ();

    # 0 means whitespace is not OK
    # 1 means whitespace is OK
    # 2 means whitespace is needed
    my $ws_ok = 0;
    my $pending_content;
    DATUM: for my $line_data ( @{$value->[0]}, ['end of file', 0] ) {
        my $type        = shift @{$line_data};
        my $indent      = shift @{$line_data};
        my $line_prefix = q{  } x $indent;
        if ( $type eq 'content' ) {
	    $pending_content .= $line_data->[0];
	    next DATUM;
	}
	if (defined $pending_content) {
            $result .= output_messages( $indent, \@pending_messages );
	    if ( $pending_content =~ /\S/xms ) {
		$pending_content =~ s/\A\s+//xms;
		$pending_content =~ s/\s+\z//xms;
		$pending_content =~ s/\s+/ /gxms;
		$result .= "\n" if $result !~ /\n\z/xms;
		$result .= q{  } x $indent;
		$result .= $pending_content;
	    } else {
	       $ws_ok = 2;
	    }
	    $pending_content = undef;
	}
        if ( $type eq 'msg: missing start tag' ) {
            my ( $location, $tagname ) = @{$line_data};
            given ($location) {
                when ('following') {
                    push @pending_messages,
                        'Following start tag is replacement for a missing one';
                }
                when ('following pre') {
                    push @pending_messages,
                        "Inside following <pre>, a start tag is missing: <$tagname>";
                }
                default {
                    Carp::croak(
                        "Internal error: unprovided-for missing start tag location: $_"
                    );
                }
            } ## end given
            next DATUM;
        } ## end if ( $type eq 'msg: missing start tag' )
        if ( $type eq 'msg: missing end tag' ) {
            my ( $location, $tagname ) = @{$line_data};
            given ($location) {
                when ('preceding') {
                    push @pending_messages,
                        'Preceding end tag is replacement for a missing one';
                }
                when ('following pre') {
                    push @pending_messages,
                        "Inside following <pre>, an end tag is missing: <$tagname>";
                }
                default {
                    Carp::croak(
                        "Internal error: unprovided-for missing end tag location: $_"
                    );
                }
            } ## end given
            next DATUM;
        } ## end if ( $type eq 'msg: missing end tag' )
        if ( $type eq 'msg: cruft' ) {
            my ( $location, $cruft ) = @{$line_data};
            given ($location) {
                when ('following') {
                    push @pending_messages, 'Next line is cruft';
                }
                when ('following pre') {

                    # Make sure the cruft quoted inside
                    # the HTML comment does not
                    # disrupt the comment.
                    ( my $safe_cruft = $cruft ) =~ s/--/- -/xms;
                    push @pending_messages,
                        qq{Inside the following <pre>, there is this cruft:\n$safe_cruft};
                } ## end when ('following pre')
                default {
                    Carp::croak(
                        "Internal error: unprovided-for cruft location: $_" );
                }
            } ## end given
            next DATUM;
        } ## end if ( $type eq 'msg: cruft' )
        if ( $type eq 'end of file' ) {
            $result .= output_messages( $indent, \@pending_messages );
	    last DATUM;
	}
        if ( $type eq 'start tag' ) {
            $result .= output_messages( $indent, \@pending_messages );
            $result .= "\n" if $result !~ /\n\z/xms;
            $result .= q{  } x $indent;
            $result .= $line_data->[0];
            next DATUM;
        } ## end if ( $type eq 'start tag' )
        if ( $type eq 'end tag' ) {
            $result .= output_messages( $indent, \@pending_messages );
            $result .= "\n" if $result !~ /\n\z/xms;
            $result .= q{  } x $indent;
            $result .= $line_data->[0];
            next DATUM;
        } ## end if ( $type eq 'end tag' )
        if ( $type eq 'cruft' ) {
            $result .= output_messages( $indent, \@pending_messages );
            $result .= "\n" if $result !~ /\n\z/xms;
            $result .= q{  } x $indent;
            $result .= $line_data->[0];
            next DATUM;
        } ## end if ( $type eq 'cruft' )
        if ( $type eq 'pre' ) {
            $result .= output_messages( $indent, \@pending_messages );
            $result .= "\n" if $result !~ /\n\z/xms;
            $result .= q{  } x $indent;
            $result .= $line_data->[0];
            next DATUM;
        } ## end if ( $type eq 'pre' )
        if ( $type eq 'script' ) {
            $result .= output_messages( $indent, \@pending_messages );
            $result .= "\n" if $result !~ /\n\z/xms;
            $result .= q{  } x $indent;
            $result .= $line_data->[0];
            next DATUM;
        } ## end if ( $type eq 'script' )
        Carp::croak( qq{Internal error: unknown line data type: "$type"\n},
            qq{  data: }, join q{}, @{$line_data}, "\n" );
    } ## end DATUM: for my $line_data ( @{$value} )
    return $result;
} ## end sub post_process

sub new_top {
    return Marpa::R2::HTML::values();
}

my $html_args = {
    'script' => sub {
        return [ [ 'script', 0, Marpa::R2::HTML::original() ] ];
    },
    'pre' => sub {
        my @new_line_data      = ();
        my @following_comments = ();
        CHILD:
        for my $value ( @{ Marpa::R2::HTML::values() } )
        {
            for my $line_data ( @{$value} ) {
                if ( $line_data->[0] =~ /^msg:/ ) {
                    push @new_line_data,
                        [
                        $_, 0,
                        'following pre',
                        @{$line_data}[ 3 .. $#{$line_data} ]
                        ];
                } ## end if ( $line_data->[0] =~ /^msg:/ )
            } ## end for my $line_data ( @{$value} )
        } ## end CHILD: for my $descendant_data ( @{ ...})
        my $original = Marpa::R2::HTML::original();
        push @new_line_data, [ 'pre', 0, $original ];
        push @new_line_data, @following_comments;
        return \@new_line_data;
    },
    ':CRUFT' => sub {
        my $literal = Marpa::R2::HTML::literal();
        my @new_line_data = ( [ 'msg: cruft', 0, 'following', $literal ] );
        push @new_line_data, [ 'cruft', 0, $literal ];
        return \@new_line_data;
    },
    q{*} => sub {
        my $tagname       = Marpa::R2::HTML::tagname();
        my @new_line_data = ();
        my @descendant_data =
            @{ Marpa::R2::HTML::descendants('token_type,value,original') };
        my $first_child         = $descendant_data[0];
        my $first_content_child = 0;

        if ( defined $first_child->[0] and $first_child->[0] eq 'S' ) {
            push @new_line_data, [ 'start tag', 0, $first_child->[2] ];
            $first_content_child = 1;
        }
        else {
            push @new_line_data,
                [ 'missing start tag', 0, 'following', $tagname ];
            push @new_line_data, [ 'start tag', 0, '<' . $tagname . '>' ];
        }

        my $last_child         = $descendant_data[-1];
        my $last_content_child = $#descendant_data;
        my $end_tag_child;
        if ( defined $last_child->[0] and $last_child->[0] eq 'E' ) {
            $end_tag_child = $last_child;
            $last_content_child -= 1;
        }

        CHILD:
        for my $descendant_data_ix (
            $first_content_child .. $last_content_child )
        {
            my ( $token_type, $value, $original ) =
                @{ $descendant_data[$descendant_data_ix] };
            if ( defined $value ) {
                for my $line_data ( @{$value} ) {
                    my ( $type, $indent, @data ) = @{$line_data};
                    push @new_line_data, [ $type, $indent + 1, @data ];
                }
                next CHILD;
            } ## end if ( defined $value )
            push @new_line_data, [ 'content', 1, $original ];
        } ## end CHILD: for my $descendant_data_ix ( $first_content_child .. ...)

        END_TAG_PROCESSING: {
            if ( defined $end_tag_child ) {
                push @new_line_data, [ 'end tag', 0, $end_tag_child->[2] ];
                last END_TAG_PROCESSING;
            }
            last END_TAG_PROCESSING if $HTML::Tagset::emptyElement{$tagname};
            push @new_line_data, [ 'end tag', 0, '<' . $tagname . '>' ];
            push @new_line_data,
                [ 'msg: missing end tag', 0, 'preceding', $tagname ];
        } ## end END_TAG_PROCESSING:

        return \@new_line_data;
    },
    ':TOP' => \&new_top,
};

my $value_ref = Marpa::R2::HTML::html( \$document, $html_args );
die "Internal error: no parse" if not defined $value_ref;
require Data::Dumper;
print STDERR Data::Dumper::Dumper($value_ref);
print post_process($value_ref);

exit 0;

__END__

=head1 NAME

C<html_fmt> - Reformat HTML, indented according to structure

=head1 SYNOPSIS

    html_fmt [uri|file]

=head1 EXAMPLE

    html_fmt http://perl.org

=head1 DESCRIPTION

Given the URI or the name of a file,
writes it to C<STDOUT>
reformatted and
indented according to the HTML structure.
Missing start and end tags are supplied and
comments added to indicate this.
Text inside
C<< <pre> >> elements 
is not altered.

L<html_fmt> tries to parse everything that is actually out there on the Web.
In fact,
L<html_fmt> will assume any file fed to it was intended as HTML,
and will produce its best guess of the author's intent.

L<html_fmt> supplies missing start and end tags.
L<html_fmt>'s parser is extremely liberal in what it accepts.
When its liberalization of the standards is not sufficient to make
a document into valid HTML,
L<html_fmt>
will pick characters to treat as noise or "cruft".
The parser ignores cruft in determining
the structure of the document.

When
L<html_fmt> adds
a missing start tag,
it precedes the new start tag with a comment.
When
L<html_fmt> adds
a missing end tag,
it follows the new end tag with a comment.
When L<html_fmt> classifies characters
as "cruft",
it adds a comment to that effect before the "cruft".

C<pre> elements receive special treatment.
The contents of 
C<pre> elements are not reformatted.
When missing tags or cruft occur inside a C<pre> element,
the comments to that effect are placed 
before the C<< <pre> >> start tag.

The argument to L<html_fmt> can be either as a URI or a file
name.  If it starts with alphanumerics followed by a colon, it is treated
as a URI.  Otherwise it is treated as file name.

=head1 SAMPLE OUTPUT

Given this input:

    <title>Test page<tr>x<head attr="I am cruft"><p>Final graf

L<html_fmt> returns

    <!-- Following start tag is replacement for a missing one -->
    <html>
      <!-- Following start tag is replacement for a missing one -->
      <head>
        <title>
          Test page
        </title>
        <!-- Preceding end tag is replacement for a missing one -->
      </head>
      <!-- Preceding end tag is replacement for a missing one -->
      <!-- Following start tag is replacement for a missing one -->
      <body>
        <!-- Following start tag is replacement for a missing one -->
        <table>
          <!-- Following start tag is replacement for a missing one -->
          <tbody>
            <tr>
              <!-- Following start tag is replacement for a missing one -->
              <td>
                x
                <!-- Next line is cruft -->
                <head attr="I am cruft">
                <p>
                  Final graf
                </p>
                <!-- Preceding end tag is replacement for a missing one -->
              </td>
              <!-- Preceding end tag is replacement for a missing one -->
            </tr>
            <!-- Preceding end tag is replacement for a missing one -->
          </tbody>
          <!-- Preceding end tag is replacement for a missing one -->
        </table>
        <!-- Preceding end tag is replacement for a missing one -->
      </body>
      <!-- Preceding end tag is replacement for a missing one -->
    </html>
    <!-- Preceding end tag is replacement for a missing one -->

=head1 PURPOSE

This program is a demo of a demo.
It purpose is to show how easy it is to write applications which look
at the structure of web pages using L<Marpa::R2::HTML>.
And the purpose of L<Marpa::R2::HTML>
is to demonstrate the power of its parse engine,
L<Marpa>.
L<Marpa::R2::HTML> was written in a few days,
and its logic 
is a straightforward,
natural expression of the structure of HTML.

=head1 ACKNOWLEDGEMENTS

The starting template for this code was
L<HTML::TokeParser>, by Gisle Aas.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut
