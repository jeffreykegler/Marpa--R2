# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Semantics - How Marpa evaluates parses

=head1 Synopsis

=for Marpa::R2::Display
name: SLIF full synopsis
normalize-whitespace: 1

    use Marpa::R2;

    my $grammar = Marpa::R2::Scanless::G->new(
        {   bless_package => 'My_Nodes',
            source        => \(<<'END_OF_SOURCE'),
    :default ::= action => [values] bless => ::lhs
    lexeme default = action => [start,length,value] bless => ::name

    :start ::= Script
    Script ::= Expression+ separator => comma
    comma ~ [,]
    Expression ::=
        Number bless => primary
        | '(' Expression ')' bless => paren assoc => group
       || Expression '**' Expression bless => exponentiate assoc => right
       || Expression '*' Expression bless => multiply
        | Expression '/' Expression bless => divide
       || Expression '+' Expression bless => add
        | Expression '-' Expression bless => subtract

    Number ~ [\d]+
    :discard ~ whitespace
    whitespace ~ [\s]+
    # allow comments
    :discard ~ <hash comment>
    <hash comment> ~ <terminated hash comment> | <unterminated
       final hash comment>
    <terminated hash comment> ~ '#' <hash comment body> <vertical space char>
    <unterminated final hash comment> ~ '#' <hash comment body>
    <hash comment body> ~ <hash comment char>*
    <vertical space char> ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
    <hash comment char> ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
    END_OF_SOURCE
        }
    );


    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );

    my $input = '42*2+7/3, 42*(2+7)/3, 2**7-3, 2**(7-3)';
    $recce->read(\$input);
    my $value_ref = $recce->value();
    die "No parse was found\n" if not defined $value_ref;

    # Result will be something like "86.33... 126 125 16"
    # depending on the floating point precision
    my $result = ${$value_ref}->doit();

    package My_Nodes;

    sub My_Nodes::primary::doit { return $_[0]->[0]->doit() }
    sub My_Nodes::Number::doit  { return $_[0]->[2] }
    sub My_Nodes::paren::doit   { my ($self) = @_; $self->[1]->doit() }

    sub My_Nodes::add::doit {
        my ($self) = @_;
        $self->[0]->doit() + $self->[2]->doit();
    }

    sub My_Nodes::subtract::doit {
        my ($self) = @_;
        $self->[0]->doit() - $self->[2]->doit();
    }

    sub My_Nodes::multiply::doit {
        my ($self) = @_;
        $self->[0]->doit() * $self->[2]->doit();
    }

    sub My_Nodes::divide::doit {
        my ($self) = @_;
        $self->[0]->doit() / $self->[2]->doit();
    }

    sub My_Nodes::exponentiate::doit {
        my ($self) = @_;
        $self->[0]->doit()**$self->[2]->doit();
    }

    sub My_Nodes::Script::doit {
        my ($self) = @_;
        return join q{ }, map { $_->doit() } @{$self};
    }

=for Marpa::R2::Display::End

=head1 Overview

B<This document is under construction.>
It is being converted to describe Marpa's primary interface, the SLIF.
Currently,
much of it actually describes an older and more low-level Marpa interface, the NAIF.

The SLIF's general approach to semantics is traditional,
and will be familar to those who have used other parsers.
For evaluation purposes,
every parse is seen as a tree.
Every nodes of the tree corresponds either to a lexemes,
in which case the node is a "leaf" of the tree,
or to a rule.

Nodes on the tree are evaluated recursively, bottom-up.
Once the values of all its child nodes are known,
a parent node is ready to be evaluated.
The final value of a parse is the value of the top node
of the parse tree.

What the SLIF does at each node is called that node's B<action>.
Actions can be many things in the SLIF, as will be described
in what follows.
To give some perspective, it might be useful at this point
to describe what could
happen when evaluating a typical node.

=head2 Evaluating a typical node

As a typical example, the action adverb of a rule might be treated as a name,
which is resolved to a Perl closure,
called the rule evaluation closure.
When it is that node's turn to be evaluated that closure
is called with a series of arguments:
first, the per-parse argument,
and then the values of the child nodes in lexical order.
The result of calling the rule evaluation closure is passed
upward in the parse tree, except if this is the top of the tree.
If that is the case, the evaluation of the parse is finished,
and the value of the parse is the value of the rule evaluation closure.

=head1 Finished to here

An action name is either reserved,
or resolves to a Perl object.
When it resolves to a Perl object,
that object is usually a Perl closure -- code.
If the Perl object action is code,
it is a rule evaluation closure, and will be
called to produce the result.
When a Perl object action is some other kind of object,
its treatment is
L<as described
below|/"Reference actions">.

An action name
and action is also used
to create the per-parse-tree variable,
as L<described
below|/"The per-parse-tree variable">.

=head1 G0 and G1 Subgrammars

Evaluation only takes place within the structural (G1) subgrammar,
and the descriptions of the behaviors of rules and lexemes applies only
to the G1 subgrammar.
G0 rules and terminal symbols do not become nodes
in the parse tree,
they have no actions,
and they are never evaluated.

=head1 Evaluating a lexeme

Lexemes can have a action specified in
the L<lexeme default statement|Marpa::R2::Scanless::DSL/"Lexeme default statement">.
If no action is specified for a lexeme, its value is its literal value in the input
stream, as a string.

=head2 Evaluating a rule

If a node is not a token node,
then it is a B<rule node>.
Rule nodes are always
associated with a rule.
It a rule's action is a rule evaluation closure,
it is called at
L<Node Evaluation Time|/"Tree Traversal Phase">.

The rule evaluation closures's
arguments will be a
per-parse-tree variable followed, if the rule is not nulled,
by the values of its child nodes in lexical order.
If the rule is nulled, the child node values will be omitted.
A rule evaluation closure action is always called in scalar context.

If the action is a constant,
it becomes the value of the rule node.
If the action is a rule evaluation closure,
its return value becomes the value of the node.
If there is no action for a
rule node,
the value of the rule node is a Perl C<undef>.

=head2 Sequence rule nodes

Some rules are L<sequence rules|Marpa::R2::NAIF::Grammar/"Sequence rules">.
Sequence rule nodes are also rule nodes.
Everything said above about rule nodes
applies to sequence rule nodes.
Specifically,
the arguments to the value actions for sequence rules
are the
per-parse-tree variable followed by
the values of the child nodes in lexical order.

The difference (and it is a big one)
is that in an ordinary rule, the right hand side
is fixed in length, and that length is known
when you are writing the code for the value action.
In a sequence rule,
the number of right hand side symbols is not known
until node evaluation time.
The rule evaluation closure
of a sequence rule
must be capable of
dealing with
a variable number of arguments.

Sequence semantics work best when
every child node
in the sequence has the same semantics.
When that is not the case,
writing the sequence using
ordinary non-sequence rules should be considered as
an alternative.

By default, if a sequence rule has separators,
the separators are thrown away before
the value action is called.
(Separators are described in
L<the section introducing sequence rules|Marpa::R2::NAIF::Grammar/"Sequence rules">.)
This means that separators do not appear in the C<@_> array
of the rule evaluation closure which is the value action.
If the value of the C<keep> rule property
is a Perl true value, separators are kept,
and do appear in the
value action's
C<@_> array.

=head2 Null nodes

A null node is a special case of a rule node,
one where the rule derives the zero-length,
or empty string.
When the rule node is a null node,
the rule evaluation closure will be called with
no child value arguments.

When a node is nulled,
it must be as a result of a nullable rule,
and the action name and action are those
associated with that rule.
An ambiguity can arise if there is more
than one nullable rule with the same LHS,
but a different action name.
In that case the action name for the null nodes
is that of the empty rule.

The remaining case is that of
a set of nullable rules with the same LHS,
where two or more of the rules have different action names,
but none of the rules in the set is an empty rule.
When this happens, Marpa throws an exception.
To fix the issue,
the user can add an empty rule.
For more details,
see L<the document on
null semantics|Marpa::R2::Semantics::Null>.

=head1 Action context

=for Marpa::R2::Display
name: SLIF action context synopsis
normalize-whitespace: 1

    sub do_S {
        my ($action_object) = @_;
        my $rule_id         = $Marpa::R2::Context::rule;
        my $grammar         = $Marpa::R2::Context::grammar;
        my ( $lhs, @rhs ) = $grammar->rule($rule_id);
        $action_object->{text} =
              "rule $rule_id: $lhs ::= "
            . ( join q{ }, @rhs ) . "\n"
            . "locations: "
            . ( join q{-}, Marpa::R2::Context::location() ) . "\n";
        return $action_object;
    } ## end sub do_S

=for Marpa::R2::Display::End

In addition to the per-parse-tree variable
and their child arguments,
rule evaluation closures also have access
to B<context variables>.

=over

=item * C<$Marpa::R2::Context::grammar> is set to
the grammar being parsed.

=item * C<$Marpa::R2::Context::rule> is the ID of the
current rule.
Given the rule ID, an application can find
its LHS and RHS symbols using
L<the SLIF grammar's C<rule()> method|Marpa::R2::Scanless::G/"rule">.

=item * C<Marpa::R2::Context::location()> returns the start
and end locations of the current rule.

=back

=head1 Bailing out of parse evaluation

=for Marpa::R2::Display
name: SLIF bail synopsis
normalize-whitespace: 1

    my $bail_message = "This is a bail out message!";

    sub do_bail_with_message_if_A {
        my ($action_object, $terminal) = @_;
        Marpa::R2::Context::bail($bail_message) if $terminal eq 'A';
    }

    sub do_bail_with_object_if_A {
        my ($action_object, $terminal) = @_;
        Marpa::R2::Context::bail([$bail_message]) if $terminal eq 'A';
    }

=for Marpa::R2::Display::End

The C<Marpa::R2::Context::bail()> static method is used to
"bail out" of the evaluation of a parse tree.
It will cause an exception to be thrown.
If its first and only argument is a reference,
that reference is the exception object.
Otherwise, an exception message is created
by converting the method's arguments to strings,
concatenating them,
and prepending them with a message indicating
the file and line number at which the
C<Marpa::R2::Context::bail()> method was called.

=head1 Parse trees, parse results and parse series

When the semantics are applied to a parse tree,
it produces a value called a B<parse result>.
Because Marpa allows ambiguous parsing,
each parse can produce a B<parse series> --
a series of zero or more parse trees,
each with its own parse result.
The first call to the
L<the recognizer's C<value>
method|Marpa::R2::NAIF::Recognizer/"value">
after the recognizer is created is the
start of the first parse series.
The first parse series continues until there is
a call to the
L<the C<reset_evaluation>
method|Marpa::R2::NAIF::Recognizer/"reset_evaluation">
or until the recognizer is destroyed.
Usually, an application is only interested in a single
parse series.

When the
L<C<reset_evaluation>|Marpa::R2::NAIF::Recognizer/"reset_evaluation">
method
is called
for a recognizer, it begins a new parse series.
The new parse series continues until
there is another
call to the
L<the C<reset_evaluation>
method|Marpa::R2::NAIF::Recognizer/"reset_evaluation">,
or until the recognizer is destroyed.

Most applications will find that the order in which
Marpa executes its semantics "just works".
L<A separate
document|Marpa::R2::Semantics::Phases>
describes that order
in detail.
The details can matter in some applications,
for example, those which exploit side effects.

=head1 Finding the action for a rule

Marpa finds the action for each rule based on
rule and symbol properties and on the grammar named arguments.
Specifically, Marpa attempts the following,
in order:

=over

=item * Resolving an action based on the C<action> property of the rule,
if one is defined.

=item * If the rule is empty,
and the C<default_empty_action> named argument of the grammar
is defined,
resolving an action based on that named argument.

=item * Resolving an action based on
the C<default_action> named argument of the grammar,
if one is defined.

=item * Defaulting to a Perl C<undef> value.

=back

Resolution of action names is L<described
below|/"Resolving action names">.
If the C<action> property,
the C<default_action> named argument,
or the C<default_empty_action> named argument
is defined,
but does not resolve successfully, Marpa
throws an exception.
Marpa prefers to "fast fail" in these cases,
because they usually indicate a mistake
that the application's author
will want to correct.

=head1 Resolving action names

Action names come from these sources:

=over

=item * The C<default_action> named argument of Marpa's grammar.

=item * The C<default_empty_action> named argument of Marpa's grammar.

=item * The C<action> property of Marpa's rules.

=item * The C<new> constructor in the package specified by the
C<action_object> named argument of the Marpa grammar.

=back

=head2 Reserved action names

Action names that begin with a double colon ("C<::>") are reserved.
At present only the C<::undef> reserved action is documented for
use outside of the DSL-based interfaces.

=head3 ::undef

A constant whose value is a Perl C<undef>.
Perl is unable to distinguish reliably between a
non-existent value and scalars with an C<undef> value.
This makes it impossible to reliably distinguish
resolutions
to a Perl C<undef> from resolution problems.
The "C<::undef>" reserved action name should 
be preferred for
indicating a constant whose value is a Perl C<undef>.

=head2 Fully qualified action names

An action name that
contains a double colon ("C<::>") or a single quote ("C<'>")
is considered to be a fully qualified name.
Any other action name is considered to be a B<bare action name>.

If the action name to be resolved is already a fully qualified name,
it is not further transformed.
It will be resolved in the form it was received,
or not at all.

For bare action names,
Marpa tries to qualify them by adding a package name.
If the C<actions> grammar named argument is defined,
Marpa uses it as the package name.
Otherwise,
if the
C<action_object> grammar named argument is defined,
Marpa uses it as the package name.
Once Marpa has fully qualified the action name,
Marpa looks for a Perl object with that name.

Marpa will not attempt to resolve an action name
that it cannot fully qualify.
This implies that,
for an action name to resolve successfully,
one of these five things must be the case:

=over

=item * The action name is one of the reserved action names.

=item * The action name is fully qualified to begin with.

=item * The C<actions> named argument is defined.

=item * The C<action_object> named argument is defined.

=back

Marpa's philosophy
is to require that the programmer be specific about action names.
This can be an inconvenience, but Marpa prefers this to
silently executing unintended code.

If the user wants to leave the
rule evaluation closures in the C<main> namespace,
she can specify
C<"main">
as the value of the C<actions> named argument.
But
it can be good practice to keep
the rule evaluation closures
in their own namespace,
particularly if the application is not small.

=head2 Perl object actions

Actions divide into two types:
reserved actions and Perl object actions.
A Perl object action is a actual Perl object of some type:
either code or a reference.

In simplified terms,
if a Perl object action comes from resolution of
an action name,
and
there is a Perl closure of that name, the Perl
closure is the resolution.
If there is a reference with that name
it is resolved
L<as described for Perl reference
actions|/"Reference actions">.
If there is some other scalar with that name,
it is a fatal error.
All other Perl objects with that name are ignored.

More precisely, the resolution depends the lookup
of the action name in the Perl symbol table:

=over 4

=item * 

If there is a C<CODE> entry,
that entry is the resolution.

=item * 

If there is a C<SCALAR> entry,
and it is a reference,
it is resolved
L<as described for Perl reference
actions|/"Reference actions">.

=item * 

If there is a C<SCALAR> entry,
and it is not a reference,
it is a fatal error.

=item * 

If there is no C<SCALAR> entry and no C<CODE> entry,
it will be considered a failure to resolve.

=back

=head2 Reference actions

A Marpa action can be a Perl object which is a reference.
Referents should be treated as read-only constants.
It is possible to modify the values pointed to
by a reference, but the effect will be global,
and this is deprecated as bad practice.
The referents of reference actions should be treated
as read-only, and never modified.

In the following, let C<$action_ref> be the action reference.
Reference actions are handled based on type,
ignoring any blessing as class objects.
This would be the reftype as returned
by C<Scalar::Util::reftype $action_ref>.

If the reftype is C<CODE>,
the resolution is to the Perl closure.
The effect is the same as if an action name
had resolved directly to a closure with the same
name.
The Perl closure,
also called a B<rule evaluation closure>,
will be called to produce the value of
the action.

If the reftype is C<SCALAR>,
the resolution is to its de-referenced value,
C<${$action_ref}>.
The effect is roughly the same as if an action
name had resolved to a closure which returned
C<${$action_ref}>.

If the reftype is C<ARRAY>,
the resolution is to the original reference,
C<$action_ref>.
The effect is roughly the same as if an action
name had resolved to a closure which returned
C<$action_ref>.

If the reftype is C<HASH>,
the resolution is to the original reference,
C<$action_ref>.
The effect is roughly the same as if an action
name had resolved to a closure which returned
C<$action_ref>.

=head2 Modifying Perl object actions

It is important to note multiple invocations
of C<$action_ref> will
always point to the same contents,
and that any modification will be
seen by other invocations.
In other words, the modification will have global
effect.
For this reason modifying the referents of
reference actions is deprecated.

For example,
assume that actions are in a package named C<My_Nodes>,
which contains a hash reference named C<empty_hash>, 

=for Marpa::R2::Display
ignore: 1

        package My_Nodes;
        our $empty_hash = {};

=for Marpa::R2::Display::End

It can be tempting, in building objects which are hashes,
to start with a left node whose action is C<empty_hash>
and to add contents to it as the object is passed up the evaluation
tree.
But C<$empty_hash> points to a single hash object.
This single hash object will shared by all nodes,
with all nodes seeing each other's changes.
Worse, all Marpa parsers which use the same C<My_Nodes>
namespace will share the same hash object.

When not simply a mistake,
this is usually bad programming practice.
Before modifying the referent of a reference action,
rule evaluation closures should copy it.
Safer, if less efficient,
is to define the C<empty_hash> action
as a closure which returns C<{}>.

=head2 Visibility of Perl object actions

It is important to note that,
when Perl closures are used for the semantics,
they must be visible in the scope where the semantics are
B<resolved>.
The action names are usually B<specified> with the grammar,
but action B<resolution> takes place
in the recognizer's
L<C<value>|Marpa::R2::NAIF::Recognizer/"value">
and
L<C<reset_evaluation>|Marpa::R2::NAIF::Recognizer/"reset_evaluation">
methods.
This can sometimes be a source of confusion,
because if a Perl closure is visible when the
action is specified,
but goes out of scope before the action name is resolved,
resolution will fail.

=head1 The per-parse-tree variable

In the Tree Setup Phase,
Marpa creates a per-parse-tree variable.
This becomes the first argument of the rule evaluation closures for
the rule nodes.
If the grammar's C<action_object> named argument is not defined,
the per-parse-tree variable is initialized to an empty hash ref.

Most data for
the value actions of the rules
will be passed up the parse tree.
The actions will see the values of the rule node's child nodes
as arguments,
and will return their own value to be seen as an argument
by their parent node.
The per-parse-tree variable can be used for data which does not
conveniently fit this model.

The lifetime of the per-parse-tree variable
extends into the Tree Traversal Phase.
During the Tree Traversal Phase,
Marpa's internals never alter the per-parse-tree variable --
it is reserved for use by the application.

=head2 Action object constructor

If the grammar's C<action_object> named argument has a defined value,
that value is treated as the name of a class.
The B<action object constructor> is
the C<new> method
in the C<action_object> class.

The action object constructor is called
in the Tree Setup Phase.
The return value of the
action object constructor becomes the per-parse-tree variable.
It is a fatal error if the
grammar's C<action_object> named argument is defined,
but does not name a class with a C<new> method.

Resolution of the action object constructor is
resolution of the B<action object constructor name>.
The action object constructor name is
formed by concatenating
the literal string "C<::new>" to
the value of the C<action_object> named argument.

All standard rules apply when resolving the action
object constructor name.
If a grammar has both the C<actions> and the
C<action_object> named arguments defined,
all action names B<except>
for the action object constructor will be
resolved in the C<actions> package or not at all.
The action object constructor is always in
the C<action_object> class, if it is anywhere.

=head1 Parse order

If a parse is ambiguous, all parses are returned,
with no duplication.
By default, the order is arbitrary, but
it is also possible to control the order.
Details are in L<the document
on parse order|Marpa::R2::Semantics::Order>.

=head1 Infinite loops

Grammars with infinite loops (cycles)
are generally regarded as useless in practical applications.
Due to lack of interest,
the SLIF does not currently support them,
altougth Libmarpa itself, Marpa's thin interface and the NAIF all do.
Those interested in knowing more can look at L<the
document on the NAIF's support of infinitely ambiguous
grammars|Marpa::R2::NAIF::Semantics::Infinite>.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
