# Copyright 2014 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Event - SLIF parse events

=head1 Synopsis

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1
partial: 1

    my $input = q{a b c "insert d here" e e f};
    my $length = length $input;
    my $pos    = $slr->read( \$input );

    my $actual_events = q{};

    READ: while (1) {

        my @actual_events = ();

        my $next_lexeme;
        EVENT:
        for my $event ( @{ $slr->events() } ) {
            my ($name) = @{$event};

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1
partial: 1

            push @actual_events, $name;
        }

        if (@actual_events) {
            $actual_events .= join q{ }, "Events at position $pos:", @actual_events;
            $actual_events .= "\n";
        }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1
partial: 1

        if ($pos < $length) {
            $pos = $slr->resume();
            next READ;
        }
        last READ;
    } ## end READ: while (1)

=for Marpa::R2::Display::End

The synopsis is extracted from an example given in full
L<below|/"An example">.

=head1 About this document

This document is an overview of B<SLIF parse events>.
SLIF parse events
B<trigger> based on conditions declared in the DSL.
Typical events are the prediction or recognition
of a symbol.

SLIF parse events are often used to allow an application to
switch over to its own custom procedural logic.
Among other things,
an application can do its own "external" scanning of lexemes.
An application may ask Marpa to resume internal scanning at
any point.

SLIF parse events may be named or unnamed.
Use of unnamed events is discouraged, and should be reserved for legacy
code.
New applications should only use named events.
When not otherwise specified,
this document is talking about named events.
Unnamed events are described
L<below,
in a section dedicated to them|/"Unnamed events">.

=head1 Terminology

SLIF parse events are called B<parse events>
or simply B<events>,
in contexts where the meaning is clear.

SLIF parse events evolved over time from simpler
mechanisms,
and the term SLIF parse event was introduced late
in the development of Marpa::R2.
In previous versions of Marpa::R2,
SLIF parse events and their precursors are called "pauses" or simply "events".
For historical reasons,
some of the method names dealing with SLIF parse events
still have the word "pause" as part of their name.

In this document, an B<instance> of a symbol
in a parse
means an occurrence
of the symbol in that parse
with a specific start location and length.
An instance of a symbol is also called
B<symbol instance>.
A consequence of this definition
is that every symbol instance
has exactly one end location.

In a parse,
a nulled symbol instance,
or B<nulled symbol>, is a symbol instance with a length of zero.
A non-nulled symbol instance, non-nulled instance,
or B<non-nulled symbol>, is a symbol instance which is not
nulled.
A symbol in a grammar is 
a B<nullable symbol> if it has
at least one nulled instance
in at least one parse of at least one input.
A symbol in a grammar is 
a B<nulling symbol> if,
in all parses of all inputs,
all of its instances are nulled instances.
A symbol is B<non-nulling> if it is not nulling.

In the following, we say say that
an input is consistent with
the actual input up to location I<L>,
or simply, B<actual to L>,
if it is the actual input up to location I<L>,
and any possible string after location I<L>.
We say that a symbol is B<acceptable> at
a location I<L>
if there is a valid parse,
according to the grammar,
of some input actual to I<L>.
We say that a symbol instance
is B<recognized> at
a location I<L> if its end location is I<L>,
and there is a valid parse, according to the grammar,
of some input actual to I<L>.
We say that a symbol
is B<recognized> at
a location I<L> if its end location is I<L>,
and there is a valid parse, according to the grammar,
of some input actual to I<L>.

=head1 The life cycle of events

=over 4

=item * An SLIF parse event must be B<declared>.

=item * A declared event may B<trigger>.

=item * Once an event triggers, it may be B<accessed>.

=back

Events are declared in the SLIF DSL.
Parse events can be either a lexeme event
or a non-lexeme event.
Lexeme events are declared using
L<C<:lexeme> pseudo-rules|Marpa::R2::DSL/"Lexeme pseudo-rules">.
Non-lexeme events are declared using
L<named event statements|Marpa::R2::DSL/"Named event statement">.
The various types of parse events are described in detail
L<below|/"Types of parse event">.
The description of
each type of parse event,
indicates whether it is a lexeme or a non-lexeme event.

Once declared, events
may trigger during any event-triggering SLIF
recognizer method.
The event-triggering SLIF recognizer methods are
L<C<read()>|Marpa::R2::Scanless::R/"read()">,
L<C<resume()>|Marpa::R2::Scanless::R/"resume()">,
L<C<lexeme_read()>|Marpa::R2::Scanless::R/"lexeme_read()"> and
L<C<lexeme_complete()>|Marpa::R2::Scanless::R/"lexeme_complete()">.
When an event triggers, it causes the event-triggering
method to return immediately, with the current location
at the B<trigger location>.
Non-lexeme events may trigger during any of the event-triggering
methods.
Lexeme events will only trigger during calls of the
C<< $slr->read() >> and C<< $slr->resume() >> methods.

Events may be accessed using
L<the Scanless recognizer's events()
method|/"events()">.
The beginning and end of the lexeme triggering a lexeme event
may be found using
L<the Scanless recognizer's pause_span()
method|/"pause_span()">.

=head1 Types of parse event

=head2 Completion events

Completion events are declared in the SLIF DSL
using the
L<named event statement|Marpa::R2::DSL/"Named event statement">:

=for Marpa::R2::Display
name: SLIF completed event statement synopsis
partial: 1
normalize-whitespace: 1

    event subtext = completed <subtext>

=for Marpa::R2::Display::End

Completion SLIF parse events can be specified for any
symbol that is not a lexeme.
Completion events are non-lexeme events.
A completion event triggers
whenever a non-nulled instance of its symbol
is recognized at the current location.
The trigger location is the current location,
which will be the end location
of the instance that triggered the event.
The event is called a "completion"
because, at the trigger location,
the recognition of its symbol
is "complete".

=head2 Nulling events

Nulling events are declared in the SLIF DSL
using the
L<named event statement|Marpa::R2::DSL/"Named event statement">:

=for Marpa::R2::Display
name: SLIF nulled event statement synopsis
partial: 1
normalize-whitespace: 1

    event 'A[]' = nulled <A>

=for Marpa::R2::Display::End

A nulling SLIF parse event occurs whenever a nulled instance
of its symbol is recognized at the current location.
The trigger location is the current location,
which will be the
the location where the triggering instance both begins and ends.

Nulling SLIF parse events can be specifed for any
symbol that is not a lexeme.
Nulled symbols may derive other null symbols,
and null derivations may be ambiguous.
All nulling events declarated
for symbols in these derivations will
trigger.

=head2 Prediction events

Prediction events are declared in the SLIF DSL
using the
L<named event statement|Marpa::R2::DSL/"Named event statement">:

=for Marpa::R2::Display
name: SLIF predicted event statement synopsis
partial: 1
normalize-whitespace: 1

    event '^a' = predicted A

=for Marpa::R2::Display::End

A prediction event triggers whenever
a non-nulling symbol is acceptable at the current location.
The trigger location is the current location.
No symbol instance can start at a location unless a
a prediction of the symbol is declared and activated,
A prediction may not result in an actual instance of the symbol,
but no actual instance can start at a location unless a prediction,
if properly declared and activated,
would triggered at that location.

Prediction SLIF parse events may be defined for any symbol,
whether it is a lexeme or not.
But prediction events are non-lexeme events,
and B<not> lexeme events,
even if their symbol is a lexeme.

=head2 Post-lexeme events

=for Marpa::R2::Display
name: SLIF predicted event statement synopsis
partial: 1
normalize-whitespace: 1

    :lexeme ~ <a> pause => after event => '"a"'

=for Marpa::R2::Display::End

An post-lexeme event is a lexeme event.
It triggers if the lexeme is scanned at the current location.
Its trigger location is the current location,
which will also be the location where the lexeme ends.
Post-lexeme events which trigger during
C<< $slr->lexeme_complete() >> and
C<< $slr->lexeme_read() >> calls are discarded.

=head2 Pre-lexeme events

=for Marpa::R2::Display
name: SLIF predicted event statement synopsis
partial: 1
normalize-whitespace: 1

    :lexeme ~ <insert d> pause => before event => 'insert d'

=for Marpa::R2::Display::End

An pre-lexeme event is a lexeme event.
It triggers if the lexeme is scanned at the current location.
Its trigger location is the location where the lexeme starts.

For most events, the trigger location is the current location,
but pre-lexeme events are the exception -- they can be said
to "rewind" the scanner by the length of the lexeme.
Pre-lexeme events trigger where the lexeme starts because
one of their intended use cases is catching a lexeme which
is about to be read, and giving it special treatment.
For more on this, see
L<below|"External scanning">.
Pre-lexeme events which trigger during
C<< $slr->lexeme_complete() >> and
C<< $slr->lexeme_read() >> calls are discarded.

There is a lot of similarity
between pre-lexeme events and predictions,
and the two often occur together.
but there are important differences.
A pre-lexeme event does not occur unless that the lexeme is actually
found in the input.
A prediction event, on the other hand, is
as the name suggests, only a prediction -- the lexeme may not
actually be found in the input.

=head1 Lexeme events

The event mechanism groups into lexeme
and non-lexeme events, based on their type.
The lexeme events are the pre-lexeme event
and post-lexeme event.

A non-lexeme event will trigger at the current location
if all of the following criteria,
applied in order, are true:

=over 4

=item *

It is declared in a
L<C<:lexeme> pseudo-rules|Marpa::R2::DSL/"Lexeme pseudo-rules">.

=item *

It has been scanned by the L0 grammar at that location.

=item *

The G1 grammar would accept that lexeme at that location.

=item *

The event is activated.
Deactivation and reactivation of events is
done with the SLIF recognizer's
L<activate() method|Marpa::R2::Scanless::R/"activate()">

=item *

Its lexeme priority is higher than, or equal to,
that of any other lexeme
remaining after the previous criteria
have been applied.

=item *

If it is a post-lexeme event,
none of other remaining events are pre-lexeme events.
(In other words, a pre-lexeme event prevents any
post-lexeme events from triggering at the same location.)

=back

Marpa allows ambiguous lexemes and,
even after all the above criteria have been applied,
there can be still be more than one lexeme event at a location.

=head1 Non-lexeme events

Prediction, completion and nulling events are non-lexeme events.

The conditions for a non-lexeme event are simpler than those for
a lexeme event, because they do not involve lexical processing.

A non-lexeme event will trigger at the current location
if all of the following are true:

=over 4

=item *

It is declared in a
L<named event statement|Marpa::R2::DSL/"Named event statement">.

=item *

The defining condition for its type is satisified:
It is a prediction and its symbol is acceptable at the current location;
or it is a completion or a nulling event and its symbol is recognized
at the current location.

=item *

The event is
L<activated|Marpa::R2::Scanless::R/"activate()">.

=back

=head1 Techniques

=head2 External scanning

Switching to external scanning is an intended use case
for all events,
but the behavior of pre-lexeme events
in particular is most intuitive when seen with
external scanning in mind.

In L<the example below|/"An example">,
the symbol C<< <insert d> >> has a pre-lexeme event
declared:

=for Marpa::R2::Display
name: SLIF predicted event statement synopsis
partial: 1
normalize-whitespace: 1

    :lexeme ~ <insert d> pause => before event => 'insert d'

=for Marpa::R2::Display::End

When this triggers, the code in the example switches to
external scanning:
It reads a C<< <d> > symbol externally,
skips over lexeme actually in the input,
and resumes internal scanning.
There is a very trivial example,
one which an application would deal with in simpler ways.
But it does serve as a small example of how external scanning
is performed.

=head2 Markers

It is quite reasonable to create "markers" --
nulling symbols
whose primary (or sole) purpose
is to have nulling events declared for them.
Markers are the only way to declare events that trigger in
the middle of rule.

=head2 Rules

There are no events explicitly defined in terms of rules,
but every rule event that is wanted can be achieved in
one or more ways.
The most flexible of these, and the best for most purposes,
is to use L<markers|/"Markers">.

Another method is to use the LHS of a rule to track rule
predictions and completions.
This requires that the LHS symbol of the rule be unique to that
rule.

=head1 Implications

This section describes 
some implications of the SLIF parse events mechanism
that may be unexpected at first to some users.
It explains why they are Marpa as designed,
and I hope the reader will come to agree,
as is desirable.

=head2 Ambiguity

If a parse is ambiguous, events trigger for
B<all> the possible symbols.
A user thinking in terms of one of the parses,
and unaware of the ambiguity, may find this unexpected.
In L<the example|/"An example">,
events for both the symbols C<< <ambig1> >>
and C<< <ambig2> >>, as well as all their
derived symbols, trigger.

=head2 Tentative events

SLIF parse events are generated whenever the event occurs in a left-to-right
scan.
More precisely, a Marpa event is triggered if and only if
there is a parse corresponding to the event
for the actual input 
up to the trigger location
and some possible input after the trigger location.

Because the possible input that the event depends on may not
turn out to be the actual input,
events are B<tentative>.
There is no guarantee that a derivation
corresponding to the event will wind up in the value of the parse,
or even in any of the values of an ambiguous parse.

In L<the example|/"An example">,
prediction and completion
events are reported for the symbols
C<< <start1> >>,
C<< <start2> >>,
C<< <mid1> >> and
C<< <mid2> >>
but none of these symbols
winds up in
any of the parse values.
This is because they are derived from
C<< <ambig1> >> or
C<< <ambig2> >>.
But for
C<< <ambig1> >> or
C<< <ambig2> >> to be fully recognized,
there must be a 
C<< <z> >> symbol in the input and the
input stream
in the example does not contain a
C<< <z> >> symbol.

All SLIF parse events are tentative,
not just completion events.
In the example, the predictions
for 
C<< <mid1> >> and
C<< <mid2> >> do not correspond to anything in
the final parse tree,
because the locations where
C<< <mid1> >> and
C<< <mid2> >> would be predicted are not reached in
those trees.
For similar reasons, nulling events are tentative.
And lexemes can be ambiguous, with not every lexeme
being part of a final parse tree, so lexeme
events are also tentative.

=head2 Nulled forests

When a symbol is nulled, any symbol which can be null-derived
is considered to be nulled.
In L<the example|/"An example">,
when the 
symbol C<< <g> >> is nulled,
it derived symbols
C<< <g1> >>,
C<< <g2> >>,
C<< <g3> >>,
C<< <g4> >>.

Note that what was said about
L<ambiguity|"Ambiguity">
applies here.
In the example, the symbols
C<< <g1> >> and
C<< <g2> >> are in one derivation,
while C<< <g3> >> and
C<< <g4> >> are in another,
so that not just a parse tree,
but a entire parse forest
in nulled.

More precisely,

=over 4

=item * If the grammar allows
any derivation of the symbol
I<Y> from I<X> in which I<X> and I<Y> are both
nulled; and

=item * a nulling
a SLIF parse event is declared for I<Y>; and

=item * a nulled instance of I<X> is encountered
in the parse at location I<L>; then

=item * a nulling SLIF parse event for I<Y>
will trigger at location I<L>.

=back

=head2 Events and instances

As stated above, only nulling instances generate nulling events,
and only non-nulled instances generate prediction events
and completion events.
Since lexemes cannot be zero length, this means that,
for a given symbol instance,
nulling events and all other events,
are mutually exclusive.

Some cases may seem to violate this rule.
For example
at position 23
in the parse in
L<the code below|/"An example">,
we have a nulling event and
a post-lexeme event,
a prediction event
and a completion event,
all of which are for the symbol C<< <e> >>:

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1

    Events at position 23: "e" e$ e[] ^e ^f

=for Marpa::R2::Display::End

The reason for this is that these events are
for three different symbols instances, all of which
share the same trigger location:

=over 4

=item 1

A nulled instance at location 23.

=item 2

An potential non-zero instance, which may begin
at location 23.

=item 3

A non-nulled instance, which begins at location 21
and ends at location 22.

=back

The prediction of the second instance is, in fact,
fulfilled, as reported at location 25:

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1

    Events at position 25: "e" e$ ^f

=for Marpa::R2::Display::End

The third instance ends at position 22, but it
is reported at position 23,
also because of whitespace.

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1

    Events at position 21: d$ mid1$ mid2$ e[] ^e ^f

=for Marpa::R2::Display::End

The reason that prediction and completion events exclude
nulled symbols,
is that there is no practical distinction between expecting
a zero-length symbol, and actually seeing one.
This means the prediction and completion of a nulled symbol
always occur together.
This very special nature of nulled symbols motivates their
separation into a special case.

=head2 Hidden events

An important aspect of the event mechanism is that
it always triggers a return from the event-triggering
method at the trigger location.
It may happen, however, that the method would return
at that location in any case.
When a method triggers an event, the triggering
can be said to be B<hidden>.
A event which causes hidden triggering is called
a B<hidden event>.

As one example of hidden triggering,
the
L<C<lexeme_complete()>|Marpa::R2::Scanless::R/"lexeme_complete()"> and
L<C<lexeme_read()>|Marpa::R2::Scanless::R/"lexeme_read()">
methods return at every lexeme at which a lexme is read, so
all triggering in those methods is hidden triggering.
As another example of hidden triggering,
the C<< $slr->read() >> and C<< $slr->resume() >> methods
return at end of string,
but events may also trigger at end of string.

Applications must be programmed with the possibility of hidden
triggering in mind.
The L<example below|/"An example"> is coded to access all
events, including hidden events.
To do this, it is careful to access events after its
calls to the
L< C<< $slr->lexeme_read() >>
as well as to make an additional pass through the event-accessing loop
after an end of string is encountered.

=head2 Lexeme events and external scanning

During external scanning, lexemes are read using the
L< C<< $slr->lexeme_complete() >>|Marpa::R2::Scanless::R/"lexeme_complete()"> and
L< C<< $slr->lexeme_read() >>|Marpa::R2::Scanless::R/"lexeme_read()"> methods.
Non-lexeme events may trigger during this methods, as was discussed
in L</"Hidden events">.
However, lexeme events that would occur during the
C<< $slr->lexeme_complete() >> and
C<< $slr->lexeme_read() >> methods are ignored,
and will never trigger.

While, in one sense, this is non-orthogonal behavior
it is the most consistent course of action.
A pre-lexeme event occuring during 
a C<< $slr->lexeme_complete() >> and
C<< $slr->lexeme_read() >> method call would reverse its effect,
which is at best pointless.

A post-lexeme event would be less dangerous,
but it also be completely redundant.
Its presence or absence
would only tell the application only what
it already knows when the
C<< $slr->lexeme_complete() >> or
C<< $slr->lexeme_read() >> methods
return success or failure.

=head1 An example

The SLIF DSL in this example
is unlike anything you would actually
use in practice.
It
is intended to illusrate the unusual and "corner" cases
described above.

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1

    sub forty_two { return 42; };

    use Marpa::R2;

    my $dsl = <<'END_OF_DSL';
    :default ::= action => [name,values]
    lexeme default = latm => 1

    test ::= a b c d e e f g h action => main::forty_two
        | a ambig1 | a ambig2
    e ::= <real e> | <null e>
    <null e> ::=
    g ::= g1 | g3
    g1 ::= g2
    g2 ::= 
    g3 ::= g4
    g4 ::= 
    d ::= <real d> | <insert d>
    ambig1 ::= start1 mid1 z
    ambig2 ::= start2 mid2 z
    start1 ::= b  mid1 ::= c d
    start2 ::= b c  mid2 ::= d

    a ~ 'a' b ~ 'b' c ~ 'c'
    <real d> ~ 'd'
    <insert d> ~ ["] 'insert d here' ["]
    <real e> ~ 'e'
    f ~ 'f'
    h ~ 'h'
    z ~ 'z'

    :lexeme ~ <a> pause => after event => '"a"'
    :lexeme ~ <b> pause => after event => '"b"'
    :lexeme ~ <c> pause => after event => '"c"'
    :lexeme ~ <real d> pause => after event => '"d"'
    :lexeme ~ <insert d> pause => before event => 'insert d'
    :lexeme ~ <real e> pause => after event => '"e"'
    :lexeme ~ <f> pause => after event => '"f"'
    :lexeme ~ <h> pause => after event => '"h"'

    event '^test' = predicted test
    event 'test$' = completed test
    event '^start1' = predicted start1
    event 'start1$' = completed start1
    event '^start2' = predicted start2
    event 'start2$' = completed start2
    event '^mid1' = predicted mid1
    event 'mid1$' = completed mid1
    event '^mid2' = predicted mid2
    event 'mid2$' = completed mid2

    event '^a' = predicted a
    event '^b' = predicted b
    event '^c' = predicted c
    event 'd[]' = nulled d
    event 'd$' = completed d
    event '^d' = predicted d
    event '^e' = predicted e
    event 'e[]' = nulled e
    event 'e$' = completed e
    event '^f' = predicted f
    event 'g[]' = nulled g
    event '^g' = predicted g
    event 'g$' = completed g
    event 'g1[]' = nulled g1
    event 'g2[]' = nulled g2
    event 'g3[]' = nulled g3
    event 'g4[]' = nulled g4
    event '^h' = predicted h

    :discard ~ whitespace
    whitespace ~ [\s]+
    END_OF_DSL

    my $grammar = Marpa::R2::Scanless::G->new( { source => \$dsl } );
    my $slr = Marpa::R2::Scanless::R->new(
        { grammar => $grammar, semantics_package => 'My_Actions' } );
    my $input = q{a b c "insert d here" e e f h};
    my $length = length $input;
    my $pos    = $slr->read( \$input );

    my $actual_events = q{};

    READ: while (1) {

        my @actual_events = ();

        my $next_lexeme;
        EVENT:
        for my $event ( @{ $slr->events() } ) {
            my ($name) = @{$event};
            if ($name eq 'insert d') {
               my (undef, $length) = $slr->pause_span();
               $next_lexeme = ['real d', 'd', $length];
            }
            push @actual_events, $name;
        }

        if (@actual_events) {
            $actual_events .= join q{ }, "Events at position $pos:", @actual_events;
            $actual_events .= "\n";
        }

        if ($next_lexeme) {
            $slr->lexeme_read(@{$next_lexeme});
            $pos = $slr->pos();
            next READ;
        }
        if ($pos < $length) {
            $pos = $slr->resume();
            next READ;
        }
        last READ;
    } ## end READ: while (1)

    my $expected_events = <<'=== EOS ===';
    Events at position 0: ^test ^a
    Events at position 1: "a" ^b ^start1 ^start2
    Events at position 3: "b" start1$ ^c ^mid1
    Events at position 5: "c" start2$ ^d ^mid2
    Events at position 6: insert d
    Events at position 21: d$ mid1$ mid2$ e[] ^e ^f
    Events at position 23: "e" e$ e[] ^e ^f
    Events at position 25: "e" e$ ^f
    Events at position 27: "f" g[] g1[] g3[] g2[] g4[] ^h
    Events at position 29: "h" test$
    === EOS ===

=for Marpa::R2::Display::End

=head1 Unnamed events

Use of unnamed events is strongly discouraged.
However, to support legacy code, unnamed events are still supported.

Unnamed events are declared by
L<C<:lexeme> pseudo-rules|Marpa::R2::Scanless::DSL/"Lexeme pseudo-rules">,
when
L<the C<pause> adverb|Marpa::R2::Scanless::DSL/"pause"> 
is used without an
L<the C<event> adverb|Marpa::R2::Scanless::DSL/"event">.
(The C<pause> adverb is so named, because
Marpa's SLIF parse events were once called ``pauses''.)
Since the
L<the C<pause> adverb|Marpa::R2::Scanless::DSL/"pause">
creates a SLIF parse event, but
L<the C<event> adverb|Marpa::R2::Scanless::DSL/"event">
provides the event's name,
this results in a SLIF parse event without a name --
an unnamed event.

Unnamed events cannot be accessed using
L< the C<< $slr->events() >>
method|Marpa::R2::Scanless::R/"events()">.
The only accessors for unnamed events are
the L< the C<< $slr->pause_lexeme() >>
method|Marpa::R2::Scanless::R/"pause_lexeme()">.
and the L< the C<< $slr->pause_span() >>
method|Marpa::R2::Scanless::R/"pause_span()">.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2014 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# vim: expandtab shiftwidth=4:
