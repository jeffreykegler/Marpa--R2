# Copyright 2014 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::Scanless::R - Scanless interface recognizers

=head1 Synopsis

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );
    my $self = bless { grammar => $grammar }, 'My_Actions';
    $self->{recce} = $recce;

    if ( not defined eval { $recce->read($p_input_string); 1 }
        )
    {
        ## Add last expression found, and rethrow
        my $eval_error = $EVAL_ERROR;
        chomp $eval_error;
        die $self->show_last_expression(), "\n", $eval_error, "\n";
    } ## end if ( not defined eval { $event_count = $recce->read...})

    my $value_ref = $recce->value( $self );
    if ( not defined $value_ref ) {
        die $self->show_last_expression(), "\n",
            "No parse was found, after reading the entire input\n";
    }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: Scanless recognizer semantics
partial: 1
normalize-whitespace: 1

    package My_Actions;
    sub do_parens    { shift; return $_[1] }
    sub do_add       { shift; return $_[0] + $_[2] }
    sub do_subtract  { shift; return $_[0] - $_[2] }
    sub do_multiply  { shift; return $_[0] * $_[2] }
    sub do_divide    { shift; return $_[0] / $_[2] }
    sub do_pow       { shift; return $_[0]**$_[2] }
    sub do_first_arg { shift; return shift; }
    sub do_script    { shift; return join q{ }, @_ }

=for Marpa::R2::Display::End

=head1 About this document

This page is the reference document for the recognizer objects
of Marpa's SLIF (Scanless interface).

The Scanless interface is so-called because
it does not require the application to supply a scanner (lexer).
The SLIF contains its own lexer,
one whose use is integrated into
its syntax.
In this document, use of the SLIF's
internal scanner is called
B<internal scanning>.

The SLIF allows applications that find it useful to
do their own scanning.
When an application
bypasses the SLIF's internal scanner
and does its own scanning,
this document calls it
B<external scanning>.
An application can use
external scanning to supplement internal 
scanning,
or to replace the SLIF's internal scanner entirely.

=head1 The input stream

The recognizer reads a virtual input stream.
By default, this
is identical to a physical input stream.
The physical input stream is
a Perl string passed as the first argument
to the L<C<< $slr->read() >> method|/read()> method.
Once set by the C<read()> method, the physical input
stream cannot be changed.

Physical input stream location is simply
the Perl C<pos()> location
in the physical input string.
Physical input stream location may be zero,
but is never negative.

In this document,
the phrase "input stream" and
the word "stream",
unless otherwise specified,
refer to the physical input stream.
The phrase "input stream location" and
the word "location",
unless otherwise specified,
refer
to physical input stream location,

Virtual input streams complicate the idea of parse
location,
but they are essential for some applications.
Implementing the C language's pre-processor directives require
either two passes, or
a virtual approach to the input.
And Perl here-documents cannot be parsed correctly
by an application which insists on moving forward
serially in the input.
The
SLIF allows applications to skip
backward and forward in the physical input stream,
and to read sections of the stream repeatedly.

Input streams are ordered sets of characters,
and the locations in them are
represented as the integers from 0 to I<N>,
where I<N> is the size of the set.
In this document, we will refer to ordered subsets of
contiguous locations as either B<ranges> or B<spans>.

=head1 Ranges

A range is an ordered set of contiguous locations
specified by start location and end location:
[I<S ... E>].
A range is a subset of a "universe" --
some larger ordered set of locations
0 to I<N>.
In this document the larger sets,
or universes, will be physical input streams
or L<G1 location streams|"G1 locations">.

The start and end locations of the range
refer to locations
in its universe.
Negative locations
refer to a locations relative
to the end of the range's universe, so that
-1 refers to the last location of the universe,
-2 refers to the second-to-last location of the universe,
etc.

=head1 Spans

A span is an ordered set of contiguous locations
specified by start location and length:
[I<S, L>].
A span is a subset of a universe, as was
described above for ranges.

The range corresponding to the span
[I<S, L>] is [I<S ... (S+L)-1>].
The span corresponding to the range
[I<S ... E>] is [I<S, (S-E)+1>].
A span with
a negative length
is interpreted as if it was the range
with that same pair of values.

In general, spans are more convenient for programming.
But when fencepost issues are important,
spans require a lot of mental arithmetic,
and a discussion that uses ranges is easier to follow.

As examples,

=over

=item *

The entire input stream is the range C<[0 ... -1]>
and the span C<[0, -1]>.

=item *

The entire input stream, except for the last character,
is the range C<[0 ... -2]>
and the span C<[0, -2]>.

=item *

The substring consisting only of the last character is
the range C<[-1 ... -1]> and the span C<[-1, 1]>.

=item *

The substring which consists of the last 3 characters is
the range C<[-3 ... -1]>
and the span C<[-3,  3]>.

=item *

The substring which consists
of only the third-to-last character
is the range C<[-3 ... -3]>
and the span C<[-3, 1]>.

=back

=head1 Internal scanning

The virtual input stream is a series of input strings.
An input string is a substring
of the physical input stream.
By default the virtual input stream consists of
exactly one input string,
one which begins at location 0 in the physical input stream
and whose length is the length of the physical input stream.

The SLIF always starts scanning using the L<C<read()>|/"read()">
method, and
the first input string is specified, implicitly or explicitly,
by the L<C<read()>|/"read()"> method.
When not specified, the
input string
for C<read()> defaults to the range [I<0 ... -1>].

L<C<read()>|/"read()"> will return success when it reaches the end of its
input string, or when a SLIF parse event triggers.
(Parse events are described in L<a separate
document|Marpa::R2::Event>.)
In many cases there are no parse events declared,
or none trigger.
If no parse event triggers
and the parse does not fail,
then C<read()> will read to the end of string,
leaving the recognizer ready to produce a parse value
using the L<C<< $slr->value >> method|/"value()">.

The SLIF tracks a C<current location> in the physical input stream.
On return from 
the C<read()> method,
current location will depend on the reason for the return.
If a
L<SLIF parse event|Marpa::R2::Event>
triggered, the current location will be
the trigger location;
otherwise the current location will be at the end of the
input string.

The C<read()> method may only be called once for a recognizer,
but internal scanning can be resumed with the L<C<resume()>|/"resume()"> method.
The C<resume()> method use the same physical input stream that was specified
to the C<read()> method, but uses an new input string,
which may be specified explicitly or implicitly.
By default, the new input string runs from the current location
to the end of the physical input stream.

On successful return from the 
L<C<resume()>|/"resume()"> method,
the current location is set in the same way as it for the
L<C<read()>|/"read()"> method:
the trigger location, if an event triggered;
otherwise, the end of string.
The L<C<resume()>|/"resume()"> method may be called repeatedly,
until the application considers the virtual input stream 
complete.
More details are in the reference descriptions
of the
L<C<read()>|/"read()"> and
L<C<resume()>|/"resume()"> methods, below.

When the application considers input complete,
and is ready to produced a parse value,
the L<C<< $slr->value >> method|/"value()"> method
is used.
In most cases, this is all that is needed.
But Marpa also allows repeated passes over the same input
with different settings.
More details on the semantics are provided in
L<a separate document|Marpa::R2::Semantics>.


=head1 External scanning

External scanning is usually performed by reading lexemes using the 
L<C<< $slr->lexeme_read() >> method|/"lexeme_read()">, which
allows the reading of unambiguous lexemes.
If ambiguous lexemes are needed, then
the L<C<< $slr->lexeme_alternative() >>|/"lexeme_alternative()"> and
L<C<< $slr->lexeme_complete() >>|/"lexeme_complete()"> methods can be used.

Scanning must always begin with a call 
to the L<C<read()>|/"read()"> method,
so that, in a pedantic sense, scanning always begins with internal scanning.
But the first input string may be zero length:

=for Marpa::R2::Display
name: SLIF external read example
partial: 1
normalize-whitespace: 1

    $recce->read( \$string, 0, 0 );

=for Marpa::R2::Display::End

and there is no requirement that internal scanning ever be resumed.

=head2 External lexemes and the input stream

For error message and other purposes,
even external lexemes are required to correspond to a span of the input stream.
An external scanner
must set up a relationship to the input stream,
even if that relationship is completely artificial.

Here is
one very general way to deal with external lexemes
which have no natural mapping into
the physical input stream.
Call what would ordinarily be the input string, the "natural input".
Form the physical input stream by prefixing these 7 character:
"C<NO TEXT>".
For example, if the natural text is "C<Hi! I am the real input>",
then the physical input stream will be

=for Marpa::R2::Display
ignore: 1

    "NO TEXTHi! I am the real input"

=for Marpa::R2::Display::End

To read the natural text,
the initial call to the L<C<read()>|/"read()"> method should be
of the form
C<< $slr->read($input_string, 7) >>.
When externally reading a lexeme which has no real relationship
to the natural input,
use a method call similar to
C<< $slr->lexeme_read($symbol_name, 0, 7, $value) >>.

=head1 G1 locations

In addition to input stream location,
the SLIF also tracks G1 location.
G1 locations run from 0 to I<N> and the conventions
and notation
for numbering them and describing G1 spans and ranges
are the same as for input stream locations.

G1 location can be ignored most of the time,
but it does become relevant
when tracing the G1 grammar,
and when dealing with ambiguous terminals,
(For those more familiar with Marpa's internals,
the G1 location is the G1 Earley set index.)

Because lexemes may be ambiguous,
a set of lexemes is read at a single G1 location.
If a lexeme is unambiguous,
its set will contain exactly one lexeme.
G1 location can be thought of
as location in terms of
boundaries of sets of lexemes,
so that the 
the first set of lexemes starts at G1 location 0
and ends at G1 location 1.
When we speak of a set of lexemes B<at> G1 location I<L>,
we refer to the set of lexemes ending at G1 location I<L>.
That means that there is no set of lexemes at
G1 location 0.

As each new set of lexemes is read,
G1 location 
increases by one.
B<G1 length>
is length calculated in terms of G1 locations.
For example, if a span of G1 locations which begin at G1 location
42 and has length 2, 
it will contain a pair of G1 locations: G1 location 42 and G1 location 43.

=head2 Literals and G1 spans

It is sometimes
useful to find the literal substring
of the physical input stream which corresponds to a span
of G1 locations.
If an application reads the physical stream in sequence within the G1 span
this presents no complications.
For more complcated cases, the exact rules are described in
this section.

Except for G1 location zero,
every G1 location I<X> corresponds to a range in the physical
input stream.
We'll call the physical input stream range that corresponds to
G1 location I<X>, [I<s(X) ... e(X)>].
Only two things are guaranteed about I<s(X)> and I<e(X)> as
a function of I<X>:

=over 4

=item *

I<s(X)> and I<e(X)> are not defined when I<X> is zero.

=item *
It will always be the case that
I<< s(X) <= e(X) >>.

=back

In mapping ranges of G1 locations to ranges of physical
input stream locations, there are several complications:

=over 4

=item *

There is a fencepost versus interval issue:
physical input stream locations correspond to characters,
but G1 locations are locations before and after characters.

=item *

Both kinds of locations are zero-based,
but G1 location 0 does not corresponds to a range in
the physical input stream.

=item *

Scanning is allowed to skip backward and forward,
so the mapping of G1 location to physical stream locations
is not necessarily monotonic.
For example, if I<X> and I<Y> are G1 locations
such that I<< X < Y >>,
it is possible that
I<< s(X) > e(Y) >>.

=item *

Repeated scanning of the same physical input stream locations
is allowed, as well as overlaps.
For example, if I<X> and I<Y> are G1 locations,
it is possible that
I<< s(X) < s(Y) < e(X) < e(Y) >>.

=item *

Even when there is a monotonic function from G1 location to physical
input stream span,
there will usually be gaps.
For example, applications typically discard whitespace.
This means that if I<W> is the physical input stream location of
a whitespace character,
there will be no G1 location I<X> such that
I<< s(X) <= W <= e(X) >>.

=back

To cope with these situations,
the following rules are used when
translating G1 locations into literal substrings
of the physical input stream.

=over 4

=item *

If [I<X ... Y>] is a G1 range,
and
I<< s(X) < e(Y) >>,
the literal will be
substring made of the characters in the
physical input stream range [I<s(X) ... e(Y)>].

=item *

If I<< s(X) >= e(Y) >>,
the literal will be the empty string.

=back

For applications which read the physical input stream in lexical order,
without skipping forward,
the above rules will work as expected.
For other applications,
the above may be "close enough".
But some applications
may want to use custom logic to reassemble the input
from the physical input stream.
The L</"literal()"> method can assist in this process.

=head1 Recognizer settings

The B<recognizer settings> are the named arguments
accepted by
the B<recognizer setting-aware methods>
are
the L<C<new()>|/"Constructor">,
L<C<set()>|/"set()"> and
L<C<series_restart()>|"series_restart()"> methods.
Not every recognizer setting-aware method accepts all of the settings.
The details are given below, by setting.

=head2 end

Most users will not need this setting.
It is an advanced argument.
The L<C<end>|/"end"> setting
specifies the parse end, as a G1 location.
The default is for the parse to end where the input did,
so that the parse returned is of the entire virtual input stream.
The L<C<end>|/"end"> setting is only allowed in
the L<C<new()>|/"Constructor">,
and L<C<series_restart()>|"series_restart()"> methods.

=head2 grammar

The value of the C<grammar> setting must be
an SLIF grammar object.
The C<new()> method is required to have
a C<grammar> setting.
The C<grammar> setting is only allowed
the L<C<new() method>|/"Constructor">.
Once the recognizer is created, the grammar cannot be
changed.

=head2 max_parses

If non-zero, causes a fatal error when that number
of parse results is exceeded.
C<max_parses> is useful to
limit CPU usage and output length when testing
and debugging.
Stable and production applications may
prefer to count the number of parses,
and take a less Draconian response when the
count is exceeded.

The value must be an integer.
If it is zero, there will be no
limit on the number of parse results returned.
The default is for
there to be no limit.
The C<max_parses> setting is valid in all
calls of the recognizer setting-aware methods.

=head2 ranking_method

The value must be a string:
one of "C<none>",
"C<rule>",
or "C<high_rule_only>".
When the value is "C<none>", Marpa returns the parse results
in arbitrary order.
This is the default.

The "C<rule>"
and "C<high_rule_only>" ranking methods
allows the user
to control the order
in which parse results are returned by
the C<value> method,
and to exclude some parse results from the parse series.
For details, see L<the document
on parse order|Marpa::R2::Semantics::Order>.

The C<ranking_method> setting is not allowed
once evaluation of the current parse series has begun.
Specifically,
The L<C<ranking_method>|/"ranking"> setting is always allowed in
the L<C<new()>|/"Constructor">,
and L<C<series_restart()>|"series_restart()"> methods,
because they initialize a new parse series.
And, while a parse series is in progress,
the L<C<ranking_method>|/"ranking"> setting is allowed in
calls of the
L<C<< $slr->set() >>|"set()"> method,
up until the first call of the
L<C<< $slr->value() >>|"value()"> method.

=head2 semantics_package

Sets the semantic package for the recognizer.
This setting takes precedence
over any package implied by the blessing of the per-parse arguments to
the SLIF recognizer's C<value()> method.
The semantics package is used when resolving action names to
fully qualified Perl names.
For more details on the SLIF semantics,
see the L<document on SLIF
semantics|Marpa::R2::Semantics>.

The L<C<semantics_package>|/"semantics_package"> setting is only allowed in
when a new parse series is begun.
That is, it is only allowed in calls
of the L<C<new()>|/"Constructor">
and L<C<series_restart()>|"series_restart()"> methods.

=head2 too_many_earley_items

The C<too_many_earley_items> setting is optional,
and very few applications will need it.
If specified, it sets the B<Earley item warning threshold> to
a value other than its default.
If an Earley set becomes larger than the
Earley item warning threshold,
a recognizer event is generated,
and
a warning is printed to the trace file handle.

Marpa parses from any BNF,
and can handle grammars and inputs which produce very large
Earley sets.
But parsing that involves very large Earley sets can be slow.

By default, Marpa calculates
an Earley item warning threshold
for the G1 recognizer
based on the size of the
G1 grammar,
and for each L0 recognizer based on the size
of the L0 grammar.
The default thresholds will never be less than 100.
The default is the result of considerable experience
and almost all users will be happy with it.

If the
Earley item warning threshold is changed from its default,
the change applies to both L0 and G1 -- currently
there is no way to set them separately.
If the Earley item warning threshold is set to 0,
no recognizer event is generated,
and
warnings about large Earley sets are turned off.
An Earley item threshold warning almost always
indicates a serious issue,
and turning these warnings off will
rarely be what an application wants.

The C<too_many_earley_items> setting is allowed
in any call of any of the recognizer setting-aware methods.

=head2 trace_terminals

If non-zero, traces the lexemes --
those tokens passed from the L0 parser to
the G1 parser.
This recognizer setting is the best way to follow
what the L0 parser is doing,
and it is also very helpful for tracing the G1 parser.
The C<trace_terminals> setting is allowed
in any call of any of the recognizer setting-aware methods.

=head2 trace_values

The value of the C<trace_values> setting is a numeric trace level.
If the
numeric trace level is 1, Marpa prints tracing information as values
are computed in the evaluation stack.  A trace level of 0 turns
value tracing off, which is the default. Traces are written to the
trace file handle.
The C<trace_values> setting is allowed
in any call of any of the recognizer setting-aware methods.

=head2 trace_file_handle

The value is a file handle.
Trace output and warning messages
go to the trace file handle.
By default, the trace file handle is inherited from the
grammar.
The C<too_many_earley_items> setting is allowed
in any call of any of the recognizer setting-aware methods.

=head1 Constructor

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );

=for Marpa::R2::Display::End

The C<new()> method is the constructor for SLIF recognizers.
The arguments to the
the C<new()> constructor must be one or more hashes of named arguments,
where each hash key is a recognizer setting.
The L<C<grammar>|/"grammar"> recognizer setting is required.
All other recognizer settings are optional.
For more on recognizer settings,
see
L<the section describing them|/"Recognizer settings">.

=head1 Basic mutators

=head2 ambiguous()

=for Marpa::R2::Display
name: Tutorial 2 synopsis
partial: 1
normalize-whitespace: 1

    if ( my $ambiguous_status = $recce->ambiguous() ) {
        die "Parse is ambiguous\n", $ambiguous_status;
    }

=for Marpa::R2::Display::End

This method should be called after the C<read()> method.
If there is exactly one parse, it returns the empty string.
If there is no parse, it returns a non-empty string indicating that fact.
If there are two or more parses,
it returns a non-empty string describing the ambiguity.

Applications should only test the returned string to see if it is
empty or non-empty.
The non-empty strings are intended only for reading by
humans -- their exact format is subject to change.

=head2 read()

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    $recce->read($p_input_string);

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: SLIF external read example
partial: 1
normalize-whitespace: 1

    $recce->read( \$string, 0, 0 );

=for Marpa::R2::Display::End

Given a pointer to a physical input stream and,
optionally, a span specifying an input string within it,
C<read()> parses input string according to the grammar.
C<read()> returns successfully if it parses to the end
of the input string,
or if it triggers a SLIF parse event.
Only a single call to C<read()>
is allowed for a scanless
recognizer.

The first argument of C<read()> is a pointer to the physical
input stream, which by default will also be the virtual input stream.
C<read()> recognizes
optional second and third arguments and treats them
as the start and length
of a L<span|/"Spans"> of the physical input stream.
The default start location is zero.
The default length is -1.
Negative locations and lengths are 
and interpreted as L<described above|/"Spans">.

If a SLIF parse event occurs during the C<read()> method,
the current location is set to the trigger location.
SLIF parse events are described in detail in
L<a separate document|Marpa::R2::Event>.
If no SLIF parse event triggers,
and the parse reaches the end of the input string without a
failure,
the current location is set to the end of the input string.

The call is considered successful
if it reached the end of input string,
or if a SLIF parse event triggered.
On success, C<read()> returns the current
physical input stream location.
This value may be zero.
On failure, C<read()> throws an exception.

=head2 series_restart()

=for Marpa::R2::Display
name: SLIF recognizer series_restart() synopsis
normalize-whitespace: 1

    $slr->series_restart( { end => $i } );

=for Marpa::R2::Display::End

The C<series_restart()> method ends the current parse series,
and starts another.
It allows, as optional arguments, hashes of named arguments
for the SLIF recognizer.
These named arguments can be any of those allowed by
L<the C<set()> method|/"set()>.

C<series_restart()> resets all the named arguments to their defaults.
An application that wants a non-default named argument to have effect
in each of its parse
series must respecify it at the beginning of each parse series.
C<series_restart()> is particularly useful for
the 
C<end> and C<semantics_package> named arguments,
which cannot be changed once a parse series is underway.
To change their values,
an application must start a new parse series.

=head2 set()

=for Marpa::R2::Display
name: SLIF recognizer set() synopsis
normalize-whitespace: 1

    $slr->set( { max_parses => 42 } );

=for Marpa::R2::Display::End

This method allows the named arguments to be changed after a SLIF
grammar is created.
The arguments to
C<set()> must be one or more hashes of named arguments,
where each hash key is a recognizer setting.
For more on recognizer settings,
see
L<the section describing them|/"Recognizer settings">.

=head2 value()

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $value_ref = $recce->value( $self );

=for Marpa::R2::Display::End

The C<value> method call evaluates the next parse tree
in the parse series,
and returns a reference to the parse result for that parse tree.
If there are no more parse trees,
the C<value> method returns C<undef>.

Because Marpa parses ambiguous grammars, every parse
is a series of zero or more parse trees.
This series of zero or more parse trees is called a B<parse series>.
There are zero parse trees if there was no valid parse
of the input according to the grammar.

The C<value()> method allows one optional argument.
If provided, the argument
explicitly specifies the per-parse argument for the
parse tree.
This per-parse argument can be a Perl scalar of any kind, but the most useful
type for a per-parse argument is a reference
(blessed or unblessed) to a hash or to an array.
The per-parse argument will be the first argument of all 
Perl semantics closures.
When data does not conveniently fit into the bottom-up
flow of parse tree evaluation,
the per-parse argument
is useful for sharing it within
the tree.
Symbol tables are one example of the kind of data which parses often
require, but which it is not convenient to accumulate bottom-up.

If the L<C<semantics_package>|/"semantics_package"> named argument of the SLIF
recognizer was not specified,
Marpa will use the package into which the per-parse argument was blessed
as the semantics package --
the package in which to look for the parse's Perl semantic closures.
In this case, Marpa will regard the per-parse arguments of all
calls in the same parse series as the source of the semantics package,
and it will require that the calls be consistent --
each call must have a per-parse argument,
and that per-parse argument  must be blessed into the semantics package.

=head1 Mutators for external scanning

=head2 activate()

=for Marpa::R2::Display
name: SLIF activate() method synopsis
partial: 1
normalize-whitespace: 1

        $slr->activate($_, 0) for @events;

=for Marpa::R2::Display::End

The C<activate()> method allows the recognizer to deactivate and reactivate
SLIF parse events.
SLIF parse events are described in
L<a separate document|Marpa::R2::Event>.

The C<activate()> method takes two arguments.
The first is the name of an event, and the second (optional) argument is
0 or 1.
If the argument is 0, the event is deactivated.
If the argument is 1, the event is reactivated.
An argument of 1 is the default.
but,
since an SLIF recognizer always starts with all defined events
activated,
0 will probably be more common as the second argument to
C<activate()>

Location 0 events are triggered in the SLIF recognizer's 
constructor,
before the C<activate()> method can be called.
Currently there is no way to deactivate
location zero events.

The overhead imposed by events
can be reduced by using the C<activate()> method.
But making many calls to the
the C<activate()> method purely for efficiency
purposes will be counter-productive.
Also, deactivated events still impose
some overhead, so if an event is never used
it should be commented out in the SLIF DSL.

=head2 lexeme_alternative()

=for Marpa::R2::Display
name: SLIF lexeme_alternative() example
partial: 1
normalize-whitespace: 1

            if ( not defined $recce->lexeme_alternative($token_name) ) {
                die
                    qq{Parser rejected token "$long_name" at position $start_of_lexeme, before "},
                    substr( $string, $start_of_lexeme, 40 ), q{"};
            }

=for Marpa::R2::Display::End

The C<lexeme_alternative()> method
allows an external scanner to read
ambiguous tokens.
Most applications 
will prefer the simpler L<C<lexeme_read()>|/"lexeme_read()">.

C<lexeme_alternative()> takes one or two arguments.
The first argument,
which is required,
is the name of a symbol to be read
at the current location.
The second argument,
which is optional,
is the value of the symbol.
The value argument is interpreted as described for C<lexeme_read()>.

Any number of tokens may be read using C<lexeme_alternative()>
without advancing the current location.
This allows an application to use ambiguous tokens.
To complete reading at a G1 location,
and advance the current G1 location to the next G1 location,
use the L<C<lexeme_complete()>|/"lexeme_complete()"> method.

On success, returns a non-negative number.
Returns C<undef> if the token was rejected.
Failures are thrown as exceptions.

=head2 lexeme_complete()

=for Marpa::R2::Display
name: SLIF lexeme_alternative() example
partial: 1
normalize-whitespace: 1

            next TOKEN
                if $recce->lexeme_complete( $start_of_lexeme,
                        ( length $lexeme ) );

=for Marpa::R2::Display::End

The C<lexeme_complete()> method allows an external scanner to read
ambiguous tokens.
Most applications will prefer the simpler C<lexeme_read()>.

The C<lexeme_complete()> method
requires two arguments,
which represent the start and length parameters of
a span in the physical input stream.
The span is interpreted as described for the
L<the C<lexeme_read()> method|/"lexeme_read()">.

The C<lexeme_complete()>
method completes the reading of
alternative tokens at the current G1 location,
and advances the current G1 location by one.
Current location in the input stream is moved
to the location after the new lexeme,
as indicated by the arguments.

SLIF parse events may occur during
the L<lexeme_complete()> method,
as described for the
L<the C<lexeme_read()> method|/"lexeme_read()">.

B<Return value:>
On success, C<lexeme_complete()>
returns the new current location.
This will never be location zero, because a succesful
call of C<lexeme_complete()> always advances the location.
On unthrown failure, C<lexeme_complete()> returns 0.

=head2 lexeme_read()

=for Marpa::R2::Display
name: SLIF read/resume example
partial: 1
normalize-whitespace: 1

    $re->lexeme_read( 'lstring', $start, $length, $value ) // die;

=for Marpa::R2::Display::End

The C<lexeme_read()> method reads a single, unambiguous, lexeme.
It takes four arguments, only the first of which is required.
The first argument is the lexeme's symbol name.
The second and third arguments specify the span in
the physical input stream
The last argument specifies the value of the lexeme.

In the span specified by
the second and third arguments,
the start location defaults to the current location.
If the pause span is defined,
and the start of the pause lexeme is
the same as the current location,
length defaults to the length of the pause span.
Otherwise length defaults to -1.
Negative values are allowed and are interpreted
as L<described above|/"Spans">.

This span will be treated as the section of the input stream
that corresponds to the tokens read at the current location.
This correspondence may be artificial, but a span must
always be specified.

IF the fourth argument specifying the value of the lexeme
is omitted,
the token's value will be a string
containing the corresponding substring
of the input stream.
Omitting the value argument does not have the same
effect as passing an explicit Perl C<undef>.
If the value argument is an explicit Perl C<undef>,
the value of the lexeme will be a Perl C<undef>.

=for Marpa::R2::Display
ignore: 1

    $slr->lexeme_read($symbol, $start, $length, $value)

=for Marpa::R2::Display::End

is the equivalent of

=for Marpa::R2::Display
ignore: 1

    $slr->lexeme_alternative($symbol, $value)
    $slr->lexeme_complete($start, $length)

=for Marpa::R2::Display::End

Non-lexeme
SLIF parse events may trigger during the C<lexeme_read()> method.
Lexeme SLIF parse events are ignored because they are designed
to allow switching over to external scanning, and
therefore make no sense when external scanning is already in progress.
SLIF parse events are described in detail in
L<a separate document|Marpa::R2::Event>.

Current input stream location will be set
to C<$start+$length>.
If a SLIF parse event triggers, current input stream location
will be set to the trigger location but currently this
is always the same as
C<$start+$length>.
Current G1 location is advanced by one.

On success, C<lexeme_read()> returns the new current location.
This will never be location zero, because lexemes cannot be zero length.
If the token was rejected, returns a Perl C<undef>.
On other unthrown failure, returns 0.

=head2 resume()

=for Marpa::R2::Display
name: SLIF read/resume example
partial: 1
normalize-whitespace: 1

    my $re = Marpa::R2::Scanless::R->new(
        {   grammar           => $parser->{grammar},
            semantics_package => 'MarpaX::JSON::Actions'
        }
    );
    my $length = length $string;
    for (
        my $pos = $re->read( \$string );
        $pos < $length;
        $pos = $re->resume()
        )
    {
        my ( $start, $length ) = $re->pause_span();
        my $value = substr $string, $start + 1, $length - 2;
        $value = decode_string($value) if -1 != index $value, '\\';
        $re->lexeme_read( 'lstring', $start, $length, $value ) // die;
    } ## end for ( my $pos = $re->read( \$string ); $pos < $length...)
    my $per_parse_arg = bless {}, 'MarpaX::JSON::Actions';
    my $value_ref = $re->value($per_parse_arg);
    return ${$value_ref};

=for Marpa::R2::Display::End

The C<resume()> method resumes
the SLIF's internal scanning,
L<as described
above|/"Internal scanning">.
A physcial input stream must already have
been specified using the 
L<C<< $slr->read() >> method|/"read()">.

The C<resume()> method takes two optional arguments,
which represent the start and length parameters of
a span.
The default start location is the current location.
The default length is -1.
Negative arguments are interpreted
as L<described above|/"Spans">.

If a SLIF parse event occurs during the C<read()> method,
the current location is set to the trigger location.
SLIF parse events are described in detail in
L<a separate document|Marpa::R2::Event>.
If no SLIF parse event triggers,
and the parse reaches the end of the input string without a
failure,
the current location is set to the end of the input string.

The call is considered successful
if it reached the end of input string,
or if a SLIF parse event triggered.
On success, C<resume()> moves
the current location to where it paused,
or to the EOS.

On success, C<resume()> returns
the new current location.
On unthrown failure,
C<resume()> return a Perl C<undef>.

=head1 Accessors

=head2 ambiguity_metric()

=for Marpa::R2::Display
name: Scanless ambiguity_metric() synopsis

    my $ambiguity_metric = $slr->ambiguity_metric();

=for Marpa::R2::Display::End

Returns 1 if there is an unambiguous parse,
and 2 or greater if there is a ambiguous parse.
Returns 0 if called before parsing.
Returns 0 or less than zero on other unthrown failure.

=head2 current_g1_location()

=for Marpa::R2::Display
name: Scanless current_g1_location() synopsis

    my $current_g1_location = $slr->current_g1_location();

=for Marpa::R2::Display::End

Returns the current G1 location.

=head2 events()

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1
partial: 1

        EVENT:
        for my $event ( @{ $slr->events() } ) {
            my ($name) = @{$event};
            push @actual_events, $name;
        }

=for Marpa::R2::Display::End

The C<events()> method takes no arguments,
and returns an array of event descriptors.
It returns the empty array
if there were no event.

Each named event descriptor is a reference to an array of one,
and potentially more, elements.
The first element of every named event descriptor is a string
containing the name of the event,
and this is typically the only element.
In certain cases, there could be
other elements of a named event descriptor,
which will be
as described for the type of named event.
Named events are
L<described in the SLIF
DSL|Marpa::R2::Scanless::DSL/"Named event statement">.

Events occur during the
L<the Scanless recognizer's read()|/"read()">,
L<resume()|/"resume()">,
L<lexeme_complete()|/"lexeme_complete()">,
and L<lexeme_read()|/"lexeme_read()">
methods.
Any subsequent call
to an SLIF recognizer mutator may clear the list
of triggered events,
The assumption is that
an application interested in events
will call
the C<events()> method almost as soon as
control is returned to it.

Named events are returned in order by type.
Completion events are first.
They are followed by the nulled events.
These are in turn followed by prediction events.
Within each type,
the order of events is arbitrary.

Applications may find it convenient to
turn specific events off,
temporarily or permanently.
Events may be activated or deactivated
with the SLIF recognizer's
L<activate() method|/"activate()">.

=head2 exhausted()

=for Marpa::R2::Display
name: $slr->exhausted example

    my $exhausted_status = $slr->exhausted();

=for Marpa::R2::Display::End

The exhausted method returns a Perl true if parsing in a SLIF
recognizer is
exhausted, and a Perl false otherwise. Parsing is exhausted when the
recognizer will not accept any further input.

Marpa usually "does what you mean" in case of parse exhaustion,
but this method
allows the recognizer's exhaustion status to be discovered directly.
Parse exhaustion is discussion in detail in
L<a separate document|Marpa::R2::Exhaustion>.

=head2 g1_location_to_span()

=for Marpa::R2::Display
name: Scanless g1_location_to_span() synopsis

        my ( $span_start, $span_length ) =
            $slr->g1_location_to_span($g1_location);

=for Marpa::R2::Display::End

G1 locations do not correspond to a single input stream
location, but to a span of them.
The C<g1_location_to_span()> method
returns an B<array> of two elements, representing a span in the input stream.
The first element of the array is the input stream location
where the span starts.
The second element of the array is the length of the span.
As a special case,
the input stream span for G1 location 0 is always (0,0).

Sometimes it is convenient to think of
G1 location as corresponding to a single input stream location.
When this is the case,
what is usually intended is the last input stream location
of the span.
The last input stream location
of the span
will always be C<$span_start+$span_length>.

=head2 input_length()

=for Marpa::R2::Display
name: SLIF input_length() example
partial: 1
normalize-whitespace: 1

    my $input_length = $slr->input_length();

=for Marpa::R2::Display::End

The C<input_length()> method accepts no arguments,
and returns the length of the input stream.

=head2 last_completed()

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    sub show_last_expression {
        my ($self) = @_;
        my $recce = $self->{recce};
        my ( $g1_start, $g1_length ) = $recce->last_completed('Expression');
        return 'No expression was successfully parsed' if not defined $g1_start;
        my $last_expression = $recce->substring( $g1_start, $g1_length );
        return "Last expression successfully parsed was: $last_expression";
    } ## end sub show_last_expression

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    my ( $g1_start, $g1_length ) = $recce->last_completed('Expression');

=for Marpa::R2::Display::End

Given the name of a symbol,
returns the start G1 location and
the length in G1 locations of the most recent match.
If there was more than one most recent match, it returns
the longest.
If there was no match, returns the empty array in array context
and a Perl false in scalar context.

=head2 line_column()

=for Marpa::R2::Display
name: SLIF trace example
partial: 1
normalize-whitespace: 1

    my ( $start, $span_length ) = $re->pause_span();
    my ( $line,  $column )      = $re->line_column($start);

=for Marpa::R2::Display::End

The C<line_column()> method accepts one, optional, argument:
a location in the input stream.
The location defaults to the current location.
C<line_column()> returns the corresponding line and column position,
as a 2-element array.
The first element of the array is the line position,
and the second element is the column position.

Numbering of lines and columns is 1-based,
following UNIX editor tradition.
Except at EOF, the line and column will be that of an
actual character.
At EOF the line number
will be that of the last line,
and the column number will be that of the last column
plus one.
Applications which want to treat EOF as a special case
can test it for using the L<C<pos()> method|/"pos()">
and the L<C<input_length()> method|/"input_length()">.

A line is considered to end with any newline sequence
as defined in the
Unicode Specification 4.0.0, Section 5.8.
Specifically, a line ends with one of the following:

=over 4

=item *

a LF (line feed U+000A);

=item * 

a CR (carriage return, U+000D), when it is not followed by a LF;

=item *

a CRLF sequence (U+000D,U+000A);

=item *

a NEL (next line, U+0085);

=item *

a VT (vertical tab, U+000B);

=item *

a FF (form feed, U+000C);

=item *

a LS (line separator, U+2028) or

=item *

a PS (paragraph separator, U+2029).

=back

=head2 literal()

=for Marpa::R2::Display
name: SLIF trace example
partial: 1
normalize-whitespace: 1

    my $literal_string = $re->literal( $start, $span_length );

=for Marpa::R2::Display::End

The C<literal()> method accepts two arguments,
the start location and length of a span in the
input stream.
It returns the substring of the input stream
corresponding to that span.

=head2 pause_lexeme()

=for Marpa::R2::Display
name: SLIF trace example
partial: 1
normalize-whitespace: 1

   my $lexeme = $re->pause_lexeme();

=for Marpa::R2::Display::End

Use of this method is discouraged.
New applications should avoid it.
Instead a named event should be used,
and the name of the event used to determine the name of
the lexeme which triggered the lexeme event.

The C<pause_lexeme()> method accepts no arguments.
It returns the name of the lexeme which triggered the most
recent lexeme SLIF parse event.

More than one lexeme may cause a pause.
When this is the case,
all the causal lexemes will be
acceptable to the G1 grammar,
and all the causal lexemes will have
the same lexeme priority.
When more than one lexeme causes a pause,
the choice of pause
lexeme is arbitrary.
Applications may not rely on a particular choice,
or on that choice being repeated,
even when the choice is made
in similar or identical circumstances.

If the most recent call of
an event-triggering method did not trigger
a lexeme event,
or if no event-triggering method has yet been called
for the current parse series,
the pause lexeme is undefined.
C<pause_lexeme()> returns a Perl C<undef> when
the pause lexeme is undefined.

=head2 pause_span()

=for Marpa::R2::Display
name: SLIF read/resume example
partial: 1
normalize-whitespace: 1

    my ( $start, $length ) = $re->pause_span();

=for Marpa::R2::Display::End

The C<pause_span()> method accepts no arguments,
and returns the "pause span" as a 2-element array.
The "pause span" is
the start location and length of the lexeme which caused
the most recent pause.
The pause span is initially undefined
and it is reset to undefined at the beginning of
each call to the L<C<read()>|/"read()"> or L<C<resume()>|/"resume()"> methods.

A pause is not always caused by a lexeme -- internal
scanning may be paused
because of the length argument of an internal scanning method.
When the most recent pause was not caused by a lexeme,
no span can be associated with it,
and the pause span is undefined.
C<pause_span()> returns a Perl C<undef> if
the pause span is undefined.

=head2 pos()

=for Marpa::R2::Display
name: SLIF pos() example
partial: 1
normalize-whitespace: 1

    my $pos = $slr->pos();

=for Marpa::R2::Display::End

The C<pos()> method accepts no arguments,
and returns the current input stream location.

=head2 progress()

=for Marpa::R2::Display
name: Scanless progress() synopsis

    my $progress_output = $slr->progress();

=for Marpa::R2::Display::End

Returns an array that describes the progress
of a parse
at a location.
With no argument, C<progress()> reports progress at
the current location.
If a G1 location is
given as its argument,
C<progress()> reports progress at that G1 location.
The G1 location may be negative.
An argument of I<-X>
will be interpreted as location I<N+X+1>, where I<N> is
the current G1 location.
In other words, an argument of -1 indicates the current G1 location,
an argument of -2 indicates the G1 location just before
the current one, etc.

The progress reports returned by
the C<progress()> method
identify rules by their G1 rule ID.
G1 rules IDs can be converted to a list of the rule's
symbols using the L<C<rule()> method
of the SLIF grammar|Marpa::R2::Scanless::G/"rule()">.
Details on progress reports can be found in
L<their own document|Marpa::R2::Progress>.

=head2 show_progress()

=for Marpa::R2::Display
name: Scanless show_progress() synopsis
partial: 1
normalize-whitespace: 1

    my $show_progress_output = $slr->show_progress();

=for Marpa::R2::Display::End

Shows the progress of the G1 parse.
For a description of its output,
see L<Marpa::R2::Progress>.

With no arguments,
the string contains reports for
the current location.
If locations are specified as arguments to
C<show_progress()>, they need to be 
G1 locations.

With a single integer argument I<N>,
the string contains reports for G1 location I<N>.
With two numeric arguments, I<N> and I<M>, the arguments are interpreted
as the start and end points of a range of G1 locations
and the returned string contains
reports for all locations in the range.

If an argument is negative,
I<-N>,
it indicates
the I<N>th location counting backward
from the furthest location of the parse.
For example, if 42 was the furthest G1 location,
-1 would be G1 location 42 and -2 would be location 41.
For example, the method call
C<< $recce->show_progress(-3, -1) >>
returns reports for the last three G1 locations of the parse.
The method call C<< $recce->show_progress(0, -1) >>
will print progress reports for the entire parse.

Locations are G1 locations instead of string offsets,
for two reasons.
First, G1 parse state is only defined at the start of parsing,
and at the end of a non-discarded lexeme.
Therefore many strings offsets will not have a G1 parse state.
Second, SLIF recognizers using external scanning are allowed
to rescan the same string repeatedly.
Therefore, a single string offset may have many
G1 parse states.

=head2 substring()

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    my $last_expression = $recce->substring( $g1_start, $g1_length );

=for Marpa::R2::Display::End

Given a G1 span -- that is, a G1 start location and a length in G1 locations --
the C<substring()> method
returns a substring of the input
stream.
A G1 length of zero will produce the zero-length string.

The substring of the input stream is determined on the assumption
that the application reads the input monotonically.
When this is not the case, the substring is determined as
L<described above|/"Literals and G1 spans">.

=head2 terminals_expected()

=for Marpa::R2::Display
name: Scanless terminals_expected() synopsis
normalize-whitespace: 1

    my @terminals_expected = @{$slr->terminals_expected()};

=for Marpa::R2::Display::End

Returns a reference to a list of strings, where the strings are the
names of the lexemes acceptable at the current location.
The presence of a lexeme in this list means
that lexeme will be acceptable in the next call of the L<C<resume()>|/"resume()"> method.

This is highly useful for Ruby Slippers parsing.
A more fine-tuned approach is to identify the lexemes of interest
and create "predicted symbol" events for them.

=head1 Discouraged methods

Methods in this section continue to be supported, but their use is
discouraged in favor of other, better solutions.
New applications should avoid using discouraged methods.

=head2 event()

=for Marpa::R2::Display
name: SLR event() method synopsis
normalize-whitespace: 1
partial: 1

            my $event    = $slr->event($event_ix);

=for Marpa::R2::Display::End

Use of this method is discouraged in favor of the more efficient
L<events() method|/"events()">.
The C<event()> method requires one argument,
an event index.
It returns a descriptor of
the named event with that index, or a Perl C<undef>
if there is no such event.
For more details on events, see the 
L<description of the events() method|/"events()">.

=head2 last_completed_range()

Use of this method is discouraged in favor of 
L</"last_completed()">.
Given the name of a symbol,
C<last_completed_range()>
returns the G1 start and G1 end locations of the most recent match.
If there was more than one most recent match,
C<last_completed_range()>
returns the longest.
If there was no match,
C<last_completed_range()>
returns the empty array in array context
and a Perl false in scalar context.

=head2 range_to_string()

Use of this method is discouraged in favor of 
L</"substring()">.
Given a G1 start and a G1 end location,
C<range_to_string()>
returns the substring of the input
stream that is between the two.
The C<range_to_string()> method 
assumes that
the application read forward smoothly in the input stream,
while reading
the sequence of G1 locations.
When that is not the case,
C<range_to_string()> behaves in
much the same way as described above
for L</"substring()">.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2014 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:

