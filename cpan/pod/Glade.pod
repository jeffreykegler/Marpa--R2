# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::Glade - Low-level interface to Marpa's ASF's

=head1 Synopsis

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 1
normalize-whitespace: 1

  my $grammar = Marpa::R2::Scanless::G->new(
      {   source => \(<<'END_OF_SOURCE'),
  :start ::= pair
  pair ::= duple | item item
  duple ::= item item
  item ::= Hesperus | Phosphorus
  Hesperus ::= 'a'
  Phosphorus ::= 'a'
  END_OF_SOURCE
      }
  );

  my $slr = Marpa::R2::Scanless::R->new( { grammar => $grammar } );
  $slr->read( \'aa' );
  my $asf = Marpa::R2::ASF->new( { slr => $slr } );
  die 'No ASF' if not defined $asf;
  my $output_as_array = asf_to_basic_tree($asf);
  my $actual_output   = array_display($output_as_array);

=for Marpa::R2::Display::End

The code for C<asf_to_basic_tree()> represents a user-supplied call
using the interface described below.  An full example of C<ast_to_basic_tree()>,
which constructs a Perl array "tree",
is given
L<below|/"The code for ast_to_basic_tree()">.
C<array_display()> displays the tree in a compact form.
The code for it is also given L<below|/"The code for array_display()">.
The return value of C<array_display()> is as follows:

=for Marpa::R2::Display
name: ASF low-level calls synopsis, output
remove-display-indent: 1
remove-blank-last-line: 1

    Glade 2 has 2 symches
      Glade 2, Symch 0, pair ::= duple
        Glade 6, duple ::= item item
          Glade 8 has 2 symches
            Glade 8, Symch 0, item ::= Hesperus
              Glade 13, Hesperus ::= 'a'
                Glade 15, Symbol 'a': "a"
            Glade 8, Symch 1, item ::= Phosphorus
              Glade 1, Phosphorus ::= 'a'
                Glade 17, Symbol 'a': "a"
      Glade 2, Symch 1, pair ::= item item
        Glade 8 revisited

=for Marpa::R2::Display::End

=head1 This INTERFACE is ALPHA and EXPERIMENTAL

The interface described in this document is very much a work in progress.
It is alpha and experimental.
The bad side of this is that it is subject to radical change without notice.
The good side is that field is 100% open for users
to have feedback into the final interface.

=head1 About this document

This document describes the low-level interface to Marpa's abstract syntax forests (ASF's).
An ASF is an efficient and practical way to represent multiple abstract syntax trees (AST's).
This low-level interface allows the maximum flexiblity in building the forest,
but requires the application to do much of the work.
A higher-level interface is planned.

=head1 Ambiguity: factoring versus symches

An abstract syntax forest (ASF) is similar to an abstract syntax tree (AST), but it
has an additional ability -- it can represent an ambiguous parse.
Ambiguity in a parse can come in two forms, and Marpa's ASF's treat the
distinction as important.  An ambiguity can be a symbolic choice
(symch), or a factoring.  Symbolic choices are the kind of ambiguity
that springs first to mind -- a choice between rules, or a choice
between a rule and token.  Factorings involve only one rule,
but in factoring that one rule divides the input up in different ways.
I'll give examples below.

Symches and factorings are treated separately,
because they behave very differently:

=over 4

=item * Symches are less common than factorings.

=item * Factorings are frequently not of interest; symches are almost
always of major interest.

=item * Symches usually have just a few alternatives; the
possible number of factorings easily grows into the thousands.

=item * Even in the worst case, the number of symches is less than
a finite constant, which depends on the grammar and is of reasonable size.
The maximum number of factorings
grows exponentially with the length of the string being factored, and has
no limit.

=back

=head2 An example of a symch

For the grammar,

=for Marpa::R2::Display
name: ASF symch dump example grammar
remove-display-indent: 1
remove-blank-last-line: 1

    :start ::= planet
    planet ::= hesperus
    planet ::= phosphorus
    hesperus ::= venus
    phosphorus ::= venus
    venus ~ 'venus'

=for Marpa::R2::Display::End

and the input string 'venus', the forest would look like

=for Marpa::R2::Display
name: ASF symch dump example output
remove-blank-last-line: 1
remove-display-indent: 1

    Symbol #0 planet has 2 symches
      Symch #0.0
      GL2 Rule 1: planet ::= hesperus
        GL3 Rule 3: hesperus ::= venus
          GL4 Symbol venus: "venus"
      Symch #0.1
      GL2 Rule 2: planet ::= phosphorus
        GL5 Rule 4: phosphorus ::= venus
          GL6 Symbol venus: "venus"

=for Marpa::R2::Display::End

Notice the tags of the form "C<GLn>", where I<n> is an integer.
These identify the glade.
(Glades will be described in detail below.)

=head2 An example of a factoring

For the grammar,

=for Marpa::R2::Display
name: ASF factoring dump example grammar
normalize-whitespace: 1
partial: 1

    :start ::= top
    top ::= b b
    b ::= a a
    b ::= a
    a ~ 'a'

=for Marpa::R2::Display::End

and the input 'C<aaa>',
a successful parse will always have two C<b>'s.
Of these two C<b>'s one will always be short, deriving a 
a single C<a>,
The other will always be long, deriving two
C<a>'s.
But they can be in either order,
which means that the two C<b>'s can divide up the input stream in
two different ways:

=over 4

=item * Long first, short second.

=item * Short first, long second.

=back

These two different ways of dividing the input stream using the rule

=for Marpa::R2::Display
name: ASF factoring dump example grammar
normalize-whitespace: 1
partial: 1

    top ::= b b

=for Marpa::R2::Display::End

are called a B<factoring>.  Here's Marpa's dump of the forest:

=for Marpa::R2::Display
name: ASF factoring dump example output
remove-blank-last-line: 1
remove-display-indent: 1

    GL2 Rule 1: top ::= b b
      Factoring #0
        GL3 Rule 3: b ::= a
          GL4 Symbol a: "a"
        GL5 Rule 2: b ::= a a
          GL6 Symbol a: "a"
          GL7 Symbol a: "a"
      Factoring #1
        GL8 Rule 2: b ::= a a
          GL9 Symbol a: "a"
          GL10 Symbol a: "a"
        GL11 Rule 3: b ::= a
          GL12 Symbol a: "a"

=for Marpa::R2::Display::End

=head1 The structure of a forest

The intuitive forest of an ASF, can be pictured as on a mountain.  The forest has glades,
and there are paths between them.
The term "glade" comes from the idea of a glade as a distinct place in a forest that is
open to light.
The paths between glades have a direction -- they are always thought of
as running downhill.
If a path connects two glades, the one uphill is called an upglade and the
one downhill is called a downglade.

There is a glade at the top of mountain called the "peak".
The peak has no upglades.

=head1 The glade hierarchy

Every glade has the same internal structure, which is this hierarchy:

=over 4

=item * Glades contain symches.  Symches can be for rules or for tokens.

=item * Rule symches contain factorings.

=item * Factorings contain factors.

=item * A factor is the uphill end of a path which leads to a downglade.
That downglade will contain a glade hierarchy of its own.

=back

=head2 Glades

Glade nodes represent a possible instance of a symbol in a parse.
Each glade has a symbol (called the "glade symbol"),
and an "input span".
An input span is an input start location, and a length in characters.
Because it has a start location and a length, each span also has
a end location in the input.

=head2 Symches

A glade will have one or more symches as children.
If a glade has only one symch, that symch is said to be a B<trivial> symch.
Symches may be token symches or rule symches.
For a token, the glade symbol will be the token symbol.
For a rule, the glade symbol will be the LHS of the rule.

Only one of the symches in a glade can be a token symch.
There can, however, be many rule symches in a glade --
one for every rule with the glade symbol on its LHS.

=head2 Factorings

Each rule symch contains one or more factorings.
A factoring is a way of dividing up the input span of the glade among its RHS symbols,
which in this context are called B<factors>.
If a rule symch has only one factoring, that factoring is said to be B<trivial>.
A token symch contains no factorings.
Within an ASF,
the token symches are it B<terminals>.

Because the number of factorings can get out of hand,
factorings may be ommitted.
A symch which omits factorings is said to be B<truncated>.
By default, every symch is truncated down to its first 42 factorings.

=head2 Factors

Every factoring has one or more factors.
Each "factor" corresponds to a symbol instance on the RHS of the rule.
Each such RHS factor is also a downglade, one which contains its own
symches.

=head1 The Glade ID

Each glade has a glade ID.
This can be relied on to be a non-negative integer.
A glade ID may be zero.
Glade ID's are obtained from the L</"peak()">
and L</"factoring_downglades()"> methods.

=head1 Techniques for traversing ASF's

=head2 Memoization

When traversing a forest, you should to take steps to avoid
traversing the same glades twice.
You can do this by memoizing the result of each glade, perhaps
using its glade ID to index a glade.
When a glade is visited, it can be checked to see if its result has
been memoized.
If so the memoized result is used.

This memoization eliminates the need to revisit the downglades
of an already visited glade.
It does not eliminate multiple visits to a glade, but it does
eliminate retraversal of the glades downhill from it.
In practice, the improvement in speed can be stunning.
It will often be the difference between 
an program which is unuseably slow even for very small inputs,
and one which is very extremely fast even for large inputs.

Repeated subtraversals happen which two upper glades share the same lower
glade.  This is a very frequent occurrence in ASF's.
Additionally, the underlying algorithm allows cycles, and some day the SLIF will
as well.
Traversing a cycle will cause an infinite loop unless you memoize.

The example in this POD includes a memoization scheme which is very simple,
but adequate for most purposes.
The main logic of it is shown here.

=head1 The Glade ID

Each glade has a glade ID.
This can be relied on to be a non-negative integer.
A glade ID may be zero.
Glade ID's are obtained from the L</"peak()">
and L</"factoring_downglades()"> methods.

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

        my ( $asf, $glade, $seen ) = @_;
        return bless ["Glade $glade revisited"], 'My_Revisit'
            if $seen->[$glade];
        $seen->[$glade] = 1;

=for Marpa::R2::Display::End

As you can see, memoization is not hard.
Putting memoization in your very first drafts of code
will save you time and trouble.

=head1 Constructor

=head2 new()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 1
normalize-whitespace: 1
partial: 1

  my $asf = Marpa::R2::ASF->new( { slr => $slr } );
  die 'No ASF' if not defined $asf;

=for Marpa::R2::Display::End

Creates a new ASF object.
Must be called with a list of one or more hashes of named arguments.
Current only one named argument is allowed, the C<slr> argument, and
that argument is required.
The value of the C<slr> argument must be a SLIF recognizer object.

Returns the new ASF object, or undef if there was a problem.

=head1 Forest Methods

These "forest" methods deal with the ASF as a whole,
as compared to methods with a focus on specific glades,
symches, factorings or factors.

=head2 grammar()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $grammar     = $asf->grammar();

=for Marpa::R2::Display::End

Returns the SLIF grammar associated with the ASF.
This can be convenient when using SLIF grammar methods
while examining an ASF.
All failures are thrown as exceptions.

=head2 peak()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $peak = $asf->peak();

=for Marpa::R2::Display::End

Returns the glade ID of the peak.
This may be zero.
All failures are thrown as exceptions.

=head1 Glade Methods

=head2 glade_literal()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

        my $literal = $asf->glade_literal($glade);

=for Marpa::R2::Display::End

Returns the literal substring of the input associated
with the glade.
Every glade is associated with a span -- a start location in the input,
and a length.
On failure, throws an exception.

The literal is determined by the range.
This works as expected if your application reads the input characters 
one-by-one in order.
(We will call applications which read in this fashion, monotonic.)
Your application is monotonic, unless you've taken special measures to make it otherwise.
Computation of literal substrings for non-monotonic applications
is addressed in L<Marpa::R2::Scanless::R/"Literals and G1 spans">.

=head2 glade_symch_count()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $symch_count = $asf->glade_symch_count($glade);

=for Marpa::R2::Display::End

Requires a glade ID as its only argument.
Returns the number of symches downhill from the glade specified by the argument.
On failure, throws an exception.

=head2 glade_symbol_id()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $symbol_id    = $asf->glade_symbol_id($glade);
    my $display_form = $grammar->symbol_display_form($symbol_id);

=for Marpa::R2::Display::End

Requires a glade ID as its only argument.
Returns the symbol ID of the "glade symbol" for the glade specified by the argument.
On failure, throws an exception.

=head1 Symch Methods

=head2 symch_rule_id()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $rule_id = $asf->symch_rule_id( $glade, $symch_ix );

=for Marpa::R2::Display::End

Requires two arguments: a glade ID and a zero-based symch index.
These specify a symch.
If it is a rule symch, returns the rule ID.
If it is a token symch, returns -1.

Returns a Perl undef, if the glade exists, but the symch index is too high.
On other failure, throws an exception.

=head2 symch_is_truncated()

[ To be written. ]

=head2 symch_factoring_count()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $factoring_count =
        $asf->symch_factoring_count( $glade, $symch_ix );

=for Marpa::R2::Display::End

Requires two arguments: a glade ID and a zero-based symch index.
For a rule symch,
returns the numbers of factorings in the symch specified by the two arguments.
This will always be one or greater.
For a token symch, returns zero.

Returns a Perl undef, if the glade exists, but the symch index is too high.
On other failure, throws an exception.

=head1 Factoring Methods

=head2 factoring_downglades()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $downglades =
        $asf->factoring_downglades( $glade, $symch_ix,
        $factoring_ix );

=for Marpa::R2::Display::End

Requires three arguments: a glade ID,
the zero-based index of a symch
and the zero-based index of a factoring.
On success, returns a reference to an array.
The array contains the glade IDs of the the downglades in
the factoring specified by the arguments.

Returns a Perl undef, if the glade and symch exists, but the factoring index is too high.
On other failure, throws an exception.
In particular, exceptions are thrown if the symch is for a token;
and if the glade exists, but the symch index is too high.

=head1 Methods for reporting ambiguity

=for Marpa::R2::Display
name: ASF ambiguity reporting
normalize-whitespace: 1
partial: 1

        if ( $recce->ambiguity_metric() > 1 ) {
            my $asf = Marpa::R2::ASF->new( { slr => $recce } );
            die 'No ASF' if not defined $asf;
            my $ambiguities = Marpa::R2::Internal::ASF::ambiguities($asf);

            # Only report the first two
            my @ambiguities = grep {defined} @{$ambiguities}[ 0 .. 1 ];

            $actual_value  = 'Application grammar is ambiguous';
            $actual_result = Marpa::R2::Internal::ASF::ambiguities_show( $asf,
                \@ambiguities );
            last PROCESSING;
        } ## end if ( $recce->ambiguity_metric() > 1 )

=for Marpa::R2::Display::End

=head2 ambiguities()

=for Marpa::R2::Display
name: ASF ambiguity reporting
normalize-whitespace: 1
partial: 1

    my $ambiguities = Marpa::R2::Internal::ASF::ambiguities($asf);

=for Marpa::R2::Display::End

Returns a reference to an array of ambiguity reports in the ASF.
The first and only argument must be an ASF object.
The array returned will be be zero length if the parse was not ambiguous.
Ambiguity reports are as L<described below|"Ambiguity reports">.

While the C<ambiguities()> method can be called to determine whether
or not ambiguities exist, it is the more expensive way to do it.
The L<$slr-E<gt>ambiguity_metric() method|Marpa::R2::Scanless::R/"ambiguity_metric()">
tests an already-existing boolean and is therefore extremely fast.
If you are simply testing for ambiguity,
or if you can save time when you know that a parse is unambiguous,
you will usually want to test for ambiguity with the C<ambiguity_metric()> method
before calling the C<ambiguities()> method.

=head2 ambiguities_show()

=for Marpa::R2::Display
name: ASF ambiguity reporting
normalize-whitespace: 1
partial: 1

    $actual_result = Marpa::R2::Internal::ASF::ambiguities_show( $asf,
        \@ambiguities );

=for Marpa::R2::Display::End

Returns a string which contains a description of the ambiguities in its arguments.
Takes two arguments, both required.
The first is an ASF, and the second is a reference to an array of ambiguities,
in the format returned by L<the ambiguities() method|/"ambiguities()">.

Major applications will often have their own 
customized ambiguity formatting routine, one which can formulate
error messages based, not just on the names of the rules and symbols,
but knowledge of what role the rules and symbols mean in
the application.
This method is intended for applications which do not have
their own customized ambiguity handling.
For those which do, it can be used
as a fallback for handling those reports that the customized method does not recognize
or that do not need special handling.
The format of the returned string is subject to change.

=head1 Ambiguity reports

The ambiguity reports returned by the L<C<ambiguities()> method|/"ambiguities()">
are of two kinds: symch reports and factoring reports.

=head2 Symch reports

A symch report is issued whenever, in a top-down traversal of the ASF,
an non-trivial symch is encountered.

A symch report takes the form

=for Marpa::R2::Display
ignore: 1

   [ 'symch', $glade ]

=for Marpa::R2::Display::End

where C<$glade> is the ID of the glade with the symch ambiguity.
With this and the glade accessors, an applicaiton can report full
details of the symch ambiguity.

Typically, when there is more than one kind of ambiguity in an input span, only
one is of real interest.
Symch ambiguities are usually of more interest than factorings.
And if one ambiguities is uphill from another, the downhill ambiguity is usually
a side effect of the uphill one.

Accordingly, if there is both a symch ambiguity and a factoring ambiguity in a glade,
only the symch ambiguity is reported.
And if two ambiguities in the ASF overlap, only the one closest to the peak is reported.

=head2 Factoring reports

A symch report is issued whenever, in a top-down traversal of the ASF,
an sequence of symbols is found which has more than one factoring.
Factoring reports are specific -- they identify not just rules,
but the specific sequences within the RHS
which are differently factored -- B<multi-factored stretches>.
A single rule, if the symbol fall into step with each other and then
out of step, may have several multifactored stretches.
Identifying specific multifactored stretches
is useful when dealing with sequence rules,
whose RHS's can be very long.
The details of how an multifactored stretch is defined are L<below|/"Multifactored stretches">.

A factoring report takes the form

=for Marpa::R2::Display
ignore: 1

    [ 'factoring', $glade, $symch_ix, $factor_ix1, $factoring_ix2, $factor_ix2 ];

=for Marpa::R2::Display::End

where C<$glade> is the identifier of the glade with the symch ambiguity,
and C<$symch_ix> is the index of the symch involved.
The the ambiguously factored stretch is indicated by the identifying
two the factors at its beginning which differ in length.
(Since they are at the beginning of an ambiguous stretch, the two factors
will have the same start location in the input.)

To identify a factor within a symch, it is necessary to know the
index of the factoring, and the index of the factor.
The first factor will always have a factoring index of 0,
and its factor index is C<$factor_ix1>.
The second factor will have have a factoring index of C<$factoring_ix2>,
and its factor index is C<$factor_ix2>.

More information is not given because full information can voluminous --
ambiguously factoring stretch can be lengthy, and the number of factorings
can be in the thousands or higher.
Error reporting is the primary application,
two differing factors at the beginning of each ambiguous stretch is
usually all that is wanted for error reporting.
An application that does not need to know more can find it using
using the glade accessors.

Ambiguities in rules and symbols underneath an ambiguously factored stretch
are not reported.
If a glade has both a symch ambiguity and stretches of factoring ambiguity,
only the symch ambiguity is reported.

=head1 The code for the synopsis

=head2 The asf_to_basic_tree() code

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1

    sub asf_to_basic_tree {
        my ( $asf, $glade ) = @_;
        my $peak = $asf->peak();
        return glade_to_basic_tree( $asf, $peak, [] );
    } ## end sub asf_to_basic_tree

    sub glade_to_basic_tree {
        my ( $asf, $glade, $seen ) = @_;
        return bless ["Glade $glade revisited"], 'My_Revisit'
            if $seen->[$glade];
        $seen->[$glade] = 1;
        my $grammar     = $asf->grammar();
        my @symches     = ();
        my $symch_count = $asf->glade_symch_count($glade);
        SYMCH: for ( my $symch_ix = 0; $symch_ix < $symch_count; $symch_ix++ ) {
            my $rule_id = $asf->symch_rule_id( $glade, $symch_ix );
            if ( $rule_id < 0 ) {
                my $literal      = $asf->glade_literal($glade);
                my $symbol_id    = $asf->glade_symbol_id($glade);
                my $display_form = $grammar->symbol_display_form($symbol_id);
                push @symches,
                    bless [qq{Glade $glade, Symbol $display_form: "$literal"}],
                    'My_Token';
                next SYMCH;
            } ## end if ( $rule_id < 0 )

            # ignore any truncation of the factorings
            my $factoring_count =
                $asf->symch_factoring_count( $glade, $symch_ix );
            my @symch_description = ("Glade $glade");
            push @symch_description, "Symch $symch_ix" if $symch_count > 1;
            push @symch_description, $grammar->rule_show($rule_id);
            my $symch_description = join q{, }, @symch_description;

            my @factorings = ($symch_description);
            for (
                my $factoring_ix = 0;
                $factoring_ix < $factoring_count;
                $factoring_ix++
                )
            {
                my $downglades =
                    $asf->factoring_downglades( $glade, $symch_ix,
                    $factoring_ix );
                push @factorings,
                    map { glade_to_basic_tree( $asf, $_, $seen ) } @{$downglades};
            } ## end for ( my $factoring_ix = 0; $factoring_ix < $factoring_count...)
            push @symches,
                bless [
                "Glade $glade, symch $symch_ix has $factoring_count factorings",
                @factorings
                ],
                'My_Factorings'
                if $factoring_count > 1;
            push @symches, bless [ @factorings[ 0, 1 ] ], 'My_Rule';
        } ## end SYMCH: for ( my $symch_ix = 0; $symch_ix < $symch_count; ...)
        return bless [ "Glade $glade has $symch_count symches", @symches ],
            'My_Symches'
            if $symch_count > 1;
        return $symches[0];
    } ## end sub glade_to_basic_tree

=for Marpa::R2::Display::End

Because of the blessings in this example, a standard dump of the output array is
too cluttered for comfortable reading.
The following code displays the output array in a more compact form.
This code actually works for all arrays and makes no use of Marpa, 
but it is included for completeness,
and to provide a simple example of array traversal.

=head2 The array_display() code

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 3
normalize-whitespace: 1

    sub array_display {
        my ($array) = @_;
        my ( undef, @lines ) = @{ array_lines_display($array) };
        my $text = q{};
        for my $line (@lines) {
            my ( $indent, $body ) = @{$line};
            $indent -= 4;
            $text .= ( q{ } x $indent ) . $body . "\n";
        }
        return $text;
    } ## end sub array_display

    sub array_lines_display {
        my ($array) = @_;
        my $reftype = Scalar::Util::reftype($array) // '!undef!';
        return [ [ 0, $array ] ] if $reftype ne 'ARRAY';
        my @lines = ();
        ELEMENT: for my $element ( @{$array} ) {
            for my $line ( @{ array_lines_display($element) } ) {
                my ( $indent, $body ) = @{$line};
                push @lines, [ $indent + 2, $body ];
            }
        } ## end ELEMENT: for my $element ( @{$array} )
        return \@lines;
    } ## end sub array_lines_display

=for Marpa::R2::Display::End

=head1 Details

This section contains some mathematical elaborations of the above.
These details are segregated because they are not essential to using this interface,
and while some readers find them more helpful than distracting,
for others it is the reverse.

=head2 An alternative way of defining glade terminology

Here's a way of defining some of the above terms which is less intuitive,
but more precise.
First, define the B<glade length> from glades A to glade B in an ASF as 
the number of glades on the shortest path from A to B, not including glade A.
(Recall that paths are directional.)
If there is no path between glades A and B, the glade length is undefined.
Glade B is a B<downglade> of glade A,
and a glade A is an B<upglade> of glade B,
if and only if the glade length from A to B is 1.

A glade A is B<upper> with respect to glade B,
and a glade B is B<lower> with respect to glade A,
if and only if the glade length from A to B is defined.

A B<peak> of an ASF is a node without upglades.
By construction of the ASF, there is only one peak.
A glade is B<trivial> if and only if it has exactly one downglade.

=head2 Cycles

In the current SLIF implementation, a forest is a directed acyclic graph (DAG).
(In the mathematical literature a DAG is also called a "tree", but that use is confusing
in the present context.)
The underlying Marpa algorithm allows parse trees with cycles,
and someday the SLIF probably will as well.
When that happens, ASF's will no longer be "acyclic" and therefore will no
longer be DAG's.
This document talks about ASF's as if they could contain cycles,
when parse trees with cycles are encountered,
the applications which follow the guidelines in this document
will be ready for them.

One consequence of an ASF containing cycles is that two glades can be both uphill and downhill
from each other.
That is if glade A cycles back to itself through glade B,
glade A will be uphill from glade B,
and glade B will be uphill from glade A.
This means that glade B will be downhill from glade A,
and glade A will be downhill glade B,

This means the sense of downhill and uphill will becomes more complicated.
ASF's will always be constructed so that the peak has no upglades, however,
so that, even in an ASF with cycles, the peak will always be uphill from all glades,
and all other glades will always be downhill from the peak.

=head2 Token symches

In the current SLIF implementation, a symbol is always either a token
or the LHS of a rule.
This means that every glade either that contains a token symch
cannot contain any rule symches, and vice versa.

However, the underlying Marpa algorithm allows LHS terminals,
and someday the SLIF probably will as well.
For this reason, the descriptions in this document always describes
glades as if they could contain both rule symches and a token symch.

=head2 Maximum symches per glade

There can be at most one token symch, plus a rule symch
for every rule in the grammar.
That means the maximum number of symbolic choices in a glade is
one plus
the number of rules in the grammar.

=head2 Multifactored stretches

When locating factoring ambiguities, Marpa drills down below the rule level.
This is very useful for ambiguities in sequence rules, whose RHS's can be very long.

Recall that each factoring contains one or more factors, each of which has a symbol and a span.
A B<symbol sequence> is a sequence of one or more symbols of a specific type in a specific order,
the first symbol of which starts at a specific input location.
A specific occurrence of a symbol in a symbol sequence is an B<instance>.
Symbol sequence instances have offsets, numbered in order within the sequence
starting with the first symbol, and zero-based.
The number of symbols in the sequence is its B<length>, and will be one greater
than the maximum offset of any of its instances.
Symbol stretches align in the input,
but symbol stretches in different factorings do not have to align by factor index.
In factorings of sequence rules, where the RHS consists of repetitions of a single symbol,
a short stretch might be found at many factor indexes in each of the factorings.

Intuitively, a B<factoring position> is a location among the factors of a factoring.
It can be considered to be a duple of factoring index and factor index.
The factor at the start of the factoring position is the B<base factor>.
Given a factoring position, the factors of its factoring will have offsets relative to
the base factor.
Factor offsets are zero-based, so that the base factor has offset 0.
An factor corresponds to an instance of a symbol sequence, relative to a factoring position,
if the instance offset is the same as the factor offset.

An instance of a symbol sequence is ambiguous in a set of factorings,
if and only if, for some choice of factoring positions,
two or more of the corresponding factors match different spans of the input.
A symbol sequence is ambiguous in a set of factorings,
if every instance in it is ambiguous in that set of factorings.
An instance of a symbol sequence is ambiguous in a symch if and only if it is ambiguous in the symch's set of factoring.
An symbol sequence is ambiguous in a symch if and only if it is ambiguous in the symch's set of factorings.
A symch is multifactored if and only if some symbol sequence is ambiguous in it.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
