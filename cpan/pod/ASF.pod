# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::ASF - Marpa's abstract syntax forests (ASF's)

=head1 Synopsis

We want to "diagram" the following sentence.

=for Marpa::R2::Display
name: ASF synopsis input
normalize-whitespace: 1

  my $sentence = 'a panda eats shoots and leaves.';

=for Marpa::R2::Display::End

Here's the result we are looking for.  It is in Penntag form:

=for Marpa::R2::Display
name: ASF synopsis output
partial: 1
remove-display-indent: 1
remove-blank-last-line: 1

  (S (NP (DT a) (NN panda))
     (VP (VBZ eats) (NP (NNS shoots) (CC and) (NNS leaves)))
     (. .))
  (S (NP (DT a) (NN panda))
     (VP (VP (VBZ eats) (NP (NNS shoots))) (CC and) (VP (VBZ leaves)))
     (. .))
  (S (NP (DT a) (NN panda))
     (VP (VP (VBZ eats)) (VP (VBZ shoots)) (CC and) (VP (VBZ leaves)))
     (. .))

=for Marpa::R2::Display::End

Here is the grammar.

=for Marpa::R2::Display
name: ASF synopsis grammar
normalize-whitespace: 1
remove-display-indent: 1
remove-blank-last-line: 1

  :default ::= action => [values] bless => ::lhs
  lexeme default = action => [value] bless => ::name

  S   ::= NP  VP  period  bless => S

  NP  ::= NN              bless => NP
      |   NNS          bless => NP
      |   DT  NN          bless => NP
      |   NN  NNS         bless => NP
      |   NNS CC NNS  bless => NP

  VP  ::= VBZ NP          bless => VP
      | VP VBZ NNS        bless => VP
      | VP CC VP bless => VP
      | VP VP CC VP bless => VP
      | VBZ bless => VP

  period ~ '.'

  :discard ~ whitespace
  whitespace ~ [\s]+

  CC ~ 'and'
  DT  ~ 'a' | 'an'
  NN  ~ 'panda'
  NNS  ~ 'shoots' | 'leaves'
  VBZ ~ 'eats' | 'shoots' | 'leaves'

=for Marpa::R2::Display::End

Here's the code. It actually does two traversals, one that produces the full result as
shown above, and another which "prunes" the forest down to a single tree.

=for Marpa::R2::Display
name: ASF synopsis code
normalize-whitespace: 1

  my $panda_grammar = Marpa::R2::Scanless::G->new( { source => \$dsl } );
  my $panda_recce = Marpa::R2::Scanless::R->new( { grammar => $panda_grammar } );
  $panda_recce->read( \$sentence );
  my $asf = Marpa::R2::ASF->new( { slr=>$panda_recce } );
  my $full_result = $asf->traverse( {}, \&full_traverser );
  my $pruned_result = $asf->traverse( {}, \&pruning_traverser );

=for Marpa::R2::Display::End

The code for the full traverser is in an appendex.
The pruning code is simpler.  Here it is:

=for Marpa::R2::Display
name: ASF synopsis pruning traverser code
normalize-whitespace: 1

  sub penn_tag {
     my ($symbol_name) = @_;
     return q{.} if $symbol_name eq 'period';
     return $symbol_name;
  }

  sub pruning_traverser {

      # This routine converts the glade into a list of Penn-tagged elements.  It is called recursively.
      my ($glade, $scratch)     = @_;
      my $rule_id     = $glade->rule_id();
      my $symbol_id   = $glade->symbol_id();
      my $symbol_name = $panda_grammar->symbol_name($symbol_id);

      # A token is a single choice, and we know enough to fully Penn-tag it
      if ( not defined $rule_id ) {
	  my $literal = $glade->literal();
	  my $penn_tag = penn_tag($symbol_name);
	  return "($penn_tag $literal)";
      }

      my $length = $glade->rh_length();
      my @return_value = map { $glade->rh_value($_) } 0 .. $length - 1;

      # Special case for the start rule
      return (join q{ }, @return_value) . "\n" if  $symbol_name eq '[:start]' ;

      my $join_ws = q{ };
      $join_ws = qq{\n   } if $symbol_name eq 'S';
      my $penn_tag = penn_tag($symbol_name);
      return "($penn_tag " . ( join $join_ws, @return_value ) . ')';

  }

=for Marpa::R2::Display::End

Here is the "pruned" output:

=for Marpa::R2::Display
name: ASF pruned synopsis output
remove-display-indent: 1
remove-blank-last-line: 1

  (S (NP (DT a) (NN panda))
     (VP (VBZ eats) (NP (NNS shoots) (CC and) (NNS leaves)))
     (. .))

=for Marpa::R2::Display::End

=head1 THIS INTERFACE is ALPHA and EXPERIMENTAL

The interface described in this document is very much a work in progress.
It is alpha and experimental.
The bad side of this is that it is subject to change from version to
version in major ways,
rapidly and without notice.

=head1 About this document

This document describes the abstract syntax forests (ASFs) of
Marpa's SLIF interface.
An ASF is an efficient and practical way to represent multiple abstract syntax trees (AST's).

=head1 Constructor

=head2 new()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 1
normalize-whitespace: 1
partial: 1

  my $asf = Marpa::R2::ASF->new( { slr => $slr } );
  die 'No ASF' if not defined $asf;

=for Marpa::R2::Display::End

Creates a new ASF object.
Must be called with a list of one or more hashes of named arguments.
Current only one named argument is allowed, the C<slr> argument, and
that argument is required.
The value of the C<slr> argument must be a SLIF recognizer object.

Returns the new ASF object, or undef if there was a problem.

=head1 Accessor

=head2 grammar()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $grammar     = $asf->grammar();

=for Marpa::R2::Display::End

Returns the SLIF grammar associated with the ASF.
This can be convenient when using SLIF grammar methods
while examining an ASF.
All failures are thrown as exceptions.

=head1 The traverser method

=head2 traverse()

=for Marpa::R2::Display
name: ASF synopsis code
normalize-whitespace: 1
partial: 1

  my $full_result = $asf->traverse( {}, \&full_traverser );

=for Marpa::R2::Display::End

Returns the value of the traversal,
which is computed as described below.
It requires two arguments: a reference to a traverser function,
and a per-traversal object, which should be a Perl reference.
Discussion of how to write a traverser follows.
The C<traverse()> method may be called repeatedly for an ASF,
with the same traverser, or with different ones.

=head1 How to write a traverser

The process of
writing a traverser will be familiar if you have experience with
traversing trees.
The traverser may be called at every node of the forest.
(These nodes are called B<glades>.)
The traverser must return a value, and this will be become the value.
of the glade.
The value of the topmost glade (called the B<peak>) becomes the value
of the traversal, and is the value returned by
L<the C<traverse()> method|/"traverse()">.

The traverser is called at most once for each glade -- subsequent
attempts to determine the value of a glade will return a memoized
value.
The traverser is always invoked for the peak, and for any glade whose
value is required.
It may or may not be invoked for other glades.

The traverser is always invoked with two arguments.
The first of the two arguments to a traverser is 
the per-traversal object, which will be shared by all calls
in the traversal.
It may be used as a "scratch pad" for information
which it is not convenient to pass via return values,
as a means of avoiding the uses of globals.

The second traverser arguments will be a B<glade object>.
Methods of the glade object are used to find information about
the glade, and to move around in it.

"Moving around" in a glade means visiting its B<parse alternatives>.
The parse alternatives, called B<alternatives> where the meaning is clear.
(If a glade has exactly one alternative, it is called a B<trivial glade>.)
When invoked, the traverser points at the first alternative.
Alternatives after the first may be visited using the
L<the C<next()> glade method|/"traverse()">.

Parse alternatives may be either token
alternatives or rule alternatives.
Whether or not the current alternative of the glade is a rule
can be determined using the
L<the C<rule_id()> glade method|/"traverse()">,
which returns undefined if and only if the glade is positioned at a token
alternative.

At all alternatives,
L<the C<span()>|/"span()"> and
L<the C<literal()>|/"literal()"> glade methods
are of use.
L<the C<symbol_id()> glade method|/"symbol_d()"> is
also always of use although its meaning varies.
At token alteratives, the C<symbol_id()> method returns the 
token symbol.
At rule alteratives, the C<symbol_id()> method returns the 
ID of the LHS of the rule.

At rule alternatives,
L<the C<rh_count()>|/"rh_count()"> and
L<the C<rh_value()>|/"rh_value()"> glade methods
are of use.
The C<rh_count()> method returns the length of the RHS,
and the C<rh_value()> method returns the value of one of the
RHS children, as determined using its traverser.

At the peak of the ASF, the symbol will be named 'C<[:start]>'.
This case often requires special treatment.
Note that it is entirely possible for the peak to be a non-trivial
glade.

=head1 Traversal accessors

These are the methods that must be called in the context of a traversal routine.
The descriptions state whether the value remains constant within a glade,
or within a symch.
Symches are a concern for some advanced applications.
A symch is either a series of alternatives which share the same rule,
or a token alternative.

=head2 literal()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $literal = $glade->literal();

=for Marpa::R2::Display::End

=head2 span()

=for Marpa::R2::Display::Start
name: ASF span() traverser method example
normalize-whitespace: 1
partial: 1

  my ( $start, $length ) = $glade->span();
  my $end = $start + $length - 1;

=for Marpa::R2::Display::End

=head2 symbol_id()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

    my $symbol_id   = $glade->symbol_id();

=for Marpa::R2::Display::End

=head2 rule_id()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $rule_id     = $glade->rule_id();

=for Marpa::R2::Display::End

Returns the ID of the rule for the current
alternative, which will be non-negative,
but which may be zero.
Returns C<undef> if and only if the current
alternative is a token alternative.
Takes no arguments.
Always constant within a symch.

=head2 rh_length()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $length = $glade->rh_length();

=for Marpa::R2::Display::End

=head2 rh_value()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $child_value = $glade->rh_value($rh_ix);

=for Marpa::R2::Display::End

=head2 next()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  last CHOICE if not defined $glade->next();

=for Marpa::R2::Display::End

When moving through a glade using
the C<traverse()> method,
all alternatives which share the same symch will be
visited before any alternatives from other symches
are visited.

=head1 Appendix: full traverser code

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1

  sub full_traverser {

      # This routine converts the glade into a list of Penn-tagged elements.  It is called recursively.
      my ($glade, $scratch)     = @_;
      my $rule_id     = $glade->rule_id();
      my $symbol_id   = $glade->symbol_id();
      my $symbol_name = $panda_grammar->symbol_name($symbol_id);

      # A token is a single choice, and we know enough to fully Penn-tag it
      if ( not defined $rule_id ) {
	  my $literal = $glade->literal();
	  my $penn_tag = penn_tag($symbol_name);
	  return ["($penn_tag $literal)"];
      } ## end if ( not defined $rule_id )

      # Our result will be a list of choices
      my @return_value = ();

      CHOICE: while (1) {

	  # The results at each position are a list of choices, so
	  # to produce a new result list, we need to take a Cartesian
	  # product of all the choices
	  my $length = $glade->rh_length();
	  my @results = ( [] );
	  for my $rh_ix ( 0 .. $length - 1 ) {
	      my @new_results = ();
	      for my $old_result (@results) {
		  my $child_value = $glade->rh_value($rh_ix);
		  for my $new_value ( @{ $child_value } ) {
		      push @new_results, [ @{$old_result}, $new_value ];
		  }
	      }
	      @results = @new_results;
	  } ## end for my $rh_ix ( 0 .. $length - 1 )

	  # Special case for the start rule
	  if ( $symbol_name eq '[:start]' ) {
	      return [ map { join q{}, @{$_} } @results ];
	  }

	  # Now we a list of choices, as a list of lists.  Each sub list
	  # is a list of Penn-tagged elements, which we need to join into
	  # a single Penn-tagged element.  The result will be to collapse
	  # one level of lists, and leave us with a list of Penn-tagged
	  # elements
	  my $join_ws = q{ };
	  $join_ws = qq{\n   } if $symbol_name eq 'S';
	  push @return_value,
	      map { '(' . penn_tag($symbol_name) . q{ } . ( join $join_ws, @{$_} ) . ')' }
	      @results;

	  # Look at the next alternative in this glade, or end the
	  # loop if there is none
	  last CHOICE if not defined $glade->next();

      } ## end CHOICE: while (1)

      # Return the list of Penn-tagged elements for this glade
      return \@return_value;
  } ## end sub full_traverser

=for Marpa::R2::Display::End

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
